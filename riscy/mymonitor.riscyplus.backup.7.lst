
0000		org	0
0000		sliu d 15
0001		slil d 15
0002		stackpage	d	
	; calling global function setupdisplay

0003		push	d
0004		push	c
0005		push	b
0006		sliu d 0
0007		slil d 0
0008		push	d
0009		push	c
000a		sliu c 0
000b		slil c 1
000c		sliu d #setupdisplay	[00]
000d		slil d #setupdisplay	[00]
000e		jmpfar	d d
000f		pop	b
0010		pop	c
0011		pop	d	; calling global function monitor_entry

0012		push	d
0013		push	c
0014		push	b
0015		sliu d 0
0016		slil d 0
0017		push	d
0018		push	c
0019		sliu c 0
001a		slil c 2
001b		sliu d #monitor_entry	[00]
001c		slil d #monitor_entry	[00]
001d		jmpfar	d d
001e		pop	b
001f		pop	c
0020		pop	d	

0021		halt	

0022		org	100	
	; ------- GLOBAL FUNCTION setupdisplay -------

0100	#setupdisplay
0100		pop	c
0101		push	d
0102		sliu d 0
0103		slil d 1
0104		out	d
0105		sliu d 8
0106		slil d 0
0107		out	d	;	li	d,0x02
	;	out	d
	;	li	d,0x02
	;	out	d
	;	li	d,0x0c
	;	out	d
	;	li	d,0x00
	;	out	d
	;	li	d,0x0f
	;	out	d
	;	li	d,0x00
	;	out	d
	;	li	d,0x01
	;	out	d

0108		pop	d
0109		pop	c
010a		jmpfar	d d	
	; setupdisplay ends
	
	

010b		org	200	
	; ------- GLOBAL FUNCTION monitor_entry -------

0200	#monitor_entry
0200		pop	c
0201		push	d		; print out "RISCY Monitor"

0202		sliu a 7
0203		slil a 15
0204		sliu b #monitor_message	[00]
0205		slil b #monitor_message	[00]	; calling global function printstring

0206		push	d
0207		push	c
0208		push	b
0209		sliu d 0
020a		slil d 2
020b		push	d
020c		push	c
020d		sliu c 0
020e		slil c 5
020f		sliu d #printstring	[00]
0210		slil d #printstring	[00]
0211		jmpfar	d d
0212		pop	b
0213		pop	c
0214		pop	d
0215	#monitor	; calling global function readprompt

0215		push	d
0216		push	c
0217		push	b
0218		sliu d 0
0219		slil d 2
021a		push	d
021b		push	c
021c		sliu c 0
021d		slil c 8
021e		sliu d #readprompt	[02]
021f		slil d #readprompt	[02]
0220		jmpfar	d d
0221		pop	b
0222		pop	c
0223		pop	d		; read a line into 0xfd:0

0224		sliu a 15
0225		slil a 13
0226		sliu b 0
0227		slil b 0	; calling global function readstring

0228		push	d
0229		push	c
022a		push	b
022b		sliu d 0
022c		slil d 2
022d		push	d
022e		push	c
022f		sliu c 0
0230		slil c 6
0231		sliu d #readstring	[01]
0232		slil d #readstring	[03]
0233		jmpfar	d d
0234		pop	b
0235		pop	c
0236		pop	d	
	;	.call clearscreen
		;get command

0237		sliu a 15
0238		slil a 13
0239		page	a
023a		sliu b 0
023b		slil b 0
023c		load	a [b]	
		;check command

023d		push	a
023e		sliu d 4
023f		slil d 4
0240		sub	a d
0241		sliu d #@monitor_entry0	[04]
0242		slil d #@monitor_entry0	[09]
0243		skipz	a
0244		jalr	d d
0245		pop	a
0246		sliu d #domonitordump	[07]
0247		slil d #domonitordump	[04]
0248		jalr	d d
0249	#@monitor_entry0
0249		pop	a
024a		push	a
024b		sliu d 4
024c		slil d 5
024d		sub	a d
024e		sliu d #@monitor_entry1	[05]
024f		slil d #@monitor_entry1	[06]
0250		skipz	a
0251		jalr	d d
0252		pop	a
0253		sliu d #domonitoredit	[08]
0254		slil d #domonitoredit	[06]
0255		jalr	d d
0256	#@monitor_entry1
0256		pop	a
0257		push	a
0258		sliu d 4
0259		slil d 7
025a		sub	a d
025b		sliu d #@monitor_entry2	[06]
025c		slil d #@monitor_entry2	[03]
025d		skipz	a
025e		jalr	d d
025f		pop	a
0260		sliu d #domonitorgo	[0a]
0261		slil d #domonitorgo	[0a]
0262		jalr	d d
0263	#@monitor_entry2
0263		pop	a
0264		push	a
0265		sliu d 4
0266		slil d 2
0267		sub	a d
0268		sliu d #@monitor_entry3	[07]
0269		slil d #@monitor_entry3	[00]
026a		skipz	a
026b		jalr	d d
026c		pop	a
026d		sliu d #domonitorbasic	[09]
026e		slil d #domonitorbasic	[08]
026f		jalr	d d
0270	#@monitor_entry3
0270		pop	a	

0271		sliu d #monitor	[01]
0272		slil d #monitor	[05]
0273		jalr	d d	

0274	#domonitordump	; calling global function monitordump

0274		push	d
0275		push	c
0276		push	b
0277		sliu d 0
0278		slil d 2
0279		push	d
027a		push	c
027b		sliu c 0
027c		slil c 3
027d		sliu d #monitordump	[00]
027e		slil d #monitordump	[00]
027f		jmpfar	d d
0280		pop	b
0281		pop	c
0282		pop	d
0283		sliu d #monitor	[01]
0284		slil d #monitor	[05]
0285		jalr	d d
0286	#domonitoredit	; calling global function monitoredit

0286		push	d
0287		push	c
0288		push	b
0289		sliu d 0
028a		slil d 2
028b		push	d
028c		push	c
028d		sliu c 0
028e		slil c 3
028f		sliu d #monitoredit	[09]
0290		slil d #monitoredit	[0c]
0291		jmpfar	d d
0292		pop	b
0293		pop	c
0294		pop	d
0295		sliu d #monitor	[01]
0296		slil d #monitor	[05]
0297		jalr	d d
0298	#domonitorbasic	; calling global function basic

0298		push	d
0299		push	c
029a		push	b
029b		sliu d 0
029c		slil d 2
029d		push	d
029e		push	c
029f		sliu c 1
02a0		slil c 2
02a1		sliu d #basic	[00]
02a2		slil d #basic	[00]
02a3		jmpfar	d d
02a4		pop	b
02a5		pop	c
02a6		pop	d
02a7		sliu d #monitor	[01]
02a8		slil d #monitor	[05]
02a9		jalr	d d
02aa	#domonitorgo
02aa		sliu b 0
02ab		slil b 2
02ac		load	a [b]
02ad		inc	b
02ae		load	b [b]	; calling global function hextobin

02af		push	d
02b0		push	c
02b1		push	b
02b2		sliu d 0
02b3		slil d 2
02b4		push	d
02b5		push	c
02b6		sliu c 0
02b7		slil c 4
02b8		sliu d #hextobin	[08]
02b9		slil d #hextobin	[0f]
02ba		jmpfar	d d
02bb		pop	b
02bc		pop	c
02bd		pop	d
02be		pop	b
02bf		push	a
02c0		sliu d 0
02c1		slil d 4
02c2		add	b d
02c3		load	a [b]
02c4		inc	b
02c5		load	b [b]	; calling global function hextobin

02c6		push	d
02c7		push	c
02c8		push	b
02c9		sliu d 0
02ca		slil d 2
02cb		push	d
02cc		push	c
02cd		sliu c 0
02ce		slil c 4
02cf		sliu d #hextobin	[08]
02d0		slil d #hextobin	[0f]
02d1		jmpfar	d d
02d2		pop	b
02d3		pop	c
02d4		pop	d
02d5		pop	c
02d6		jmpfar	a a	

02d7		pop	d
02d8		pop	c
02d9		jmpfar	d d	
	; monitor_entry ends
	
	

02da		org 300	
	; ------- GLOBAL FUNCTION monitordump -------

0300	#monitordump
0300		pop	c
0301		push	d	; calling global function monitor_printaddress

0302		push	d
0303		push	c
0304		push	b
0305		sliu d 0
0306		slil d 3
0307		push	d
0308		push	c
0309		sliu c 0
030a		slil c 4
030b		sliu d #monitor_printaddress	[00]
030c		slil d #monitor_printaddress	[00]
030d		jmpfar	d d
030e		pop	b
030f		pop	c
0310		pop	d
0311		sub	b b	; calling global function monitor_getaddress

0312		push	d
0313		push	c
0314		push	b
0315		sliu d 0
0316		slil d 3
0317		push	d
0318		push	c
0319		sliu c 0
031a		slil c 4
031b		sliu d #monitor_getaddress	[05]
031c		slil d #monitor_getaddress	[0c]
031d		jmpfar	d d
031e		pop	b
031f		pop	c
0320		pop	d
0321		sub	b b
0322		add	b a
0323		load	a [b]	; calling global function printhex

0324		push	d
0325		push	c
0326		push	b
0327		sliu d 0
0328		slil d 3
0329		push	d
032a		push	c
032b		sliu c 0
032c		slil c 5
032d		sliu d #printhex	[01]
032e		slil d #printhex	[0f]
032f		jmpfar	d d
0330		pop	b
0331		pop	c
0332		pop	d
0333		sliu a 2
0334		slil a 0	; calling global function printchar

0335		push	d
0336		push	c
0337		push	b
0338		sliu d 0
0339		slil d 3
033a		push	d
033b		push	c
033c		sliu c 0
033d		slil c 5
033e		sliu d #printchar	[01]
033f		slil d #printchar	[09]
0340		jmpfar	d d
0341		pop	b
0342		pop	c
0343		pop	d
0344		inc	b
0345		load	a [b]	; calling global function printhex

0346		push	d
0347		push	c
0348		push	b
0349		sliu d 0
034a		slil d 3
034b		push	d
034c		push	c
034d		sliu c 0
034e		slil c 5
034f		sliu d #printhex	[01]
0350		slil d #printhex	[0f]
0351		jmpfar	d d
0352		pop	b
0353		pop	c
0354		pop	d
0355		sliu a 2
0356		slil a 0	; calling global function printchar

0357		push	d
0358		push	c
0359		push	b
035a		sliu d 0
035b		slil d 3
035c		push	d
035d		push	c
035e		sliu c 0
035f		slil c 5
0360		sliu d #printchar	[01]
0361		slil d #printchar	[09]
0362		jmpfar	d d
0363		pop	b
0364		pop	c
0365		pop	d
0366		inc	b
0367		load	a [b]	; calling global function printhex

0368		push	d
0369		push	c
036a		push	b
036b		sliu d 0
036c		slil d 3
036d		push	d
036e		push	c
036f		sliu c 0
0370		slil c 5
0371		sliu d #printhex	[01]
0372		slil d #printhex	[0f]
0373		jmpfar	d d
0374		pop	b
0375		pop	c
0376		pop	d
0377		sliu a 2
0378		slil a 0	; calling global function printchar

0379		push	d
037a		push	c
037b		push	b
037c		sliu d 0
037d		slil d 3
037e		push	d
037f		push	c
0380		sliu c 0
0381		slil c 5
0382		sliu d #printchar	[01]
0383		slil d #printchar	[09]
0384		jmpfar	d d
0385		pop	b
0386		pop	c
0387		pop	d
0388		inc	b
0389		load	a [b]	; calling global function printhex

038a		push	d
038b		push	c
038c		push	b
038d		sliu d 0
038e		slil d 3
038f		push	d
0390		push	c
0391		sliu c 0
0392		slil c 5
0393		sliu d #printhex	[01]
0394		slil d #printhex	[0f]
0395		jmpfar	d d
0396		pop	b
0397		pop	c
0398		pop	d
0399		pop	d
039a		pop	c
039b		jmpfar	d d	
	; monitordump ends
	
	
	
	; ------- GLOBAL FUNCTION monitoredit -------

039c	#monitoredit
039c		pop	c
039d		push	d		; get value byte

039e		sliu b 0
039f		slil b 7
03a0		load	a [b]
03a1		inc	b
03a2		load	b [b]	; calling global function hextobin

03a3		push	d
03a4		push	c
03a5		push	b
03a6		sliu d 0
03a7		slil d 3
03a8		push	d
03a9		push	c
03aa		sliu c 0
03ab		slil c 4
03ac		sliu d #hextobin	[08]
03ad		slil d #hextobin	[0f]
03ae		jmpfar	d d
03af		pop	b
03b0		pop	c
03b1		pop	d
03b2		push	a
03b3		sub	b b	; calling global function monitor_getaddress

03b4		push	d
03b5		push	c
03b6		push	b
03b7		sliu d 0
03b8		slil d 3
03b9		push	d
03ba		push	c
03bb		sliu c 0
03bc		slil c 4
03bd		sliu d #monitor_getaddress	[05]
03be		slil d #monitor_getaddress	[0c]
03bf		jmpfar	d d
03c0		pop	b
03c1		pop	c
03c2		pop	d
03c3		pop	b
03c4		store	b [a]
03c5		pop	d
03c6		pop	c
03c7		jmpfar	d d	
	; monitoredit ends
	
	

03c8		org 400	
	; ------- GLOBAL FUNCTION monitor_printaddress -------

0400	#monitor_printaddress
0400		pop	c
0401		push	d
0402		sliu b 0
0403		slil b 2
0404		load	a [b]	; calling global function printchar

0405		push	d
0406		push	c
0407		push	b
0408		sliu d 0
0409		slil d 4
040a		push	d
040b		push	c
040c		sliu c 0
040d		slil c 5
040e		sliu d #printchar	[01]
040f		slil d #printchar	[09]
0410		jmpfar	d d
0411		pop	b
0412		pop	c
0413		pop	d
0414		inc	b
0415		load	a [b]	; calling global function printchar

0416		push	d
0417		push	c
0418		push	b
0419		sliu d 0
041a		slil d 4
041b		push	d
041c		push	c
041d		sliu c 0
041e		slil c 5
041f		sliu d #printchar	[01]
0420		slil d #printchar	[09]
0421		jmpfar	d d
0422		pop	b
0423		pop	c
0424		pop	d
0425		inc	b
0426		load	a [b]	; calling global function printchar

0427		push	d
0428		push	c
0429		push	b
042a		sliu d 0
042b		slil d 4
042c		push	d
042d		push	c
042e		sliu c 0
042f		slil c 5
0430		sliu d #printchar	[01]
0431		slil d #printchar	[09]
0432		jmpfar	d d
0433		pop	b
0434		pop	c
0435		pop	d
0436		inc	b
0437		load	a [b]	; calling global function printchar

0438		push	d
0439		push	c
043a		push	b
043b		sliu d 0
043c		slil d 4
043d		push	d
043e		push	c
043f		sliu c 0
0440		slil c 5
0441		sliu d #printchar	[01]
0442		slil d #printchar	[09]
0443		jmpfar	d d
0444		pop	b
0445		pop	c
0446		pop	d
0447		inc	b
0448		sliu a 2
0449		slil a 0	; calling global function printchar

044a		push	d
044b		push	c
044c		push	b
044d		sliu d 0
044e		slil d 4
044f		push	d
0450		push	c
0451		sliu c 0
0452		slil c 5
0453		sliu d #printchar	[01]
0454		slil d #printchar	[09]
0455		jmpfar	d d
0456		pop	b
0457		pop	c
0458		pop	d
0459		pop	d
045a		pop	c
045b		jmpfar	d d	
	; monitor_printaddress ends
	
	
	
	; ------- GLOBAL FUNCTION monitor_getaddress -------

045c	#monitor_getaddress
045c		pop	c
045d		push	d		; sets the data page to the page entered, returns the address in A

045e		push	b
045f		sliu b 0
0460		slil b 2
0461		load	a [b]
0462		inc	b
0463		load	b [b]	; calling global function hextobin

0464		push	d
0465		push	c
0466		push	b
0467		sliu d 0
0468		slil d 4
0469		push	d
046a		push	c
046b		sliu c 0
046c		slil c 4
046d		sliu d #hextobin	[08]
046e		slil d #hextobin	[0f]
046f		jmpfar	d d
0470		pop	b
0471		pop	c
0472		pop	d
0473		pop	b
0474		push	a
0475		sliu d 0
0476		slil d 4
0477		add	b d
0478		load	a [b]
0479		inc	b
047a		load	b [b]	; calling global function hextobin

047b		push	d
047c		push	c
047d		push	b
047e		sliu d 0
047f		slil d 4
0480		push	d
0481		push	c
0482		sliu c 0
0483		slil c 4
0484		sliu d #hextobin	[08]
0485		slil d #hextobin	[0f]
0486		jmpfar	d d
0487		pop	b
0488		pop	c
0489		pop	d
048a		pop	b
048b		page	b
048c		pop	d
048d		pop	c
048e		jmpfar	d d	
	; monitor_getaddress ends
	
	
	
	; ------- GLOBAL FUNCTION hextobin -------

048f	#hextobin
048f		pop	c
0490		push	d		; A,B are two chars.  returns num in A

0491		push	a
0492		sliu d 3
0493		slil d 10
0494		sub	a d
0495		sliu d #@hextobin0	[09]
0496		slil d #@hextobin0	[0d]
0497		skipge	a
0498		jalr	d d
0499		pop	a
049a		sliu d #hextobin_letter1	[0a]
049b		slil d #hextobin_letter1	[01]
049c		jalr	d d
049d	#@hextobin0
049d		pop	a
049e		sliu d #hextobin_number1	[0a]
049f		slil d #hextobin_number1	[0a]
04a0		jalr	d d
04a1	#hextobin_letter1
04a1		sliu d 4
04a2		slil d 1
04a3		sub	a d
04a4		sliu d 0
04a5		slil d 10
04a6		add	a d
04a7		sliu d #hextobin2	[0a]
04a8		slil d #hextobin2	[0d]
04a9		jalr	d d
04aa	#hextobin_number1
04aa		sliu d 3
04ab		slil d 0
04ac		sub	a d
04ad	#hextobin2
04ad		add	a a
04ae		add	a a
04af		add	a a
04b0		add	a a
04b1		push	b
04b2		sliu d 3
04b3		slil d 10
04b4		sub	b d
04b5		sliu d #@hextobin1	[0b]
04b6		slil d #@hextobin1	[0d]
04b7		skipge	b
04b8		jalr	d d
04b9		pop	b
04ba		sliu d #hextobin_letter2	[0c]
04bb		slil d #hextobin_letter2	[01]
04bc		jalr	d d
04bd	#@hextobin1
04bd		pop	b
04be		sliu d #hextobin_number2	[0c]
04bf		slil d #hextobin_number2	[0a]
04c0		jalr	d d
04c1	#hextobin_letter2
04c1		sliu d 4
04c2		slil d 1
04c3		sub	b d
04c4		sliu d 0
04c5		slil d 10
04c6		add	b d
04c7		sliu d #hextobin3	[0c]
04c8		slil d #hextobin3	[0d]
04c9		jalr	d d
04ca	#hextobin_number2
04ca		sliu d 3
04cb		slil d 0
04cc		sub	b d
04cd	#hextobin3
04cd		add	a b
04ce		pop	d
04cf		pop	c
04d0		jmpfar	d d	
	; hextobin ends
	
	

04d1		org 500	
	; ------- GLOBAL FUNCTION printstring -------

0500	#printstring
0500		pop	c
0501		push	d		; page in A, string addr in B

0502		page	a
0503	#printstring_loop
0503		load	a [b]
0504		push	a
0505		sliu d 0
0506		slil d 0
0507		sub	a d
0508		sliu d #@printstring0	[01]
0509		slil d #@printstring0	[00]
050a		skipz	a
050b		jalr	d d
050c		pop	a
050d		sliu d #printstring_done	[01]
050e		slil d #printstring_done	[06]
050f		jalr	d d
0510	#@printstring0
0510		pop	a	
	;	.call printchar

0511		out	a	

0512		inc	b
0513		sliu d #printstring_loop	[00]
0514		slil d #printstring_loop	[03]
0515		jalr	d d
0516	#printstring_done
0516		pop	d
0517		pop	c
0518		jmpfar	d d	
	; printstring ends
	
	
	
	; ------- GLOBAL FUNCTION printchar -------

0519	#printchar
0519		pop	c
051a		push	d	;	 prints char in A

051b		out	a	
	;	push	a
	;	push	a
	;	li	d,0xf0
	;	nand	a,d
	;	nand	a,a
	;	li	b,0x10
	;	.call div_even
	;	li	c,0x7f
	;	nand	a,c
	;	nand	a,c
	;	out	a
	;	pop	a
	;	li	d,0x0f
	;	nand	a,d
	;	nand	a,a
	;	li	d,0x7f
	;	nand	a,d
	;	nand	a,d
	;	out	a
	;	pop	a

051c		pop	d
051d		pop	c
051e		jmpfar	d d	
	; printchar ends
	
	
	
	; ------- GLOBAL FUNCTION printhex -------

051f	#printhex
051f		pop	c
0520		push	d		; prints a byte in A as two hex chars

0521		push	a
0522		push	a
0523		sliu d 15
0524		slil d 0
0525		nand	a d
0526		nand	a a
0527		sliu b 1
0528		slil b 0	; calling global function div_even

0529		push	d
052a		push	c
052b		push	b
052c		sliu d 0
052d		slil d 5
052e		push	d
052f		push	c
0530		sliu c 0
0531		slil c 7
0532		sliu d #div_even	[06]
0533		slil d #div_even	[0a]
0534		jmpfar	d d
0535		pop	b
0536		pop	c
0537		pop	d
0538		push	a
0539		sliu d 0
053a		slil d 10
053b		sub	a d
053c		sliu d #@printhex0	[04]
053d		slil d #@printhex0	[04]
053e		skipl	a
053f		jalr	d d
0540		pop	a
0541		sliu d #printhex_num1	[04]
0542		slil d #printhex_num1	[0e]
0543		jalr	d d
0544	#@printhex0
0544		pop	a
0545		sliu d 0
0546		slil d 10
0547		sub	a d
0548		sliu d 4
0549		slil d 1
054a		add	a d
054b		sliu d #printhex2	[05]
054c		slil d #printhex2	[01]
054d		jalr	d d
054e	#printhex_num1
054e		sliu d 3
054f		slil d 0
0550		add	a d
0551	#printhex2	; calling global function printchar

0551		push	d
0552		push	c
0553		push	b
0554		sliu d 0
0555		slil d 5
0556		push	d
0557		push	c
0558		sliu c 0
0559		slil c 5
055a		sliu d #printchar	[01]
055b		slil d #printchar	[09]
055c		jmpfar	d d
055d		pop	b
055e		pop	c
055f		pop	d
0560		pop	a
0561		sliu b 0
0562		slil b 15
0563		nand	a b
0564		nand	a a
0565		push	a
0566		sliu d 0
0567		slil d 10
0568		sub	a d
0569		sliu d #@printhex1	[07]
056a		slil d #@printhex1	[01]
056b		skipl	a
056c		jalr	d d
056d		pop	a
056e		sliu d #printhex_num2	[07]
056f		slil d #printhex_num2	[0b]
0570		jalr	d d
0571	#@printhex1
0571		pop	a
0572		sliu d 0
0573		slil d 10
0574		sub	a d
0575		sliu d 4
0576		slil d 1
0577		add	a d
0578		sliu d #printhex3	[07]
0579		slil d #printhex3	[0e]
057a		jalr	d d
057b	#printhex_num2
057b		sliu d 3
057c		slil d 0
057d		add	a d
057e	#printhex3	; calling global function printchar

057e		push	d
057f		push	c
0580		push	b
0581		sliu d 0
0582		slil d 5
0583		push	d
0584		push	c
0585		sliu c 0
0586		slil c 5
0587		sliu d #printchar	[01]
0588		slil d #printchar	[09]
0589		jmpfar	d d
058a		pop	b
058b		pop	c
058c		pop	d
058d		pop	a
058e		pop	d
058f		pop	c
0590		jmpfar	d d	
	; printhex ends
	
	

0591		org	600	
	; ------- GLOBAL FUNCTION readchar -------

0600	#readchar
0600		pop	c
0601		push	d		; reads a char in A

0602	#inloop
0602		in	a
0603		push	a
0604		sliu d 0
0605		slil d 0
0606		sub	a d
0607		sliu d #@readchar0	[00]
0608		slil d #@readchar0	[0f]
0609		skipz	a
060a		jalr	d d
060b		pop	a
060c		sliu d #inloop	[00]
060d		slil d #inloop	[02]
060e		jalr	d d
060f	#@readchar0
060f		pop	a
0610		pop	d
0611		pop	c
0612		jmpfar	d d	
	; readchar ends
	
	
	
	; ------- GLOBAL FUNCTION readstring -------

0613	#readstring
0613		pop	c
0614		push	d		;A = buffer page, B = buffer addr
		; reads a string until RETURN, puts in buffer and null terminates
	

0615		page	a
0616	#readstring_readloop	; calling global function readchar

0616		push	d
0617		push	c
0618		push	b
0619		sliu d 0
061a		slil d 6
061b		push	d
061c		push	c
061d		sliu c 0
061e		slil c 6
061f		sliu d #readchar	[00]
0620		slil d #readchar	[00]
0621		jmpfar	d d
0622		pop	b
0623		pop	c
0624		pop	d
0625		push	a
0626		sliu d 0
0627		slil d 13
0628		sub	a d
0629		sliu d #@readstring0	[03]
062a		slil d #@readstring0	[01]
062b		skipz	a
062c		jalr	d d
062d		pop	a
062e		sliu d #readstring_return	[06]
062f		slil d #readstring_return	[0d]
0630		jalr	d d
0631	#@readstring0
0631		pop	a
0632		push	a
0633		sliu d 0
0634		slil d 8
0635		sub	a d
0636		sliu d #@readstring1	[03]
0637		slil d #@readstring1	[0e]
0638		skipz	a
0639		jalr	d d
063a		pop	a
063b		sliu d #readstring_backspace	[05]
063c		slil d #readstring_backspace	[03]
063d		jalr	d d
063e	#@readstring1
063e		pop	a	; calling global function printchar

063f		push	d
0640		push	c
0641		push	b
0642		sliu d 0
0643		slil d 6
0644		push	d
0645		push	c
0646		sliu c 0
0647		slil c 5
0648		sliu d #printchar	[01]
0649		slil d #printchar	[09]
064a		jmpfar	d d
064b		pop	b
064c		pop	c
064d		pop	d
064e		store	a [b]
064f		inc	b
0650		sliu d #readstring_readloop	[01]
0651		slil d #readstring_readloop	[06]
0652		jalr	d d	

0653	#readstring_backspace		; ignore if beginning of line
		;;; TODO bug what if buffer doesn't start at 0?

0653		push	b
0654		sliu d 0
0655		slil d 0
0656		sub	b d
0657		sliu d #@readstring2	[05]
0658		slil d #@readstring2	[0f]
0659		skipz	b
065a		jalr	d d
065b		pop	b
065c		sliu d #readstring_readloop	[01]
065d		slil d #readstring_readloop	[06]
065e		jalr	d d
065f	#@readstring2
065f		pop	b
0660		dec	b	;	li	d,0x00
	;	out	d
	;	li	d,0x04
	;	out	d
	;	li	d,0x82
	;	out	d
	;	li	d,0x80
	;	out	d
	;	li	d,0x00
	;	out	d
	;	li	d,0x00
	;	out	d

0661		sliu d 0
0662		slil d 8
0663		out	d
0664		sliu d 2
0665		slil d 0
0666		out	d
0667		sliu d 0
0668		slil d 8
0669		out	d
066a		sliu d #readstring_readloop	[01]
066b		slil d #readstring_readloop	[06]
066c		jalr	d d	

066d	#readstring_return
066d		sliu d 0
066e		slil d 13
066f		out	d
0670		sliu d 2
0671		slil d 0
0672		out	d	;	; home
	;	li	d,0x00
	;	out	d
	;	li	d,0x03
	;	out	d
	
		;null terminate

0673		sliu a 0
0674		slil a 0
0675		store	a [b]
0676		pop	d
0677		pop	c
0678		jmpfar	d d	
	; readstring ends
	
	

0679		org	700	
	; ------- GLOBAL FUNCTION div -------

0700	#div
0700		pop	c
0701		push	d		; A = A / B

0702		sliu c 0
0703		slil c 0
0704		push	b
0705		sliu d 0
0706		slil d 0
0707		sub	b d
0708		sliu d #@div0	[01]
0709		slil d #@div0	[00]
070a		skipz	b
070b		jalr	d d
070c		pop	b
070d		sliu d #div_done	[06]
070e		slil d #div_done	[05]
070f		jalr	d d
0710	#@div0
0710		pop	b	
		; check special cases: b is negative (b>128)

0711		push	b
0712		sliu d 0
0713		slil d 0
0714		sub	b d
0715		sliu d #@div1	[01]
0716		slil d #@div1	[0d]
0717		skipl	b
0718		jalr	d d
0719		pop	b
071a		sliu d #div_neg_b	[04]
071b		slil d #div_neg_b	[00]
071c		jalr	d d
071d	#@div1
071d		pop	b		;if a is negative initially (a>127) then subtract b until a becomes positive

071e	#div_negadjust
071e		push	a
071f		sliu d 0
0720		slil d 0
0721		sub	a d
0722		sliu d #@div2	[02]
0723		slil d #@div2	[0a]
0724		skipge	a
0725		jalr	d d
0726		pop	a
0727		sliu d #divwhile	[03]
0728		slil d #divwhile	[00]
0729		jalr	d d
072a	#@div2
072a		pop	a
072b		sub	a b
072c		inc	c
072d		sliu d #div_negadjust	[01]
072e		slil d #div_negadjust	[0e]
072f		jalr	d d
0730	#divwhile
0730		push	a
0731		sub	a b
0732		sliu d #@div3	[03]
0733		slil d #@div3	[0a]
0734		skipl	a
0735		jalr	d d
0736		pop	a
0737		sliu d #div_done	[06]
0738		slil d #div_done	[05]
0739		jalr	d d
073a	#@div3
073a		pop	a
073b		sub	a b
073c		inc	c
073d		sliu d #divwhile	[03]
073e		slil d #divwhile	[00]
073f		jalr	d d
0740	#div_neg_b		; b is very large.  if a is positive, then a/b==0

0740		push	a
0741		sliu d 0
0742		slil d 0
0743		sub	a d
0744		sliu d #@div4	[04]
0745		slil d #@div4	[0c]
0746		skipge	a
0747		jalr	d d
0748		pop	a
0749		sliu d #div_done	[06]
074a		slil d #div_done	[05]
074b		jalr	d d
074c	#@div4
074c		pop	a
074d		push	a
074e		sub	a b
074f		sliu d #@div5	[05]
0750		slil d #@div5	[07]
0751		skipl	a
0752		jalr	d d
0753		pop	a
0754		sliu d #div_done	[06]
0755		slil d #div_done	[05]
0756		jalr	d d
0757	#@div5
0757		pop	a
0758		push	a
0759		sub	a b
075a		sliu d #@div6	[06]
075b		slil d #@div6	[02]
075c		skipnz	a
075d		jalr	d d
075e		pop	a
075f		sliu d #div_negadjust	[01]
0760		slil d #div_negadjust	[0e]
0761		jalr	d d
0762	#@div6
0762		pop	a		; a==b

0763		sliu c 0
0764		slil c 1
0765	#div_done
0765		sub	a a
0766		add	a c
0767		pop	d
0768		pop	c
0769		jmpfar	d d	
	; div ends
	
	
	
	; ------- GLOBAL FUNCTION div_even -------

076a	#div_even
076a		pop	c
076b		push	d		; A = A / B
		; only works if A%B is 0

076c		sliu c 0
076d		slil c 0
076e	#divewhile
076e		push	a
076f		sliu d 0
0770		slil d 0
0771		sub	a d
0772		sliu d #@div_even0	[07]
0773		slil d #@div_even0	[0a]
0774		skipz	a
0775		jalr	d d
0776		pop	a
0777		sliu d #divewhileend	[08]
0778		slil d #divewhileend	[00]
0779		jalr	d d
077a	#@div_even0
077a		pop	a
077b		sub	a b
077c		inc	c
077d		sliu d #divewhile	[06]
077e		slil d #divewhile	[0e]
077f		jalr	d d
0780	#divewhileend
0780		sub	a a
0781		add	a c
0782		pop	d
0783		pop	c
0784		jmpfar	d d	
	; div_even ends
	
	
	
	; ------- GLOBAL FUNCTION mod -------

0785	#mod
0785		pop	c
0786		push	d		; A = A % B

0787		push	b
0788		sliu d 0
0789		slil d 0
078a		sub	b d
078b		sliu d #@mod0	[09]
078c		slil d #@mod0	[03]
078d		skipz	b
078e		jalr	d d
078f		pop	b
0790		sliu d #mod0	[0c]
0791		slil d #mod0	[01]
0792		jalr	d d
0793	#@mod0
0793		pop	b		; special case: b>127

0794		push	b
0795		sliu d 0
0796		slil d 0
0797		sub	b d
0798		sliu d #@mod1	[0a]
0799		slil d #@mod1	[00]
079a		skipl	b
079b		jalr	d d
079c		pop	b
079d		sliu d #mod_neg_b	[0c]
079e		slil d #mod_neg_b	[06]
079f		jalr	d d
07a0	#@mod1
07a0		pop	b
07a1	#mod_negadjust
07a1		push	a
07a2		sliu d 0
07a3		slil d 0
07a4		sub	a d
07a5		sliu d #@mod2	[0a]
07a6		slil d #@mod2	[0d]
07a7		skipge	a
07a8		jalr	d d
07a9		pop	a
07aa		sliu d #modwhile	[0b]
07ab		slil d #modwhile	[02]
07ac		jalr	d d
07ad	#@mod2
07ad		pop	a
07ae		sub	a b
07af		sliu d #mod_negadjust	[0a]
07b0		slil d #mod_negadjust	[01]
07b1		jalr	d d
07b2	#modwhile
07b2		push	a
07b3		sub	a b
07b4		sliu d #@mod3	[0b]
07b5		slil d #@mod3	[0c]
07b6		skipl	a
07b7		jalr	d d
07b8		pop	a
07b9		sliu d #modwhileend	[0e]
07ba		slil d #modwhileend	[0b]
07bb		jalr	d d
07bc	#@mod3
07bc		pop	a
07bd		sub	a b
07be		sliu d #modwhile	[0b]
07bf		slil d #modwhile	[02]
07c0		jalr	d d
07c1	#mod0
07c1		sliu a 0
07c2		slil a 0
07c3		sliu d #modwhileend	[0e]
07c4		slil d #modwhileend	[0b]
07c5		jalr	d d
07c6	#mod_neg_b		; b is > 127
		; if a is positive, then just return a

07c6		push	a
07c7		sliu d 0
07c8		slil d 0
07c9		sub	a d
07ca		sliu d #@mod4	[0d]
07cb		slil d #@mod4	[02]
07cc		skipge	a
07cd		jalr	d d
07ce		pop	a
07cf		sliu d #modwhileend	[0e]
07d0		slil d #modwhileend	[0b]
07d1		jalr	d d
07d2	#@mod4
07d2		pop	a		; if a < b then return a

07d3		push	a
07d4		sub	a b
07d5		sliu d #@mod5	[0d]
07d6		slil d #@mod5	[0d]
07d7		skipl	a
07d8		jalr	d d
07d9		pop	a
07da		sliu d #modwhileend	[0e]
07db		slil d #modwhileend	[0b]
07dc		jalr	d d
07dd	#@mod5
07dd		pop	a
07de		push	a
07df		sub	a b
07e0		sliu d #@mod6	[0e]
07e1		slil d #@mod6	[08]
07e2		skipnz	a
07e3		jalr	d d
07e4		pop	a
07e5		sliu d #mod_negadjust	[0a]
07e6		slil d #mod_negadjust	[01]
07e7		jalr	d d
07e8	#@mod6
07e8		pop	a		; a == b, so return 0

07e9		sliu a 0
07ea		slil a 0
07eb	#modwhileend
07eb		pop	d
07ec		pop	c
07ed		jmpfar	d d	
	; mod ends
	
	

07ee		org 800	
	; ------- GLOBAL FUNCTION mul -------

0800	#mul
0800		pop	c
0801		push	d		; A = A * B

0802		sub	c c
0803	#mulloop
0803		push	b
0804		sliu d 0
0805		slil d 0
0806		sub	b d
0807		sliu d #@mul0	[00]
0808		slil d #@mul0	[0f]
0809		skipz	b
080a		jalr	d d
080b		pop	b
080c		sliu d #mulend	[01]
080d		slil d #mulend	[05]
080e		jalr	d d
080f	#@mul0
080f		pop	b
0810		add	c a
0811		dec	b
0812		sliu d #mulloop	[00]
0813		slil d #mulloop	[03]
0814		jalr	d d
0815	#mulend
0815		sub	a a
0816		add	a c
0817		pop	d
0818		pop	c
0819		jmpfar	d d	
	; mul ends
	
	
	
	; ------- GLOBAL FUNCTION clearscreen -------

081a	#clearscreen
081a		pop	c
081b		push	d		; resets screen and homes cursor

081c		sliu d 8
081d		slil d 0
081e		out	d	;	; home
	;	li	d,0x00
	;	out	d
	;	li	d,0x03
	;	out	d
	;	; clear
	;	li	d,0x00
	;	out	d
	;	li	d,0x01
	;	out	d
	

081f		pop	d
0820		pop	c
0821		jmpfar	d d	
	; clearscreen ends
	
	
	
	; ------- GLOBAL FUNCTION readprompt -------

0822	#readprompt
0822		pop	c
0823		push	d		;move to new line and display > prompt

0824		sliu d 0
0825		slil d 13
0826		out	d
0827		sliu d 2
0828		slil d 0
0829		out	d
082a		sliu d 3
082b		slil d 14
082c		out	d	
	;	;clears second line, puts cursor at beginning, prints prompt
	;	
	;	; put cursor on second line
	;	li	d,0x0c
	;	out	d
	;	li	d,0x00
	;	out	d
	;
	;	;print 16 spaces
	;	li	c,16
	;#readprompt_clr
	;	li	d,0x82
	;	out	d
	;	li	d,0x80
	;	out	d
	;	dec	c
	;	.if c != 0 then readprompt_clr
	;
	;	; put cursor on second line again
	;	li	d,0x0c
	;	out	d
	;	li	d,0x00
	;	out	d
	;
	;	; print a > prompt
	;	li	d,0x83
	;	out	d
	;	li	d,0x8e
	;	out	d

082d		pop	d
082e		pop	c
082f		jmpfar	d d	
	; readprompt ends
	
	

0830		org f00	
	; ------- GLOBAL FUNCTION identify_keychar -------

0f00	#identify_keychar
0f00		pop	c
0f01		push	d		; A is page, B is testchar
		; returns 0 if no match, otherwise keychar in A
	
		; push data page

0f02		push	a
0f03		sliu a 7
0f04		slil a 14
0f05		page	a		
		; c holds keychar addr

0f06		sliu c #keychars	[00]
0f07		slil c #keychars	[00]	

0f08	#identify_keychar_loop		;compare
		;get char from keyword list

0f08		load	a [c]	

0f09		push	a
0f0a		sub	a b
0f0b		sliu d #@identify_keychar0	[01]
0f0c		slil d #@identify_keychar0	[03]
0f0d		skipz	a
0f0e		jalr	d d
0f0f		pop	a
0f10		sliu d #identify_keychar_match	[02]
0f11		slil d #identify_keychar_match	[00]
0f12		jalr	d d
0f13	#@identify_keychar0
0f13		pop	a	

0f14	#identify_keychar_doesntmatch	
		;not a match.  move to next keychar
	
		; advance c four forwards

0f14		inc	c
0f15		inc	c
0f16		inc	c
0f17		inc	c		; if it is zero, no keychars match

0f18		load	a [c]
0f19		sliu d #identify_keychar_nomatches	[02]
0f1a		slil d #identify_keychar_nomatches	[06]
0f1b		skipnz	a
0f1c		jalr	d d
0f1d		sliu d #identify_keychar_loop	[00]
0f1e		slil d #identify_keychar_loop	[08]
0f1f		jalr	d d	

0f20	#identify_keychar_match		; the next char is the token

0f20		inc	c
0f21		inc	c
0f22		load	a [c]
0f23		sliu d #identify_keychar_done	[02]
0f24		slil d #identify_keychar_done	[07]
0f25		jalr	d d	

0f26	#identify_keychar_nomatches	

0f26		sub	a a	

0f27	#identify_keychar_done
0f27		pop	d
0f28		page	d
0f29		pop	d
0f2a		pop	c
0f2b		jmpfar	d d	
	; identify_keychar ends
	
	
	; tokens:
	; known keywords are reduced to a single character
	; integers consist of one or more digits
	; strings are surrounded by ""
	; vars are # then one or more capital letters
	

0f2c		org 1000	
	; ------- GLOBAL FUNCTION tokenize -------

1000	#tokenize
1000		pop	c
1001		push	d		; generates a new command string with tokens replacing keywords
		; A=buffer page, B=buffer addr, C=dest buffer addr
		; returns 0 if no error, 1 if syntax error
	

1002		page	a		;push the page

1003		push	a	
		;save dest addr on stack

1004		push	c	

1005	#tokenize_loop		;get next char

1005		load	a [b]	
		;if it's 0, end of line

1006		sliu d #tokenize_done	[0e]
1007		slil d #tokenize_done	[09]
1008		skipnz	a
1009		jalr	d d	
		; is it a space? just move forward

100a		load	a [b]
100b		sliu d 2
100c		slil d 0
100d		sub	a d
100e		sliu d #tokenize_notspace	[01]
100f		slil d #tokenize_notspace	[06]
1010		skipz	a
1011		jalr	d d
1012		inc	b
1013		sliu d #tokenize_loop	[00]
1014		slil d #tokenize_loop	[05]
1015		jalr	d d	

1016	#tokenize_notspace		; is it a string? then copy and advance to next "

1016		load	a [b]
1017		sliu d 2
1018		slil d 2
1019		sub	a d
101a		sliu d #tokenize_notstring	[03]
101b		slil d #tokenize_notstring	[08]
101c		skipz	a
101d		jalr	d d
101e		pop	c	

101f	#tokenize_stringcopyloop
101f		load	a [b]
1020		store	a [c]
1021		inc	b
1022		inc	c
1023		load	a [b]
1024		sliu d 2
1025		slil d 2
1026		sub	a d
1027		sliu d #tokenize_stringcopyloop	[01]
1028		slil d #tokenize_stringcopyloop	[0f]
1029		skipz	a
102a		jalr	d d	
		;put a space after the string

102b		inc	b
102c		sliu d 2
102d		slil d 2
102e		store	d [c]
102f		inc	c
1030		sliu d 2
1031		slil d 0
1032		store	d [c]
1033		inc	c
1034		push	c
1035		sliu d #tokenize_loop	[00]
1036		slil d #tokenize_loop	[05]
1037		jalr	d d	

1038	#tokenize_notstring		;is it a number? match 0-9

1038		load	a [b]
1039		sliu d 3
103a		slil d 0
103b		sub	a d
103c		sliu d #tokenize_notnumber	[06]
103d		slil d #tokenize_notnumber	[03]
103e		skipge	a
103f		jalr	d d
1040		sliu d 0
1041		slil d 10
1042		sub	a d
1043		sliu d #tokenize_notnumber	[06]
1044		slil d #tokenize_notnumber	[03]
1045		skipl	a
1046		jalr	d d	
		; copy the number over

1047		pop	c
1048	#tokenize_numbercopyloop
1048		load	a [b]
1049		store	a [c]
104a		inc	b
104b		inc	c
104c		load	a [b]
104d		sliu d 3
104e		slil d 0
104f		sub	a d
1050		sliu d #tokenize_numbercopyloopdone	[05]
1051		slil d #tokenize_numbercopyloopdone	[0b]
1052		skipge	a
1053		jalr	d d
1054		sliu d 0
1055		slil d 10
1056		sub	a d
1057		sliu d #tokenize_numbercopyloop	[04]
1058		slil d #tokenize_numbercopyloop	[08]
1059		skipge	a
105a		jalr	d d	

105b	#tokenize_numbercopyloopdone		; save a space

105b		sliu d 2
105c		slil d 0
105d		store	d [c]
105e		inc	c
105f		push	c
1060		sliu d #tokenize_loop	[00]
1061		slil d #tokenize_loop	[05]
1062		jalr	d d	

1063	#tokenize_notnumber	
		; check if it's a keychar

1063		pop	c
1064		pop	a
1065		push	a
1066		push	c
1067		push	b
1068		load	b [b]	; calling global function identify_keychar

1069		push	d
106a		push	c
106b		push	b
106c		sliu d 1
106d		slil d 0
106e		push	d
106f		push	c
1070		sliu c 0
1071		slil c 15
1072		sliu d #identify_keychar	[00]
1073		slil d #identify_keychar	[00]
1074		jmpfar	d d
1075		pop	b
1076		pop	c
1077		pop	d
1078		pop	b
1079		sliu d #tokenize_notkeychar	[08]
107a		slil d #tokenize_notkeychar	[09]
107b		skipnz	a
107c		jalr	d d	
		;save keychar to output string

107d		pop	c
107e		store	a [c]
107f		inc	c		;include space

1080		sliu d 2
1081		slil d 0
1082		store	d [c]
1083		inc	c
1084		push	c	
		;advance one char

1085		inc	b
1086		sliu d #tokenize_loop	[00]
1087		slil d #tokenize_loop	[05]
1088		jalr	d d	

1089	#tokenize_notkeychar		; check if it's a keyword
	

1089		pop	c
108a		pop	a
108b		push	a
108c		push	c	
	; calling global function identify_keyword

108d		push	d
108e		push	c
108f		push	b
1090		sliu d 1
1091		slil d 0
1092		push	d
1093		push	c
1094		sliu c 1
1095		slil c 1
1096		sliu d #identify_keyword	[00]
1097		slil d #identify_keyword	[00]
1098		jmpfar	d d
1099		pop	b
109a		pop	c
109b		pop	d
109c		sliu d #tokenize_notkey	[0b]
109d		slil d #tokenize_notkey	[08]
109e		skipnz	a
109f		jalr	d d	
		;save keyword token to output string

10a0		pop	c
10a1		store	a [c]
10a2		inc	c		;include space separator

10a3		sliu d 2
10a4		slil d 0
10a5		store	d [c]
10a6		inc	c
10a7		push	c	
		;advance b to next space or EOL

10a8	#tokenize_advance
10a8		inc	b
10a9		load	a [b]	
		; if a == 0 then done

10aa		sliu d #tokenize_done	[0e]
10ab		slil d #tokenize_done	[09]
10ac		skipnz	a
10ad		jalr	d d		; if a == ' ' then stop

10ae		sliu d 2
10af		slil d 0
10b0		sub	a d
10b1		sliu d #tokenize_advance	[0a]
10b2		slil d #tokenize_advance	[08]
10b3		skipz	a
10b4		jalr	d d	

10b5		sliu d #tokenize_loop	[00]
10b6		slil d #tokenize_loop	[05]
10b7		jalr	d d	

10b8	#tokenize_notkey		;is it a var? match A-Z

10b8		load	a [b]
10b9		sliu d 4
10ba		slil d 1
10bb		sub	a d
10bc		sliu d #tokenize_notvar	[0e]
10bd		slil d #tokenize_notvar	[04]
10be		skipge	a
10bf		jalr	d d
10c0		sliu d 1
10c1		slil d 10
10c2		sub	a d
10c3		sliu d #tokenize_notvar	[0e]
10c4		slil d #tokenize_notvar	[04]
10c5		skipl	a
10c6		jalr	d d	

10c7		pop	c	
		;plant a # at beginning

10c8		sliu d 2
10c9		slil d 3
10ca		store	d [c]
10cb		inc	c	
		; copy the letters over

10cc	#tokenize_varcopyloop
10cc		load	a [b]
10cd		store	a [c]
10ce		inc	b
10cf		inc	c
10d0		load	a [b]
10d1		sliu d #tokenize_varcopyloopdone	[0d]
10d2		slil d #tokenize_varcopyloopdone	[0c]
10d3		skipnz	a
10d4		jalr	d d
10d5		sliu d 2
10d6		slil d 0
10d7		sub	a d
10d8		sliu d #tokenize_varcopyloop	[0c]
10d9		slil d #tokenize_varcopyloop	[0c]
10da		skipz	a
10db		jalr	d d	

10dc	#tokenize_varcopyloopdone		; save a space

10dc		sliu d 2
10dd		slil d 0
10de		store	d [c]
10df		inc	c
10e0		push	c
10e1		sliu d #tokenize_loop	[00]
10e2		slil d #tokenize_loop	[05]
10e3		jalr	d d	

10e4	#tokenize_notvar		;syntax error

10e4		sliu a 0
10e5		slil a 1
10e6		sliu d #tokenize_done_return	[0e]
10e7		slil d #tokenize_done_return	[0f]
10e8		jalr	d d	

10e9	#tokenize_done
10e9		pop	c
10ea		push	c
10eb		# null terminate output string
10eb		sliu d 0
10ec		slil d 0
10ed		store	d [c]
10ee		sub	a a
10ef	#tokenize_done_return
10ef		pop	c
10f0		pop	d
10f1		pop	d
10f2		pop	c
10f3		jmpfar	d d	
	; tokenize ends
	
	

10f4		org 1100	
	
	; ------- GLOBAL FUNCTION identify_keyword -------

1100	#identify_keyword
1100		pop	c
1101		push	d		; A is page, B is address
		; returns 0 if no match, otherwise keyword char in A
	
		; push test address and data page

1102		push	b
1103		push	a		
		; c holds keyword addr

1104		sliu c #keywords	[02]
1105		slil c #keywords	[0d]	

1106	#identify_keyword_loop		;compare
		;get char from keyword list

1106		sliu a 7
1107		slil a 14
1108		page	a
1109		load	a [c]	
		;is the keyword 0? then test better be 0 or ' '

110a		push	a
110b		sliu d 0
110c		slil d 0
110d		sub	a d
110e		sliu d #@identify_keyword0	[01]
110f		slil d #@identify_keyword0	[06]
1110		skipnz	a
1111		jalr	d d
1112		pop	a
1113		sliu d #identify_keyword_notendofkeyword	[05]
1114		slil d #identify_keyword_notendofkeyword	[00]
1115		jalr	d d
1116	#@identify_keyword0
1116		pop	a		
		;get char from test

1117		pop	a
1118		page	a
1119		push	a
111a		load	a [b]	
		;if it's 0 or ' ', then match

111b		push	a
111c		sliu d 0
111d		slil d 0
111e		sub	a d
111f		sliu d #@identify_keyword1	[02]
1120		slil d #@identify_keyword1	[07]
1121		skipz	a
1122		jalr	d d
1123		pop	a
1124		sliu d #identify_keyword_match	[07]
1125		slil d #identify_keyword_match	[0c]
1126		jalr	d d
1127	#@identify_keyword1
1127		pop	a
1128		push	a
1129		sliu d 2
112a		slil d 0
112b		sub	a d
112c		sliu d #@identify_keyword2	[03]
112d		slil d #@identify_keyword2	[04]
112e		skipz	a
112f		jalr	d d
1130		pop	a
1131		sliu d #identify_keyword_match	[07]
1132		slil d #identify_keyword_match	[0c]
1133		jalr	d d
1134	#@identify_keyword2
1134		pop	a	

1135	#identify_keyword_doesntmatch	
		;not a match.  reset b and move to next keyword

1135		pop	a
1136		pop	b
1137		push	b
1138		push	a
1139		sliu a 7
113a		slil a 14
113b		page	a		;advance c to 0 if it's not there yet

113c	#identify_keyword_doesntmatch2
113c		load	a [c]
113d		sliu d #identify_keyword_doesntmatch1	[04]
113e		slil d #identify_keyword_doesntmatch1	[05]
113f		skipnz	a
1140		jalr	d d
1141		inc	c
1142		sliu d #identify_keyword_doesntmatch2	[03]
1143		slil d #identify_keyword_doesntmatch2	[0c]
1144		jalr	d d
1145	#identify_keyword_doesntmatch1	
		; advance c three forwards

1145		inc	c
1146		inc	c
1147		inc	c		; if it is zero, no keywords match

1148		load	a [c]
1149		sliu d #identify_keyword_nomatches	[08]
114a		slil d #identify_keyword_nomatches	[04]
114b		skipnz	a
114c		jalr	d d
114d		sliu d #identify_keyword_loop	[00]
114e		slil d #identify_keyword_loop	[06]
114f		jalr	d d	

1150	#identify_keyword_notendofkeyword		; are we at end of test word? if so, no match

1150		pop	a
1151		page	a
1152		push	a
1153		load	a [b]
1154		push	a
1155		sliu d 0
1156		slil d 0
1157		sub	a d
1158		sliu d #@identify_keyword3	[06]
1159		slil d #@identify_keyword3	[00]
115a		skipz	a
115b		jalr	d d
115c		pop	a
115d		sliu d #identify_keyword_doesntmatch	[03]
115e		slil d #identify_keyword_doesntmatch	[05]
115f		jalr	d d
1160	#@identify_keyword3
1160		pop	a
1161		push	a
1162		sliu d 2
1163		slil d 0
1164		sub	a d
1165		sliu d #@identify_keyword4	[06]
1166		slil d #@identify_keyword4	[0d]
1167		skipz	a
1168		jalr	d d
1169		pop	a
116a		sliu d #identify_keyword_doesntmatch	[03]
116b		slil d #identify_keyword_doesntmatch	[05]
116c		jalr	d d
116d	#@identify_keyword4
116d		pop	a	
		;test if the letters are the same

116e		sliu d 7
116f		slil d 14
1170		page	d
1171		load	d [c]	

1172		sub	a d
1173		sliu d #identify_keyword_doesntmatch	[03]
1174		slil d #identify_keyword_doesntmatch	[05]
1175		skipz	a
1176		jalr	d d	
		;not done with matching.  go to next character

1177		inc	b
1178		inc	c
1179		sliu d #identify_keyword_loop	[00]
117a		slil d #identify_keyword_loop	[06]
117b		jalr	d d	

117c	#identify_keyword_match		; the next char is the token

117c		sliu d 7
117d		slil d 14
117e		page	d
117f		inc	c
1180		load	a [c]
1181		sliu d #identify_keyword_done	[08]
1182		slil d #identify_keyword_done	[05]
1183		jalr	d d	

1184	#identify_keyword_nomatches	

1184		sub	a a	

1185	#identify_keyword_done
1185		pop	d
1186		page	d
1187		pop	d
1188		pop	d
1189		pop	c
118a		jmpfar	d d	
	; identify_keyword ends
	
	

118b		org 1200	
	; ------- GLOBAL FUNCTION basic -------

1200	#basic
1200		pop	c
1201		push	d		; print "tiny basic"

1202		sliu a 7
1203		slil a 15
1204		sliu b #basic_message	[00]
1205		slil b #basic_message	[0e]	; calling global function printstring

1206		push	d
1207		push	c
1208		push	b
1209		sliu d 1
120a		slil d 2
120b		push	d
120c		push	c
120d		sliu c 0
120e		slil c 5
120f		sliu d #printstring	[00]
1210		slil d #printstring	[00]
1211		jmpfar	d d
1212		pop	b
1213		pop	c
1214		pop	d	; calling global function basic_init

1215		push	d
1216		push	c
1217		push	b
1218		sliu d 1
1219		slil d 2
121a		push	d
121b		push	c
121c		sliu c 1
121d		slil c 3
121e		sliu d #basic_init	[01]
121f		slil d #basic_init	[0a]
1220		jmpfar	d d
1221		pop	b
1222		pop	c
1223		pop	d	; calling global function initvar

1224		push	d
1225		push	c
1226		push	b
1227		sliu d 1
1228		slil d 2
1229		push	d
122a		push	c
122b		sliu c 1
122c		slil c 13
122d		sliu d #initvar	[00]
122e		slil d #initvar	[00]
122f		jmpfar	d d
1230		pop	b
1231		pop	c
1232		pop	d	
		; main basic loop

1233	#basicloop
1233		sliu d 0
1234		slil d 13
1235		out	d
1236		sliu d 2
1237		slil d 0
1238		out	d	
		; print "Ok" prompt

1239		sliu a 7
123a		slil a 15
123b		sliu b #basic_prompt	[01]
123c		slil b #basic_prompt	[09]	; calling global function printstring

123d		push	d
123e		push	c
123f		push	b
1240		sliu d 1
1241		slil d 2
1242		push	d
1243		push	c
1244		sliu c 0
1245		slil c 5
1246		sliu d #printstring	[00]
1247		slil d #printstring	[00]
1248		jmpfar	d d
1249		pop	b
124a		pop	c
124b		pop	d
124c		sliu d 0
124d		slil d 13
124e		out	d
124f		sliu d 2
1250		slil d 0
1251		out	d	
		; read a string to fd00

1252		sliu a 15
1253		slil a 13
1254		sliu b 0
1255		slil b 0	; calling global function readstring

1256		push	d
1257		push	c
1258		push	b
1259		sliu d 1
125a		slil d 2
125b		push	d
125c		push	c
125d		sliu c 0
125e		slil c 6
125f		sliu d #readstring	[01]
1260		slil d #readstring	[03]
1261		jmpfar	d d
1262		pop	b
1263		pop	c
1264		pop	d	
		; convert it to tokens at fd80
	; calling global function tokenizeline

1265		push	d
1266		push	c
1267		push	b
1268		sliu d 1
1269		slil d 2
126a		push	d
126b		push	c
126c		sliu c 1
126d		slil c 3
126e		sliu d #tokenizeline	[00]
126f		slil d #tokenizeline	[00]
1270		jmpfar	d d
1271		pop	b
1272		pop	c
1273		pop	d
1274		push	a
1275		sliu d 0
1276		slil d 0
1277		sub	a d
1278		sliu d #@basic0	[08]
1279		slil d #@basic0	[00]
127a		skipz	a
127b		jalr	d d
127c		pop	a
127d		sliu d #basicloop_handle	[09]
127e		slil d #basicloop_handle	[07]
127f		jalr	d d
1280	#@basic0
1280		pop	a		; print error

1281		sliu a 7
1282		slil a 15
1283		sliu b #lexical_error	[01]
1284		slil b #lexical_error	[0f]	; calling global function printstring

1285		push	d
1286		push	c
1287		push	b
1288		sliu d 1
1289		slil d 2
128a		push	d
128b		push	c
128c		sliu c 0
128d		slil c 5
128e		sliu d #printstring	[00]
128f		slil d #printstring	[00]
1290		jmpfar	d d
1291		pop	b
1292		pop	c
1293		pop	d
1294		sliu d #basicloop	[03]
1295		slil d #basicloop	[03]
1296		jalr	d d	

1297	#basicloop_handle		; if the first token is a line number, save line in program space

1297		sliu a 15
1298		slil a 13
1299		page	a
129a		sliu c 8
129b		slil c 0
129c		load	a [c]
129d		push	a
129e		sliu d 3
129f		slil d 0
12a0		sub	a d
12a1		sliu d #@basic1	[0a]
12a2		slil d #@basic1	[09]
12a3		skipl	a
12a4		jalr	d d
12a5		pop	a
12a6		sliu d #basic_notprog	[0c]
12a7		slil d #basic_notprog	[09]
12a8		jalr	d d
12a9	#@basic1
12a9		pop	a
12aa		push	a
12ab		sliu d 3
12ac		slil d 10
12ad		sub	a d
12ae		sliu d #@basic2	[0b]
12af		slil d #@basic2	[06]
12b0		skipge	a
12b1		jalr	d d
12b2		pop	a
12b3		sliu d #basic_notprog	[0c]
12b4		slil d #basic_notprog	[09]
12b5		jalr	d d
12b6	#@basic2
12b6		pop	a	
	; calling global function basic_saveline

12b7		push	d
12b8		push	c
12b9		push	b
12ba		sliu d 1
12bb		slil d 2
12bc		push	d
12bd		push	c
12be		sliu c 1
12bf		slil c 3
12c0		sliu d #basic_saveline	[03]
12c1		slil d #basic_saveline	[0c]
12c2		jmpfar	d d
12c3		pop	b
12c4		pop	c
12c5		pop	d
12c6		sliu d #basicloop	[03]
12c7		slil d #basicloop	[03]
12c8		jalr	d d	

12c9	#basic_notprog	; calling global function basic_doline

12c9		push	d
12ca		push	c
12cb		push	b
12cc		sliu d 1
12cd		slil d 2
12ce		push	d
12cf		push	c
12d0		sliu c 1
12d1		slil c 5
12d2		sliu d #basic_doline	[00]
12d3		slil d #basic_doline	[00]
12d4		jmpfar	d d
12d5		pop	b
12d6		pop	c
12d7		pop	d
12d8		sliu d #basicloop	[03]
12d9		slil d #basicloop	[03]
12da		jalr	d d
12db		pop	d
12dc		pop	c
12dd		jmpfar	d d	
	; basic ends
	
	

12de		org 1300	
	; ------- GLOBAL FUNCTION tokenizeline -------

1300	#tokenizeline
1300		pop	c
1301		push	d
1302		sliu a 15
1303		slil a 13
1304		sliu b 0
1305		slil b 0
1306		sliu c 8
1307		slil c 0	; calling global function tokenize

1308		push	d
1309		push	c
130a		push	b
130b		sliu d 1
130c		slil d 3
130d		push	d
130e		push	c
130f		sliu c 1
1310		slil c 0
1311		sliu d #tokenize	[00]
1312		slil d #tokenize	[00]
1313		jmpfar	d d
1314		pop	b
1315		pop	c
1316		pop	d	;	li	a,0xfd
	;	li	b,0x80
	;	.call printstring
	;	li	a,0x0d
	;	out	a
	;	li	a,0x0a
	;	out	a
	;	li	a,0x20
	;	out	a

1317		pop	d
1318		pop	c
1319		jmpfar	d d	
	; tokenizeline ends
	
	
	
	; ------- GLOBAL FUNCTION basic_init -------

131a	#basic_init
131a		pop	c
131b		push	d		; goes from pages 0x90 to 0xcf and sets to 0

131c		sliu a 0
131d		slil a 0
131e		sliu c 9
131f		slil c 0
1320	#basic_init_pageloop
1320		page	c
1321		sliu b 0
1322		slil b 0
1323	#basic_init_addrloop
1323		sliu d 2
1324		slil d 0
1325		sub	b d
1326		store	a [b]
1327		sliu d #basic_init_addrloop	[02]
1328		slil d #basic_init_addrloop	[03]
1329		skipz	b
132a		jalr	d d
132b		inc	c
132c		push	c
132d		sliu d 13
132e		slil d 0
132f		sub	c d
1330		sliu d #@basic_init0	[03]
1331		slil d #@basic_init0	[08]
1332		skipnz	c
1333		jalr	d d
1334		pop	c
1335		sliu d #basic_init_pageloop	[02]
1336		slil d #basic_init_pageloop	[00]
1337		jalr	d d
1338	#@basic_init0
1338		pop	c
1339		pop	d
133a		pop	c
133b		jmpfar	d d	
	; basic_init ends
	
	
	
	; ------- GLOBAL FUNCTION basic_saveline -------

133c	#basic_saveline
133c		pop	c
133d		push	d		; copy line at fd80 to program space and link line number
		; program space from pages 90 to af, tokenized program from b0 to cf
		; each program line is given 0x20 space
	
		; push fdbf to fd80 to stack

133e		sliu a 15
133f		slil a 13
1340		page	a
1341		sliu b 9
1342		slil b 15
1343	#basic_saveline_pushloop
1343		load	a [b]
1344		push	a
1345		dec	b
1346		push	b
1347		sliu d 7
1348		slil d 15
1349		sub	b d
134a		sliu d #@basic_saveline0	[05]
134b		slil d #@basic_saveline0	[02]
134c		skipnz	b
134d		jalr	d d
134e		pop	b
134f		sliu d #basic_saveline_pushloop	[04]
1350		slil d #basic_saveline_pushloop	[03]
1351		jalr	d d
1352	#@basic_saveline0
1352		pop	b	
		; push fd1f to fd00 to stack

1353		sliu b 1
1354		slil b 15
1355	#basic_saveline_pushloop2
1355		load	a [b]
1356		push	a
1357		dec	b
1358		push	b
1359		sliu d 15
135a		slil d 15
135b		sub	b d
135c		sliu d #@basic_saveline1	[06]
135d		slil d #@basic_saveline1	[04]
135e		skipnz	b
135f		jalr	d d
1360		pop	b
1361		sliu d #basic_saveline_pushloop2	[05]
1362		slil d #basic_saveline_pushloop2	[05]
1363		jalr	d d
1364	#@basic_saveline1
1364		pop	b	
		; get line number

1365		sliu a 15
1366		slil a 13
1367		sliu b 8
1368		slil b 0	; calling global function dectobin

1369		push	d
136a		push	c
136b		push	b
136c		sliu d 1
136d		slil d 3
136e		push	d
136f		push	c
1370		sliu c 1
1371		slil c 4
1372		sliu d #dectobin	[00]
1373		slil d #dectobin	[00]
1374		jmpfar	d d
1375		pop	b
1376		pop	c
1377		pop	d	
		; divide it by eight to get the page number

1378		push	a
1379		sliu d 15
137a		slil d 8
137b		nand	a d
137c		nand	a a
137d		sliu b 0
137e		slil b 8	; calling global function div_even

137f		push	d
1380		push	c
1381		push	b
1382		sliu d 1
1383		slil d 3
1384		push	d
1385		push	c
1386		sliu c 0
1387		slil c 7
1388		sliu d #div_even	[06]
1389		slil d #div_even	[0a]
138a		jmpfar	d d
138b		pop	b
138c		pop	c
138d		pop	d
138e		sliu d 9
138f		slil d 0
1390		add	a d
1391		page	a
1392		sub	c c
1393		add	c a	
		; last three bits * 32 is the address

1394		pop	a
1395		sliu d 0
1396		slil d 7
1397		nand	a d
1398		nand	a a
1399		sliu b 2
139a		slil b 0	; calling global function mul

139b		push	d
139c		push	c
139d		push	b
139e		sliu d 1
139f		slil d 3
13a0		push	d
13a1		push	c
13a2		sliu c 0
13a3		slil c 8
13a4		sliu d #mul	[00]
13a5		slil d #mul	[00]
13a6		jmpfar	d d
13a7		pop	b
13a8		pop	c
13a9		pop	d	
		;copy string from stack

13aa		sliu b 2
13ab		slil b 0
13ac	#basic_saveline_poploop
13ac		pop	d
13ad		store	d [a]
13ae		inc	a
13af		dec	b
13b0		sliu d #basic_saveline_poploop	[0a]
13b1		slil d #basic_saveline_poploop	[0c]
13b2		skipz	b
13b3		jalr	d d	
		;advance page by 0x20 and copy tokenized from stack

13b4		sliu d 2
13b5		slil d 0
13b6		add	c d
13b7		page	c
13b8		sub	a d
13b9		sliu b 2
13ba		slil b 0
13bb	#basic_saveline_poploop2
13bb		pop	d
13bc		store	d [a]
13bd		inc	a
13be		dec	b
13bf		sliu d #basic_saveline_poploop2	[0b]
13c0		slil d #basic_saveline_poploop2	[0b]
13c1		skipz	b
13c2		jalr	d d
13c3		pop	d
13c4		pop	c
13c5		jmpfar	d d	
	; basic_saveline ends
	
	

13c6		org 1400	
	
	; ------- GLOBAL FUNCTION dectobin -------

1400	#dectobin
1400		pop	c
1401		push	d		;page in A, string addr in B terminated in ' ' or 0, returns num in A
	

1402		page	a
1403		sub	a a
1404	#dectobin_digloop
1404		load	c [b]		; check if digit is a ' ' or  \0

1405		sliu d #dectobin_digdone	[02]
1406		slil d #dectobin_digdone	[0c]
1407		skipnz	c
1408		jalr	d d
1409		sliu d 2
140a		slil d 0
140b		sub	c d
140c		sliu d #dectobin_digdone	[02]
140d		slil d #dectobin_digdone	[0c]
140e		skipnz	c
140f		jalr	d d	
		; multiply a = a * 10

1410		push	b
1411		sliu b 0
1412		slil b 10	; calling global function mul

1413		push	d
1414		push	c
1415		push	b
1416		sliu d 1
1417		slil d 4
1418		push	d
1419		push	c
141a		sliu c 0
141b		slil c 8
141c		sliu d #mul	[00]
141d		slil d #mul	[00]
141e		jmpfar	d d
141f		pop	b
1420		pop	c
1421		pop	d
1422		pop	b	
		; add digit

1423		load	c [b]
1424		add	a c
1425		sliu d 3
1426		slil d 0
1427		sub	a d	

1428		inc	b
1429		sliu d #dectobin_digloop	[00]
142a		slil d #dectobin_digloop	[04]
142b		jalr	d d
142c	#dectobin_digdone
142c		pop	d
142d		pop	c
142e		jmpfar	d d	
	; dectobin ends
	
	
	

142f		org 1500	
	; ------- GLOBAL FUNCTION basic_doline -------

1500	#basic_doline
1500		pop	c
1501		push	d		; fd:80 holds line to run
	
		; check for LIST

1502		sliu d 15
1503		slil d 13
1504		page	d
1505		sliu d 8
1506		slil d 0
1507		load	a [d]
1508		push	a
1509		sliu d 7
150a		slil d 3
150b		sub	a d
150c		sliu d #@basic_doline0	[01]
150d		slil d #@basic_doline0	[04]
150e		skipz	a
150f		jalr	d d
1510		pop	a
1511		sliu d #basic_dolist	[06]
1512		slil d #basic_dolist	[08]
1513		jalr	d d
1514	#@basic_doline0
1514		pop	a	
		; check for CLS

1515		push	a
1516		sliu d 6
1517		slil d 3
1518		sub	a d
1519		sliu d #@basic_doline1	[02]
151a		slil d #@basic_doline1	[01]
151b		skipz	a
151c		jalr	d d
151d		pop	a
151e		sliu d #basic_docls	[07]
151f		slil d #basic_docls	[0a]
1520		jalr	d d
1521	#@basic_doline1
1521		pop	a	
		; check for PRINT

1522		push	a
1523		sliu d 5
1524		slil d 0
1525		sub	a d
1526		sliu d #@basic_doline2	[02]
1527		slil d #@basic_doline2	[0e]
1528		skipz	a
1529		jalr	d d
152a		pop	a
152b		sliu d #basic_doprint	[08]
152c		slil d #basic_doprint	[0c]
152d		jalr	d d
152e	#@basic_doline2
152e		pop	a	
		; check for LET

152f		push	a
1530		sliu d 4
1531		slil d 12
1532		sub	a d
1533		sliu d #@basic_doline3	[03]
1534		slil d #@basic_doline3	[0b]
1535		skipz	a
1536		jalr	d d
1537		pop	a
1538		sliu d #basic_dolet	[09]
1539		slil d #basic_dolet	[0e]
153a		jalr	d d
153b	#@basic_doline3
153b		pop	a	
		; check for CLEAR

153c		push	a
153d		sliu d 6
153e		slil d 5
153f		sub	a d
1540		sliu d #@basic_doline4	[04]
1541		slil d #@basic_doline4	[08]
1542		skipz	a
1543		jalr	d d
1544		pop	a
1545		sliu d #basic_doclear	[0b]
1546		slil d #basic_doclear	[00]
1547		jalr	d d
1548	#@basic_doline4
1548		pop	a	

1549		push	a
154a		sliu d 0
154b		slil d 0
154c		sub	a d
154d		sliu d #@basic_doline5	[05]
154e		slil d #@basic_doline5	[05]
154f		skipz	a
1550		jalr	d d
1551		pop	a
1552		sliu d #basic_done	[0c]
1553		slil d #basic_done	[02]
1554		jalr	d d
1555	#@basic_doline5
1555		pop	a	
	; calling global function mark_error

1556		push	d
1557		push	c
1558		push	b
1559		sliu d 1
155a		slil d 5
155b		push	d
155c		push	c
155d		sliu c 1
155e		slil c 12
155f		sliu d #mark_error	[00]
1560		slil d #mark_error	[00]
1561		jmpfar	d d
1562		pop	b
1563		pop	c
1564		pop	d
1565		sliu d #basic_done	[0c]
1566		slil d #basic_done	[02]
1567		jalr	d d	

1568	#basic_dolist	; calling global function doLIST

1568		push	d
1569		push	c
156a		push	b
156b		sliu d 1
156c		slil d 5
156d		push	d
156e		push	c
156f		sliu c 1
1570		slil c 14
1571		sliu d #doLIST	[09]
1572		slil d #doLIST	[07]
1573		jmpfar	d d
1574		pop	b
1575		pop	c
1576		pop	d
1577		sliu d #basic_done	[0c]
1578		slil d #basic_done	[02]
1579		jalr	d d	

157a	#basic_docls	; calling global function doCLS

157a		push	d
157b		push	c
157c		push	b
157d		sliu d 1
157e		slil d 5
157f		push	d
1580		push	c
1581		sliu c 1
1582		slil c 14
1583		sliu d #doCLS	[0d]
1584		slil d #doCLS	[02]
1585		jmpfar	d d
1586		pop	b
1587		pop	c
1588		pop	d
1589		sliu d #basic_done	[0c]
158a		slil d #basic_done	[02]
158b		jalr	d d	

158c	#basic_doprint	; calling global function doPRINT

158c		push	d
158d		push	c
158e		push	b
158f		sliu d 1
1590		slil d 5
1591		push	d
1592		push	c
1593		sliu c 1
1594		slil c 6
1595		sliu d #doPRINT	[00]
1596		slil d #doPRINT	[00]
1597		jmpfar	d d
1598		pop	b
1599		pop	c
159a		pop	d
159b		sliu d #basic_done	[0c]
159c		slil d #basic_done	[02]
159d		jalr	d d	

159e	#basic_dolet	; calling global function doLET

159e		push	d
159f		push	c
15a0		push	b
15a1		sliu d 1
15a2		slil d 5
15a3		push	d
15a4		push	c
15a5		sliu c 1
15a6		slil c 14
15a7		sliu d #doLET	[00]
15a8		slil d #doLET	[00]
15a9		jmpfar	d d
15aa		pop	b
15ab		pop	c
15ac		pop	d
15ad		sliu d #basic_done	[0c]
15ae		slil d #basic_done	[02]
15af		jalr	d d	

15b0	#basic_doclear	; calling global function initvar

15b0		push	d
15b1		push	c
15b2		push	b
15b3		sliu d 1
15b4		slil d 5
15b5		push	d
15b6		push	c
15b7		sliu c 1
15b8		slil c 13
15b9		sliu d #initvar	[00]
15ba		slil d #initvar	[00]
15bb		jmpfar	d d
15bc		pop	b
15bd		pop	c
15be		pop	d
15bf		sliu d #basic_done	[0c]
15c0		slil d #basic_done	[02]
15c1		jalr	d d	

15c2	#basic_done	; calling global function error_marked

15c2		push	d
15c3		push	c
15c4		push	b
15c5		sliu d 1
15c6		slil d 5
15c7		push	d
15c8		push	c
15c9		sliu c 1
15ca		slil c 12
15cb		sliu d #error_marked	[00]
15cc		slil d #error_marked	[08]
15cd		jmpfar	d d
15ce		pop	b
15cf		pop	c
15d0		pop	d
15d1		push	a
15d2		sliu d 0
15d3		slil d 0
15d4		sub	a d
15d5		sliu d #@basic_doline6	[0d]
15d6		slil d #@basic_doline6	[0d]
15d7		skipz	a
15d8		jalr	d d
15d9		pop	a
15da		sliu d #basic_line_ret	[0f]
15db		slil d #basic_line_ret	[01]
15dc		jalr	d d
15dd	#@basic_doline6
15dd		pop	a
15de		sliu a 7
15df		slil a 15
15e0		sliu b #syntax_error	[03]
15e1		slil b #syntax_error	[01]	; calling global function printstring

15e2		push	d
15e3		push	c
15e4		push	b
15e5		sliu d 1
15e6		slil d 5
15e7		push	d
15e8		push	c
15e9		sliu c 0
15ea		slil c 5
15eb		sliu d #printstring	[00]
15ec		slil d #printstring	[00]
15ed		jmpfar	d d
15ee		pop	b
15ef		pop	c
15f0		pop	d
15f1	#basic_line_ret
15f1		pop	d
15f2		pop	c
15f3		jmpfar	d d	
	; basic_doline ends
	
	

15f4		org 1600	
	; ------- GLOBAL FUNCTION doPRINT -------

1600	#doPRINT
1600		pop	c
1601		push	d		; start at beginning of line

1602		sliu c 8
1603		slil c 2	

1604	#doprint_loop		; get the token

1604		load	a [c]		; handle " 

1605		push	a
1606		sliu d 2
1607		slil d 2
1608		sub	a d
1609		sliu d #@doPRINT0	[01]
160a		slil d #@doPRINT0	[01]
160b		skipz	a
160c		jalr	d d
160d		pop	a
160e		sliu d #doprint_str	[07]
160f		slil d #doprint_str	[04]
1610		jalr	d d
1611	#@doPRINT0
1611		pop	a		; handle ,

1612		push	a
1613		sliu d 2
1614		slil d 12
1615		sub	a d
1616		sliu d #@doPRINT1	[01]
1617		slil d #@doPRINT1	[0e]
1618		skipz	a
1619		jalr	d d
161a		pop	a
161b		sliu d #doprint_comma	[06]
161c		slil d #doprint_comma	[03]
161d		jalr	d d
161e	#@doPRINT1
161e		pop	a		; handle ;

161f		push	a
1620		sliu d 3
1621		slil d 11
1622		sub	a d
1623		sliu d #@doPRINT2	[02]
1624		slil d #@doPRINT2	[0b]
1625		skipz	a
1626		jalr	d d
1627		pop	a
1628		sliu d #doprint_semicolon	[05]
1629		slil d #doprint_semicolon	[0d]
162a		jalr	d d
162b	#@doPRINT2
162b		pop	a		; handle eol

162c		push	a
162d		sliu d 0
162e		slil d 0
162f		sub	a d
1630		sliu d #@doPRINT3	[03]
1631		slil d #@doPRINT3	[08]
1632		skipz	a
1633		jalr	d d
1634		pop	a
1635		sliu d #doprint_eol	[06]
1636		slil d #doprint_eol	[0b]
1637		jalr	d d
1638	#@doPRINT3
1638		pop	a		; evaluate expression
	; calling global function eval_expression

1639		push	d
163a		push	c
163b		push	b
163c		sliu d 1
163d		slil d 6
163e		push	d
163f		push	c
1640		sliu c 1
1641		slil c 7
1642		sliu d #eval_expression	[00]
1643		slil d #eval_expression	[00]
1644		jmpfar	d d
1645		pop	b
1646		pop	c
1647		pop	d
1648		sliu c 15
1649		slil c 15
164a		load	c [c]	; calling global function print_integer

164b		push	d
164c		push	c
164d		push	b
164e		sliu d 1
164f		slil d 6
1650		push	d
1651		push	c
1652		sliu c 1
1653		slil c 11
1654		sliu d #print_integer	[00]
1655		slil d #print_integer	[00]
1656		jmpfar	d d
1657		pop	b
1658		pop	c
1659		pop	d
165a		sliu d #doprint_loop	[00]
165b		slil d #doprint_loop	[04]
165c		jalr	d d	

165d	#doprint_semicolon		; print a space separator and end

165d		sliu d 2
165e		slil d 0
165f		out	d	

1660		sliu d #doprint_done	[09]
1661		slil d #doprint_done	[09]
1662		jalr	d d	

1663	#doprint_comma		; print a space separator

1663		sliu d 2
1664		slil d 0
1665		out	d
1666		inc	c
1667		inc	c
1668		sliu d #doprint_loop	[00]
1669		slil d #doprint_loop	[04]
166a		jalr	d d	

166b	#doprint_eol		; print a newline and end

166b		sliu d 0
166c		slil d 13
166d		out	d
166e		sliu d 2
166f		slil d 0
1670		out	d
1671		sliu d #doprint_done	[09]
1672		slil d #doprint_done	[09]
1673		jalr	d d	

1674	#doprint_str		; advance past "

1674		inc	c		; read chars and print until reach other "

1675		load	a [c]
1676		push	a
1677		sliu d 2
1678		slil d 2
1679		sub	a d
167a		sliu d #@doPRINT4	[08]
167b		slil d #@doPRINT4	[02]
167c		skipz	a
167d		jalr	d d
167e		pop	a
167f		sliu d #doprint_str_done	[09]
1680		slil d #doprint_str_done	[04]
1681		jalr	d d
1682	#@doPRINT4
1682		pop	a
1683		push	a
1684		sliu d 0
1685		slil d 0
1686		sub	a d
1687		sliu d #@doPRINT5	[08]
1688		slil d #@doPRINT5	[0f]
1689		skipz	a
168a		jalr	d d
168b		pop	a
168c		sliu d #doprint_eol	[06]
168d		slil d #doprint_eol	[0b]
168e		jalr	d d
168f	#@doPRINT5
168f		pop	a
1690		out	a
1691		sliu d #doprint_str	[07]
1692		slil d #doprint_str	[04]
1693		jalr	d d
1694	#doprint_str_done
1694		inc	c
1695		inc	c
1696		sliu d #doprint_loop	[00]
1697		slil d #doprint_loop	[04]
1698		jalr	d d
1699	#doprint_done
1699		pop	d
169a		pop	c
169b		jmpfar	d d	
	; doPRINT ends
	
	

169c		org 1700	
	; ------- GLOBAL FUNCTION eval_expression -------

1700	#eval_expression
1700		pop	c
1701		push	d	
		;C points to expression, A returns value, 0xff returns new C
	
		;expression is: term | term + term [ + term ]* | term - term [ - term]*
	
		; stop if there's a pending error
	; calling global function error_marked

1702		push	d
1703		push	c
1704		push	b
1705		sliu d 1
1706		slil d 7
1707		push	d
1708		push	c
1709		sliu c 1
170a		slil c 12
170b		sliu d #error_marked	[00]
170c		slil d #error_marked	[08]
170d		jmpfar	d d
170e		pop	b
170f		pop	c
1710		pop	d
1711		sliu d #eval_expression_end	[0c]
1712		slil d #eval_expression_end	[0a]
1713		skipz	a
1714		jalr	d d	
		; get the first term
	; calling global function eval_term

1715		push	d
1716		push	c
1717		push	b
1718		sliu d 1
1719		slil d 7
171a		push	d
171b		push	c
171c		sliu c 1
171d		slil c 8
171e		sliu d #eval_term	[00]
171f		slil d #eval_term	[00]
1720		jmpfar	d d
1721		pop	b
1722		pop	c
1723		pop	d
1724		sliu c 15
1725		slil c 15
1726		load	c [c]	

1727	#eval_expression_loop		; stop if an error

1727		push	a	; calling global function error_marked

1728		push	d
1729		push	c
172a		push	b
172b		sliu d 1
172c		slil d 7
172d		push	d
172e		push	c
172f		sliu c 1
1730		slil c 12
1731		sliu d #error_marked	[00]
1732		slil d #error_marked	[08]
1733		jmpfar	d d
1734		pop	b
1735		pop	c
1736		pop	d
1737		sliu d #eval_expression_errorstop	[0b]
1738		slil d #eval_expression_errorstop	[06]
1739		skipz	a
173a		jalr	d d
173b		pop	a	
		; check for valid end tokens: 0x00 ',' ';' ')'
		; 0x00

173c		load	b [c]
173d		sliu d #eval_expression_end	[0c]
173e		slil d #eval_expression_end	[0a]
173f		skipnz	b
1740		jalr	d d		; ,

1741		load	b [c]
1742		sliu d 2
1743		slil d 12
1744		sub	b d
1745		sliu d #eval_expression_end	[0c]
1746		slil d #eval_expression_end	[0a]
1747		skipnz	b
1748		jalr	d d		; ;

1749		load	b [c]
174a		sliu d 3
174b		slil d 11
174c		sub	b d
174d		sliu d #eval_expression_end	[0c]
174e		slil d #eval_expression_end	[0a]
174f		skipnz	b
1750		jalr	d d		; )

1751		load	b [c]
1752		sliu d 2
1753		slil d 9
1754		sub	b d
1755		sliu d #eval_expression_end	[0c]
1756		slil d #eval_expression_end	[0a]
1757		skipnz	b
1758		jalr	d d		
		; check for arithmetic tokens: + or -

1759		load	b [c]
175a		sliu d 2
175b		slil d 11
175c		sub	b d
175d		sliu d #eval_expression_plusminus	[06]
175e		slil d #eval_expression_plusminus	[0c]
175f		skipnz	b
1760		jalr	d d
1761		load	b [c]
1762		sliu d 2
1763		slil d 13
1764		sub	b d
1765		sliu d #eval_expression_plusminus	[06]
1766		slil d #eval_expression_plusminus	[0c]
1767		skipnz	b
1768		jalr	d d	
		; otherwise error

1769		sliu d #eval_expression_error	[0b]
176a		slil d #eval_expression_error	[0b]
176b		jalr	d d	

176c	#eval_expression_plusminus		; push operation

176c		load	b [c]
176d		push	b	
		; save current sum into b

176e		sub	b b
176f		add	b a	
		; move to next token

1770		inc	c		; if nothing after the plus then error

1771		load	a [c]
1772		sliu d #eval_expression_errorpopop	[0b]
1773		slil d #eval_expression_errorpopop	[0a]
1774		skipnz	a
1775		jalr	d d
1776		inc	c	
		; get the next term
	; calling global function eval_term

1777		push	d
1778		push	c
1779		push	b
177a		sliu d 1
177b		slil d 7
177c		push	d
177d		push	c
177e		sliu c 1
177f		slil c 8
1780		sliu d #eval_term	[00]
1781		slil d #eval_term	[00]
1782		jmpfar	d d
1783		pop	b
1784		pop	c
1785		pop	d
1786		sliu c 15
1787		slil c 15
1788		load	c [c]	
		; stop if an error

1789		push	a	; calling global function error_marked

178a		push	d
178b		push	c
178c		push	b
178d		sliu d 1
178e		slil d 7
178f		push	d
1790		push	c
1791		sliu c 1
1792		slil c 12
1793		sliu d #error_marked	[00]
1794		slil d #error_marked	[08]
1795		jmpfar	d d
1796		pop	b
1797		pop	c
1798		pop	d
1799		sliu d #eval_expression_errorstoppop	[0b]
179a		slil d #eval_expression_errorstoppop	[05]
179b		skipz	a
179c		jalr	d d
179d		pop	a	

179e		push	c		; reload the operation

179f		pop	d
17a0		pop	c
17a1		push	d
17a2		sliu d 2
17a3		slil d 13
17a4		sub	c d
17a5		sliu d #eval_expression_sub	[0a]
17a6		slil d #eval_expression_sub	[0e]
17a7		skipnz	c
17a8		jalr	d d		; add it

17a9		add	a b
17aa		pop	c
17ab		sliu d #eval_expression_loop	[02]
17ac		slil d #eval_expression_loop	[07]
17ad		jalr	d d
17ae	#eval_expression_sub		; subtract it

17ae		sub	b a
17af		sub	a a
17b0		add	a b
17b1		pop	c
17b2		sliu d #eval_expression_loop	[02]
17b3		slil d #eval_expression_loop	[07]
17b4		jalr	d d	

17b5	#eval_expression_errorstoppop
17b5		pop	d
17b6	#eval_expression_errorstop
17b6		pop	a
17b7		sliu d #eval_expression_end	[0c]
17b8		slil d #eval_expression_end	[0a]
17b9		jalr	d d
17ba	#eval_expression_errorpopop
17ba		pop	d
17bb	#eval_expression_error	; calling global function mark_error

17bb		push	d
17bc		push	c
17bd		push	b
17be		sliu d 1
17bf		slil d 7
17c0		push	d
17c1		push	c
17c2		sliu c 1
17c3		slil c 12
17c4		sliu d #mark_error	[00]
17c5		slil d #mark_error	[00]
17c6		jmpfar	d d
17c7		pop	b
17c8		pop	c
17c9		pop	d
17ca	#eval_expression_end
17ca		sliu d 15
17cb		slil d 15
17cc		store	c [d]
17cd		pop	d
17ce		pop	c
17cf		jmpfar	d d	
	; eval_expression ends
	
	

17d0		org 1800	
	; ------- GLOBAL FUNCTION eval_term -------

1800	#eval_term
1800		pop	c
1801		push	d	
		;C points to expression, A returns value, 0xff returns new C
	
		;expression is: paren | paren * paren [ * paren ]* | paren / paren [ / paren]*
	
		; stop if there's a pending error
	; calling global function error_marked

1802		push	d
1803		push	c
1804		push	b
1805		sliu d 1
1806		slil d 8
1807		push	d
1808		push	c
1809		sliu c 1
180a		slil c 12
180b		sliu d #error_marked	[00]
180c		slil d #error_marked	[08]
180d		jmpfar	d d
180e		pop	b
180f		pop	c
1810		pop	d
1811		sliu d #eval_term_end	[0e]
1812		slil d #eval_term_end	[0e]
1813		skipz	a
1814		jalr	d d	
		; get the first term
	; calling global function eval_paren

1815		push	d
1816		push	c
1817		push	b
1818		sliu d 1
1819		slil d 8
181a		push	d
181b		push	c
181c		sliu c 1
181d		slil c 9
181e		sliu d #eval_paren	[00]
181f		slil d #eval_paren	[00]
1820		jmpfar	d d
1821		pop	b
1822		pop	c
1823		pop	d
1824		sliu c 15
1825		slil c 15
1826		load	c [c]	

1827	#eval_term_loop		; stop if an error

1827		push	a	; calling global function error_marked

1828		push	d
1829		push	c
182a		push	b
182b		sliu d 1
182c		slil d 8
182d		push	d
182e		push	c
182f		sliu c 1
1830		slil c 12
1831		sliu d #error_marked	[00]
1832		slil d #error_marked	[08]
1833		jmpfar	d d
1834		pop	b
1835		pop	c
1836		pop	d
1837		sliu d #eval_term_errorstop	[0d]
1838		slil d #eval_term_errorstop	[0a]
1839		skipz	a
183a		jalr	d d
183b		pop	a	
		; check for end token 0x00

183c		load	b [c]
183d		sliu d #eval_term_end	[0e]
183e		slil d #eval_term_end	[0e]
183f		skipnz	b
1840		jalr	d d		
		; check for arithmetic tokens: * or / or %

1841		load	b [c]		;* is 2a

1842		sliu d 2
1843		slil d 10
1844		sub	b d
1845		sliu d #eval_term_multdiv	[05]
1846		slil d #eval_term_multdiv	[0a]
1847		skipnz	b
1848		jalr	d d		;/ is 2f

1849		sliu d 0
184a		slil d 5
184b		sub	b d
184c		sliu d #eval_term_multdiv	[05]
184d		slil d #eval_term_multdiv	[0a]
184e		skipnz	b
184f		jalr	d d		;% is 25

1850		sliu d 0
1851		slil d 10
1852		add	b d
1853		sliu d #eval_term_multdiv	[05]
1854		slil d #eval_term_multdiv	[0a]
1855		skipnz	b
1856		jalr	d d	
		; otherwise done

1857		sliu d #eval_term_end	[0e]
1858		slil d #eval_term_end	[0e]
1859		jalr	d d	

185a	#eval_term_multdiv		; save operation

185a		load	b [c]
185b		push	b	
		; save current product into b

185c		sub	b b
185d		add	b a	
		; move to next token

185e		inc	c		; if nothing after the * then error

185f		load	a [c]
1860		sliu d #eval_term_errorpop	[0d]
1861		slil d #eval_term_errorpop	[0e]
1862		skipnz	a
1863		jalr	d d
1864		inc	c	
		; get the next term
	; calling global function eval_paren

1865		push	d
1866		push	c
1867		push	b
1868		sliu d 1
1869		slil d 8
186a		push	d
186b		push	c
186c		sliu c 1
186d		slil c 9
186e		sliu d #eval_paren	[00]
186f		slil d #eval_paren	[00]
1870		jmpfar	d d
1871		pop	b
1872		pop	c
1873		pop	d
1874		sliu c 15
1875		slil c 15
1876		load	c [c]	
		; stop if an error

1877		push	a	; calling global function error_marked

1878		push	d
1879		push	c
187a		push	b
187b		sliu d 1
187c		slil d 8
187d		push	d
187e		push	c
187f		sliu c 1
1880		slil c 12
1881		sliu d #error_marked	[00]
1882		slil d #error_marked	[08]
1883		jmpfar	d d
1884		pop	b
1885		pop	c
1886		pop	d
1887		sliu d #eval_term_errorstoppop	[0d]
1888		slil d #eval_term_errorstoppop	[09]
1889		skipz	a
188a		jalr	d d
188b		pop	a	
		;swap a and b

188c		push	a
188d		push	b
188e		pop	a
188f		pop	b	

1890		pop	d
1891		push	c		; reload the operation

1892		sliu c 2
1893		slil c 15
1894		sub	c d
1895		sliu d #eval_term_div	[0b]
1896		slil d #eval_term_div	[03]
1897		skipnz	c
1898		jalr	d d
1899		sliu d 0
189a		slil d 10
189b		sub	c d
189c		sliu d #eval_term_mod	[0c]
189d		slil d #eval_term_mod	[06]
189e		skipnz	c
189f		jalr	d d		; multiply it
	; calling global function mul

18a0		push	d
18a1		push	c
18a2		push	b
18a3		sliu d 1
18a4		slil d 8
18a5		push	d
18a6		push	c
18a7		sliu c 0
18a8		slil c 8
18a9		sliu d #mul	[00]
18aa		slil d #mul	[00]
18ab		jmpfar	d d
18ac		pop	b
18ad		pop	c
18ae		pop	d
18af		pop	c
18b0		sliu d #eval_term_loop	[02]
18b1		slil d #eval_term_loop	[07]
18b2		jalr	d d
18b3	#eval_term_div		; divide it
	; calling global function div

18b3		push	d
18b4		push	c
18b5		push	b
18b6		sliu d 1
18b7		slil d 8
18b8		push	d
18b9		push	c
18ba		sliu c 0
18bb		slil c 7
18bc		sliu d #div	[00]
18bd		slil d #div	[00]
18be		jmpfar	d d
18bf		pop	b
18c0		pop	c
18c1		pop	d
18c2		pop	c
18c3		sliu d #eval_term_loop	[02]
18c4		slil d #eval_term_loop	[07]
18c5		jalr	d d
18c6	#eval_term_mod		; mod it
	; calling global function mod

18c6		push	d
18c7		push	c
18c8		push	b
18c9		sliu d 1
18ca		slil d 8
18cb		push	d
18cc		push	c
18cd		sliu c 0
18ce		slil c 7
18cf		sliu d #mod	[08]
18d0		slil d #mod	[05]
18d1		jmpfar	d d
18d2		pop	b
18d3		pop	c
18d4		pop	d
18d5		pop	c
18d6		sliu d #eval_term_loop	[02]
18d7		slil d #eval_term_loop	[07]
18d8		jalr	d d	

18d9	#eval_term_errorstoppop
18d9		pop	d
18da	#eval_term_errorstop
18da		pop	a
18db		sliu d #eval_term_end	[0e]
18dc		slil d #eval_term_end	[0e]
18dd		jalr	d d
18de	#eval_term_errorpop
18de		pop	d
18df	#eval_term_error	; calling global function mark_error

18df		push	d
18e0		push	c
18e1		push	b
18e2		sliu d 1
18e3		slil d 8
18e4		push	d
18e5		push	c
18e6		sliu c 1
18e7		slil c 12
18e8		sliu d #mark_error	[00]
18e9		slil d #mark_error	[00]
18ea		jmpfar	d d
18eb		pop	b
18ec		pop	c
18ed		pop	d
18ee	#eval_term_end
18ee		sliu d 15
18ef		slil d 15
18f0		store	c [d]
18f1		pop	d
18f2		pop	c
18f3		jmpfar	d d	
	; eval_term ends
	
	

18f4		org 1900	
	; ------- GLOBAL FUNCTION eval_paren -------

1900	#eval_paren
1900		pop	c
1901		push	d		;expression is: numvar | ( expression )
	
		; stop if there's a pending error
	; calling global function error_marked

1902		push	d
1903		push	c
1904		push	b
1905		sliu d 1
1906		slil d 9
1907		push	d
1908		push	c
1909		sliu c 1
190a		slil c 12
190b		sliu d #error_marked	[00]
190c		slil d #error_marked	[08]
190d		jmpfar	d d
190e		pop	b
190f		pop	c
1910		pop	d
1911		sliu d #eval_paren_end	[0a]
1912		slil d #eval_paren_end	[03]
1913		skipz	a
1914		jalr	d d	
		; is the first token a ( ?

1915		load	a [c]
1916		push	a
1917		sliu d 2
1918		slil d 8
1919		sub	a d
191a		sliu d #@eval_paren0	[02]
191b		slil d #@eval_paren0	[02]
191c		skipz	a
191d		jalr	d d
191e		pop	a
191f		sliu d #eval_paren_paren	[03]
1920		slil d #eval_paren_paren	[08]
1921		jalr	d d
1922	#@eval_paren0
1922		pop	a	
		; get the first term
	; calling global function eval_numorvar

1923		push	d
1924		push	c
1925		push	b
1926		sliu d 1
1927		slil d 9
1928		push	d
1929		push	c
192a		sliu c 1
192b		slil c 10
192c		sliu d #eval_numorvar	[00]
192d		slil d #eval_numorvar	[00]
192e		jmpfar	d d
192f		pop	b
1930		pop	c
1931		pop	d
1932		sliu c 15
1933		slil c 15
1934		load	c [c]
1935		sliu d #eval_paren_end	[0a]
1936		slil d #eval_paren_end	[03]
1937		jalr	d d	

1938	#eval_paren_paren		;advance to expression

1938		inc	c		;no eol allowed

1939		load	b [c]
193a		push	b
193b		sliu d 0
193c		slil d 0
193d		sub	b d
193e		sliu d #@eval_paren1	[04]
193f		slil d #@eval_paren1	[06]
1940		skipz	b
1941		jalr	d d
1942		pop	b
1943		sliu d #eval_paren_error	[09]
1944		slil d #eval_paren_error	[00]
1945		jalr	d d
1946	#@eval_paren1
1946		pop	b
1947		inc	c	
		;parse it
	; calling global function eval_expression

1948		push	d
1949		push	c
194a		push	b
194b		sliu d 1
194c		slil d 9
194d		push	d
194e		push	c
194f		sliu c 1
1950		slil c 7
1951		sliu d #eval_expression	[00]
1952		slil d #eval_expression	[00]
1953		jmpfar	d d
1954		pop	b
1955		pop	c
1956		pop	d
1957		sliu c 15
1958		slil c 15
1959		load	c [c]	
		;don't continue if an error

195a		push	a	; calling global function error_marked

195b		push	d
195c		push	c
195d		push	b
195e		sliu d 1
195f		slil d 9
1960		push	d
1961		push	c
1962		sliu c 1
1963		slil c 12
1964		sliu d #error_marked	[00]
1965		slil d #error_marked	[08]
1966		jmpfar	d d
1967		pop	b
1968		pop	c
1969		pop	d
196a		sliu d #eval_paren_stoperror	[0a]
196b		slil d #eval_paren_stoperror	[02]
196c		skipz	a
196d		jalr	d d
196e		pop	a	
		;there better be a ) next

196f		load	b [c]
1970		push	b
1971		sliu d 2
1972		slil d 9
1973		sub	b d
1974		sliu d #@eval_paren2	[07]
1975		slil d #@eval_paren2	[0c]
1976		skipnz	b
1977		jalr	d d
1978		pop	b
1979		sliu d #eval_paren_error	[09]
197a		slil d #eval_paren_error	[00]
197b		jalr	d d
197c	#@eval_paren2
197c		pop	b
197d		inc	c
197e		load	b [c]
197f		push	b
1980		sliu d 0
1981		slil d 0
1982		sub	b d
1983		sliu d #@eval_paren3	[08]
1984		slil d #@eval_paren3	[0b]
1985		skipz	b
1986		jalr	d d
1987		pop	b
1988		sliu d #eval_paren_end	[0a]
1989		slil d #eval_paren_end	[03]
198a		jalr	d d
198b	#@eval_paren3
198b		pop	b
198c		inc	c
198d		sliu d #eval_paren_end	[0a]
198e		slil d #eval_paren_end	[03]
198f		jalr	d d	

1990	#eval_paren_error	; calling global function mark_error

1990		push	d
1991		push	c
1992		push	b
1993		sliu d 1
1994		slil d 9
1995		push	d
1996		push	c
1997		sliu c 1
1998		slil c 12
1999		sliu d #mark_error	[00]
199a		slil d #mark_error	[00]
199b		jmpfar	d d
199c		pop	b
199d		pop	c
199e		pop	d
199f		sliu d #eval_paren_end	[0a]
19a0		slil d #eval_paren_end	[03]
19a1		jalr	d d
19a2	#eval_paren_stoperror
19a2		pop	a
19a3	#eval_paren_end
19a3		sliu d 15
19a4		slil d 15
19a5		store	c [d]
19a6		pop	d
19a7		pop	c
19a8		jmpfar	d d	
	; eval_paren ends
	
	

19a9		org 1a00	
	; ------- GLOBAL FUNCTION eval_numorvar -------

1a00	#eval_numorvar
1a00		pop	c
1a01		push	d	
		; parses an integer token or returns a variable value
	
		; stop if there's a pending error
	; calling global function error_marked

1a02		push	d
1a03		push	c
1a04		push	b
1a05		sliu d 1
1a06		slil d 10
1a07		push	d
1a08		push	c
1a09		sliu c 1
1a0a		slil c 12
1a0b		sliu d #error_marked	[00]
1a0c		slil d #error_marked	[08]
1a0d		jmpfar	d d
1a0e		pop	b
1a0f		pop	c
1a10		pop	d
1a11		push	a
1a12		sliu d 0
1a13		slil d 0
1a14		sub	a d
1a15		sliu d #@eval_numorvar0	[01]
1a16		slil d #@eval_numorvar0	[0d]
1a17		skipnz	a
1a18		jalr	d d
1a19		pop	a
1a1a		sliu d #eval_numorvar_end	[0c]
1a1b		slil d #eval_numorvar_end	[0e]
1a1c		jalr	d d
1a1d	#@eval_numorvar0
1a1d		pop	a	
		; up to three numbers
		; get the first

1a1e		load	a [c]	
		; check for var

1a1f		push	a
1a20		sliu d 2
1a21		slil d 3
1a22		sub	a d
1a23		sliu d #@eval_numorvar1	[02]
1a24		slil d #@eval_numorvar1	[0b]
1a25		skipz	a
1a26		jalr	d d
1a27		pop	a
1a28		sliu d #eval_numorvar_var	[0b]
1a29		slil d #eval_numorvar_var	[0c]
1a2a		jalr	d d
1a2b	#@eval_numorvar1
1a2b		pop	a	
		; check for not number or var

1a2c		push	a
1a2d		sliu d 3
1a2e		slil d 0
1a2f		sub	a d
1a30		sliu d #@eval_numorvar2	[03]
1a31		slil d #@eval_numorvar2	[08]
1a32		skipl	a
1a33		jalr	d d
1a34		pop	a
1a35		sliu d #eval_numorvar_error	[0a]
1a36		slil d #eval_numorvar_error	[0a]
1a37		jalr	d d
1a38	#@eval_numorvar2
1a38		pop	a
1a39		push	a
1a3a		sliu d 3
1a3b		slil d 9
1a3c		sub	a d
1a3d		sub	d d
1a3e		sub	d a
1a3f		sub	a a
1a40		add	a d
1a41		sliu d #@eval_numorvar3	[04]
1a42		slil d #@eval_numorvar3	[09]
1a43		skipl	a
1a44		jalr	d d
1a45		pop	a
1a46		sliu d #eval_numorvar_error	[0a]
1a47		slil d #eval_numorvar_error	[0a]
1a48		jalr	d d
1a49	#@eval_numorvar3
1a49		pop	a	
		; adjust from ascii

1a4a		sliu b 3
1a4b		slil b 0
1a4c		sub	a b
1a4d		inc	c		; get tens place

1a4e		load	b [c]		; stop if space

1a4f		push	b
1a50		sliu d 2
1a51		slil d 0
1a52		sub	b d
1a53		sliu d #@eval_numorvar4	[05]
1a54		slil d #@eval_numorvar4	[0b]
1a55		skipz	b
1a56		jalr	d d
1a57		pop	b
1a58		sliu d #eval_numorvar_numdone	[09]
1a59		slil d #eval_numorvar_numdone	[08]
1a5a		jalr	d d
1a5b	#@eval_numorvar4
1a5b		pop	b		; multiply hundreds place by 10

1a5c		sliu b 0
1a5d		slil b 10	; calling global function mul

1a5e		push	d
1a5f		push	c
1a60		push	b
1a61		sliu d 1
1a62		slil d 10
1a63		push	d
1a64		push	c
1a65		sliu c 0
1a66		slil c 8
1a67		sliu d #mul	[00]
1a68		slil d #mul	[00]
1a69		jmpfar	d d
1a6a		pop	b
1a6b		pop	c
1a6c		pop	d		; reload tens place and add it

1a6d		load	b [c]
1a6e		add	a b
1a6f		sliu b 3
1a70		slil b 0
1a71		sub	a b
1a72		inc	c		; get ones place

1a73		load	b [c]		; stop if space

1a74		push	b
1a75		sliu d 2
1a76		slil d 0
1a77		sub	b d
1a78		sliu d #@eval_numorvar5	[08]
1a79		slil d #@eval_numorvar5	[00]
1a7a		skipz	b
1a7b		jalr	d d
1a7c		pop	b
1a7d		sliu d #eval_numorvar_numdone	[09]
1a7e		slil d #eval_numorvar_numdone	[08]
1a7f		jalr	d d
1a80	#@eval_numorvar5
1a80		pop	b		; multiply 100s and 10s by 10

1a81		sliu b 0
1a82		slil b 10	; calling global function mul

1a83		push	d
1a84		push	c
1a85		push	b
1a86		sliu d 1
1a87		slil d 10
1a88		push	d
1a89		push	c
1a8a		sliu c 0
1a8b		slil c 8
1a8c		sliu d #mul	[00]
1a8d		slil d #mul	[00]
1a8e		jmpfar	d d
1a8f		pop	b
1a90		pop	c
1a91		pop	d
1a92		load	b [c]
1a93		add	a b
1a94		sliu b 3
1a95		slil b 0
1a96		sub	a b
1a97		inc	c	

1a98	#eval_numorvar_numdone		; next thing should be space or eol

1a98		load	b [c]
1a99		push	b
1a9a		sliu d 0
1a9b		slil d 0
1a9c		sub	b d
1a9d		sliu d #@eval_numorvar6	[0a]
1a9e		slil d #@eval_numorvar6	[05]
1a9f		skipz	b
1aa0		jalr	d d
1aa1		pop	b
1aa2		sliu d #eval_numorvar_end	[0c]
1aa3		slil d #eval_numorvar_end	[0e]
1aa4		jalr	d d
1aa5	#@eval_numorvar6
1aa5		pop	b
1aa6		inc	c
1aa7		sliu d #eval_numorvar_end	[0c]
1aa8		slil d #eval_numorvar_end	[0e]
1aa9		jalr	d d
1aaa	#eval_numorvar_error	; calling global function mark_error

1aaa		push	d
1aab		push	c
1aac		push	b
1aad		sliu d 1
1aae		slil d 10
1aaf		push	d
1ab0		push	c
1ab1		sliu c 1
1ab2		slil c 12
1ab3		sliu d #mark_error	[00]
1ab4		slil d #mark_error	[00]
1ab5		jmpfar	d d
1ab6		pop	b
1ab7		pop	c
1ab8		pop	d
1ab9		sliu d #eval_numorvar_end	[0c]
1aba		slil d #eval_numorvar_end	[0e]
1abb		jalr	d d
1abc	#eval_numorvar_var	; calling global function eval_var

1abc		push	d
1abd		push	c
1abe		push	b
1abf		sliu d 1
1ac0		slil d 10
1ac1		push	d
1ac2		push	c
1ac3		sliu c 1
1ac4		slil c 11
1ac5		sliu d #eval_var	[08]
1ac6		slil d #eval_var	[02]
1ac7		jmpfar	d d
1ac8		pop	b
1ac9		pop	c
1aca		pop	d
1acb		sliu c 15
1acc		slil c 15
1acd		load	c [c]
1ace	#eval_numorvar_end
1ace		sliu d 15
1acf		slil d 15
1ad0		store	c [d]
1ad1		pop	d
1ad2		pop	c
1ad3		jmpfar	d d	
	; eval_numorvar ends
	
	

1ad4		org 1b00	
	; ------- GLOBAL FUNCTION print_integer -------

1b00	#print_integer
1b00		pop	c
1b01		push	d		; prints integer in A

1b02		sliu c 0
1b03		slil c 0
1b04		push	a
1b05		sliu b 6
1b06		slil b 4	; calling global function div

1b07		push	d
1b08		push	c
1b09		push	b
1b0a		sliu d 1
1b0b		slil d 11
1b0c		push	d
1b0d		push	c
1b0e		sliu c 0
1b0f		slil c 7
1b10		sliu d #div	[00]
1b11		slil d #div	[00]
1b12		jmpfar	d d
1b13		pop	b
1b14		pop	c
1b15		pop	d
1b16		push	a
1b17		sliu d 0
1b18		slil d 0
1b19		sub	a d
1b1a		sliu d #@print_integer0	[02]
1b1b		slil d #@print_integer0	[02]
1b1c		skipz	a
1b1d		jalr	d d
1b1e		pop	a
1b1f		sliu d #print_value_tens	[02]
1b20		slil d #print_value_tens	[09]
1b21		jalr	d d
1b22	#@print_integer0
1b22		pop	a
1b23		sliu b 3
1b24		slil b 0
1b25		add	a b
1b26		out	a
1b27		sliu c 0
1b28		slil c 1
1b29	#print_value_tens
1b29		pop	a
1b2a		push	a
1b2b		sliu b 0
1b2c		slil b 10	; calling global function div

1b2d		push	d
1b2e		push	c
1b2f		push	b
1b30		sliu d 1
1b31		slil d 11
1b32		push	d
1b33		push	c
1b34		sliu c 0
1b35		slil c 7
1b36		sliu d #div	[00]
1b37		slil d #div	[00]
1b38		jmpfar	d d
1b39		pop	b
1b3a		pop	c
1b3b		pop	d	; calling global function mod

1b3c		push	d
1b3d		push	c
1b3e		push	b
1b3f		sliu d 1
1b40		slil d 11
1b41		push	d
1b42		push	c
1b43		sliu c 0
1b44		slil c 7
1b45		sliu d #mod	[08]
1b46		slil d #mod	[05]
1b47		jmpfar	d d
1b48		pop	b
1b49		pop	c
1b4a		pop	d
1b4b		push	c
1b4c		sliu d 0
1b4d		slil d 1
1b4e		sub	c d
1b4f		sliu d #@print_integer1	[05]
1b50		slil d #@print_integer1	[07]
1b51		skipz	c
1b52		jalr	d d
1b53		pop	c
1b54		sliu d #print_value_tens_doprint	[06]
1b55		slil d #print_value_tens_doprint	[05]
1b56		jalr	d d
1b57	#@print_integer1
1b57		pop	c
1b58		push	a
1b59		sliu d 0
1b5a		slil d 0
1b5b		sub	a d
1b5c		sliu d #@print_integer2	[06]
1b5d		slil d #@print_integer2	[04]
1b5e		skipz	a
1b5f		jalr	d d
1b60		pop	a
1b61		sliu d #print_value_ones	[06]
1b62		slil d #print_value_ones	[09]
1b63		jalr	d d
1b64	#@print_integer2
1b64		pop	a
1b65	#print_value_tens_doprint
1b65		sliu b 3
1b66		slil b 0
1b67		add	a b
1b68		out	a
1b69	#print_value_ones
1b69		pop	a
1b6a		sliu b 0
1b6b		slil b 10	; calling global function mod

1b6c		push	d
1b6d		push	c
1b6e		push	b
1b6f		sliu d 1
1b70		slil d 11
1b71		push	d
1b72		push	c
1b73		sliu c 0
1b74		slil c 7
1b75		sliu d #mod	[08]
1b76		slil d #mod	[05]
1b77		jmpfar	d d
1b78		pop	b
1b79		pop	c
1b7a		pop	d
1b7b		sliu b 3
1b7c		slil b 0
1b7d		add	a b
1b7e		out	a
1b7f		pop	d
1b80		pop	c
1b81		jmpfar	d d	
	; print_integer ends
	
	
	
	; ------- GLOBAL FUNCTION eval_var -------

1b82	#eval_var
1b82		pop	c
1b83		push	d		;look up the variable

1b84		sub	b b
1b85		add	b c	; calling global function getvar

1b86		push	d
1b87		push	c
1b88		push	b
1b89		sliu d 1
1b8a		slil d 11
1b8b		push	d
1b8c		push	c
1b8d		sliu c 1
1b8e		slil c 13
1b8f		sliu d #getvar	[05]
1b90		slil d #getvar	[0d]
1b91		jmpfar	d d
1b92		pop	b
1b93		pop	c
1b94		pop	d
1b95		push	a		; advance to whitespace

1b96	#eval_var_loop
1b96		inc	c
1b97		load	a [c]
1b98		push	a
1b99		sliu d 2
1b9a		slil d 0
1b9b		sub	a d
1b9c		sliu d #@eval_var0	[0a]
1b9d		slil d #@eval_var0	[04]
1b9e		skipz	a
1b9f		jalr	d d
1ba0		pop	a
1ba1		sliu d #eval_var_loop_incdone	[0b]
1ba2		slil d #eval_var_loop_incdone	[05]
1ba3		jalr	d d
1ba4	#@eval_var0
1ba4		pop	a
1ba5		push	a
1ba6		sliu d 0
1ba7		slil d 0
1ba8		sub	a d
1ba9		sliu d #@eval_var1	[0b]
1baa		slil d #@eval_var1	[01]
1bab		skipz	a
1bac		jalr	d d
1bad		pop	a
1bae		sliu d #eval_var_loop_done	[0b]
1baf		slil d #eval_var_loop_done	[06]
1bb0		jalr	d d
1bb1	#@eval_var1
1bb1		pop	a
1bb2		sliu d #eval_var_loop	[09]
1bb3		slil d #eval_var_loop	[06]
1bb4		jalr	d d
1bb5	#eval_var_loop_incdone
1bb5		inc	c
1bb6	#eval_var_loop_done
1bb6		sliu d 15
1bb7		slil d 15
1bb8		store	c [d]
1bb9		pop	a
1bba		pop	d
1bbb		pop	c
1bbc		jmpfar	d d	
	; eval_var ends
	
	
	

1bbd		org 1c00	
	; ------- GLOBAL FUNCTION mark_error -------

1c00	#mark_error
1c00		pop	c
1c01		push	d		; function is called if a syntax error was detected

1c02		sliu b 2
1c03		slil b 1
1c04		out	b
1c05		pop	d
1c06		pop	c
1c07		jmpfar	d d	
	; mark_error ends
	
	
	; ------- GLOBAL FUNCTION error_marked -------

1c08	#error_marked
1c08		pop	c
1c09		push	d		; function returna A=1 if an error was previously detected

1c0a		sliu a 0
1c0b		slil a 0
1c0c		pop	d
1c0d		pop	c
1c0e		jmpfar	d d	
	; error_marked ends
	
	
	; ------- GLOBAL FUNCTION clear_error -------

1c0f	#clear_error
1c0f		pop	c
1c10		push	d		; function clears error codes

1c11		pop	d
1c12		pop	c
1c13		jmpfar	d d	
	; clear_error ends
	
	

1c14		org 1d00	
	; variable storage at page d0
	;	d000 holds addr of next empty var entry
	
	
	; ------- GLOBAL FUNCTION initvar -------

1d00	#initvar
1d00		pop	c
1d01		push	d
1d02		sliu d 13
1d03		slil d 0
1d04		page	d
1d05		sub	d d
1d06		sliu c 0
1d07		slil c 1
1d08		store	c [d]
1d09		store	d [c]
1d0a		pop	d
1d0b		pop	c
1d0c		jmpfar	d d	
	; initvar ends
	
	
	
	; ------- GLOBAL FUNCTION setvar -------

1d0d	#setvar
1d0d		pop	c
1d0e		push	d		; input: fd:B points to variable name, A holds value
		; if variable doesn't exist, make it
	

1d0f		sub	c c
1d10		add	c a	; calling global function lookupvar

1d11		push	d
1d12		push	c
1d13		push	b
1d14		sliu d 1
1d15		slil d 13
1d16		push	d
1d17		push	c
1d18		sliu c 1
1d19		slil c 13
1d1a		sliu d #lookupvar	[09]
1d1b		slil d #lookupvar	[07]
1d1c		jmpfar	d d
1d1d		pop	b
1d1e		pop	c
1d1f		pop	d
1d20		push	a
1d21		sliu d 0
1d22		slil d 0
1d23		sub	a d
1d24		sliu d #@setvar0	[02]
1d25		slil d #@setvar0	[0c]
1d26		skipnz	a
1d27		jalr	d d
1d28		pop	a
1d29		sliu d #setvar_set	[05]
1d2a		slil d #setvar_set	[03]
1d2b		jalr	d d
1d2c	#@setvar0
1d2c		pop	a
1d2d		push	c		; find place for new var

1d2e		sliu d 13
1d2f		slil d 0
1d30		page	d
1d31		sub	d d
1d32		load	c [d]		; advance past #

1d33		inc	b		; copy var name

1d34	#setvar_copyname
1d34		sliu d 15
1d35		slil d 13
1d36		page	d
1d37		load	a [b]
1d38		sliu d 13
1d39		slil d 0
1d3a		page	d
1d3b		store	a [c]
1d3c		inc	b
1d3d		inc	c
1d3e		push	a
1d3f		sliu d 2
1d40		slil d 0
1d41		sub	a d
1d42		sliu d #@setvar1	[04]
1d43		slil d #@setvar1	[0a]
1d44		skipnz	a
1d45		jalr	d d
1d46		pop	a
1d47		sliu d #setvar_copyname	[03]
1d48		slil d #setvar_copyname	[04]
1d49		jalr	d d
1d4a	#@setvar1
1d4a		pop	a		; set the value

1d4b		pop	a
1d4c		store	a [c]
1d4d		inc	c		; update the lastvar pointer

1d4e		sub	d d
1d4f		store	c [d]
1d50		sliu d #setvar_done	[05]
1d51		slil d #setvar_done	[07]
1d52		jalr	d d
1d53	#setvar_set
1d53		sliu d 13
1d54		slil d 0
1d55		page	d
1d56		store	c [a]
1d57	#setvar_done
1d57		sliu d 15
1d58		slil d 13
1d59		page	d
1d5a		pop	d
1d5b		pop	c
1d5c		jmpfar	d d	
	; setvar ends
	
	
	
	; ------- GLOBAL FUNCTION getvar -------

1d5d	#getvar
1d5d		pop	c
1d5e		push	d		; input: fd:B points to variable name
		; A returns value of variable.  error raised if no var
	; calling global function lookupvar

1d5f		push	d
1d60		push	c
1d61		push	b
1d62		sliu d 1
1d63		slil d 13
1d64		push	d
1d65		push	c
1d66		sliu c 1
1d67		slil c 13
1d68		sliu d #lookupvar	[09]
1d69		slil d #lookupvar	[07]
1d6a		jmpfar	d d
1d6b		pop	b
1d6c		pop	c
1d6d		pop	d
1d6e		push	a
1d6f		sliu d 0
1d70		slil d 0
1d71		sub	a d
1d72		sliu d #@getvar0	[07]
1d73		slil d #@getvar0	[0a]
1d74		skipz	a
1d75		jalr	d d
1d76		pop	a
1d77		sliu d #getvar_error	[08]
1d78		slil d #getvar_error	[02]
1d79		jalr	d d
1d7a	#@getvar0
1d7a		pop	a
1d7b		sliu d 13
1d7c		slil d 0
1d7d		page	d
1d7e		load	a [a]
1d7f		sliu d #getvar_done	[09]
1d80		slil d #getvar_done	[01]
1d81		jalr	d d	

1d82	#getvar_error	; calling global function mark_error

1d82		push	d
1d83		push	c
1d84		push	b
1d85		sliu d 1
1d86		slil d 13
1d87		push	d
1d88		push	c
1d89		sliu c 1
1d8a		slil c 12
1d8b		sliu d #mark_error	[00]
1d8c		slil d #mark_error	[00]
1d8d		jmpfar	d d
1d8e		pop	b
1d8f		pop	c
1d90		pop	d
1d91	#getvar_done
1d91		sliu d 15
1d92		slil d 13
1d93		page	d
1d94		pop	d
1d95		pop	c
1d96		jmpfar	d d	
	; getvar ends
	
	
	
	; ------- GLOBAL FUNCTION lookupvar -------

1d97	#lookupvar
1d97		pop	c
1d98		push	d		; input: fd:B points to variable name
		; A returns address of match, or 0 no match
	
		; move past #

1d99		inc	b		; push var name start

1d9a		push	b		
		;first variable here

1d9b		sliu c 0
1d9c		slil c 1	

1d9d	#lookup_var_loop		; check if any more variables

1d9d		sliu d 13
1d9e		slil d 0
1d9f		page	d
1da0		sliu d 0
1da1		slil d 0
1da2		load	d [d]
1da3		push	c
1da4		sub	c d
1da5		sliu d #@lookupvar0	[0a]
1da6		slil d #@lookupvar0	[0d]
1da7		skipge	c
1da8		jalr	d d
1da9		pop	c
1daa		sliu d #lookup_var_nomatches	[0f]
1dab		slil d #lookup_var_nomatches	[06]
1dac		jalr	d d
1dad	#@lookupvar0
1dad		pop	c	
		; reset test name

1dae		pop	b
1daf		push	b
1db0	#lookup_var_charloop		;get char from test

1db0		sliu d 15
1db1		slil d 13
1db2		page	d
1db3		load	a [b]		;get char from varlist

1db4		push	b
1db5		sliu d 13
1db6		slil d 0
1db7		page	d
1db8		load	b [c]
1db9		push	a
1dba		sub	a b
1dbb		sliu d #@lookupvar1	[0c]
1dbc		slil d #@lookupvar1	[03]
1dbd		skipnz	a
1dbe		jalr	d d
1dbf		pop	a
1dc0		sliu d #lookup_var_nomatch	[0d]
1dc1		slil d #lookup_var_nomatch	[0e]
1dc2		jalr	d d
1dc3	#@lookupvar1
1dc3		pop	a
1dc4		push	a
1dc5		sliu d 2
1dc6		slil d 0
1dc7		sub	a d
1dc8		sliu d #@lookupvar2	[0d]
1dc9		slil d #@lookupvar2	[00]
1dca		skipz	a
1dcb		jalr	d d
1dcc		pop	a
1dcd		sliu d #lookup_var_yesmatch	[0d]
1dce		slil d #lookup_var_yesmatch	[07]
1dcf		jalr	d d
1dd0	#@lookupvar2
1dd0		pop	a
1dd1		pop	b
1dd2		inc	b
1dd3		inc	c
1dd4		sliu d #lookup_var_charloop	[0b]
1dd5		slil d #lookup_var_charloop	[00]
1dd6		jalr	d d
1dd7	#lookup_var_yesmatch
1dd7		pop	b		; move pointer to value

1dd8		inc	c
1dd9		sub	a a
1dda		add	a c
1ddb		sliu d #lookup_var_done	[0f]
1ddc		slil d #lookup_var_done	[07]
1ddd		jalr	d d
1dde	#lookup_var_nomatch
1dde		pop	b		;advance to next variable

1ddf	#lookup_var_advanceloop
1ddf		load	a [c]
1de0		push	a
1de1		sliu d 2
1de2		slil d 0
1de3		sub	a d
1de4		sliu d #@lookupvar3	[0e]
1de5		slil d #@lookupvar3	[0c]
1de6		skipz	a
1de7		jalr	d d
1de8		pop	a
1de9		sliu d #lookup_var_advanceend	[0f]
1dea		slil d #lookup_var_advanceend	[01]
1deb		jalr	d d
1dec	#@lookupvar3
1dec		pop	a
1ded		inc	c
1dee		sliu d #lookup_var_advanceloop	[0d]
1def		slil d #lookup_var_advanceloop	[0f]
1df0		jalr	d d
1df1	#lookup_var_advanceend		; move to next var

1df1		inc	c
1df2		inc	c
1df3		sliu d #lookup_var_loop	[09]
1df4		slil d #lookup_var_loop	[0d]
1df5		jalr	d d	

1df6	#lookup_var_nomatches
1df6		sub	a a
1df7	#lookup_var_done
1df7		pop	b
1df8		sliu d 15
1df9		slil d 13
1dfa		page	d
1dfb		pop	d
1dfc		pop	c
1dfd		jmpfar	d d	
	; lookupvar ends
	
	

1dfe		org 1e00	
	; ------- GLOBAL FUNCTION doLET -------

1e00	#doLET
1e00		pop	c
1e01		push	d		; first thing should be a var name

1e02		sliu c 8
1e03		slil c 2
1e04		load	a [c]
1e05		push	a
1e06		sliu d 2
1e07		slil d 3
1e08		sub	a d
1e09		sliu d #@doLET0	[01]
1e0a		slil d #@doLET0	[01]
1e0b		skipnz	a
1e0c		jalr	d d
1e0d		pop	a
1e0e		sliu d #dolet_error	[08]
1e0f		slil d #dolet_error	[05]
1e10		jalr	d d
1e11	#@doLET0
1e11		pop	a		
		; advance past the variable name to the ' '

1e12	#doletadvance
1e12		inc	c
1e13		load	a [c]
1e14		push	a
1e15		sliu d 0
1e16		slil d 0
1e17		sub	a d
1e18		sliu d #@doLET1	[02]
1e19		slil d #@doLET1	[00]
1e1a		skipz	a
1e1b		jalr	d d
1e1c		pop	a
1e1d		sliu d #dolet_error	[08]
1e1e		slil d #dolet_error	[05]
1e1f		jalr	d d
1e20	#@doLET1
1e20		pop	a
1e21		push	a
1e22		sliu d 2
1e23		slil d 0
1e24		sub	a d
1e25		sliu d #@doLET2	[02]
1e26		slil d #@doLET2	[0d]
1e27		skipnz	a
1e28		jalr	d d
1e29		pop	a
1e2a		sliu d #doletadvance	[01]
1e2b		slil d #doletadvance	[02]
1e2c		jalr	d d
1e2d	#@doLET2
1e2d		pop	a	
		; next should be an =

1e2e		inc	c
1e2f		load	a [c]
1e30		push	a
1e31		sliu d 3
1e32		slil d 13
1e33		sub	a d
1e34		sliu d #@doLET3	[03]
1e35		slil d #@doLET3	[0c]
1e36		skipnz	a
1e37		jalr	d d
1e38		pop	a
1e39		sliu d #dolet_error	[08]
1e3a		slil d #dolet_error	[05]
1e3b		jalr	d d
1e3c	#@doLET3
1e3c		pop	a	
		; advance to expression

1e3d		inc	c
1e3e		load	a [c]
1e3f		push	a
1e40		sliu d 0
1e41		slil d 0
1e42		sub	a d
1e43		sliu d #@doLET4	[04]
1e44		slil d #@doLET4	[0b]
1e45		skipz	a
1e46		jalr	d d
1e47		pop	a
1e48		sliu d #dolet_error	[08]
1e49		slil d #dolet_error	[05]
1e4a		jalr	d d
1e4b	#@doLET4
1e4b		pop	a
1e4c		inc	c	
	; calling global function eval_expression

1e4d		push	d
1e4e		push	c
1e4f		push	b
1e50		sliu d 1
1e51		slil d 14
1e52		push	d
1e53		push	c
1e54		sliu c 1
1e55		slil c 7
1e56		sliu d #eval_expression	[00]
1e57		slil d #eval_expression	[00]
1e58		jmpfar	d d
1e59		pop	b
1e5a		pop	c
1e5b		pop	d		; stop if an error

1e5c		push	a	; calling global function error_marked

1e5d		push	d
1e5e		push	c
1e5f		push	b
1e60		sliu d 1
1e61		slil d 14
1e62		push	d
1e63		push	c
1e64		sliu c 1
1e65		slil c 12
1e66		sliu d #error_marked	[00]
1e67		slil d #error_marked	[08]
1e68		jmpfar	d d
1e69		pop	b
1e6a		pop	c
1e6b		pop	d
1e6c		sliu d #dolet_done	[09]
1e6d		slil d #dolet_done	[04]
1e6e		skipz	a
1e6f		jalr	d d
1e70		pop	a	
		; assign the variable

1e71		sliu b 8
1e72		slil b 2	; calling global function setvar

1e73		push	d
1e74		push	c
1e75		push	b
1e76		sliu d 1
1e77		slil d 14
1e78		push	d
1e79		push	c
1e7a		sliu c 1
1e7b		slil c 13
1e7c		sliu d #setvar	[00]
1e7d		slil d #setvar	[0d]
1e7e		jmpfar	d d
1e7f		pop	b
1e80		pop	c
1e81		pop	d
1e82		sliu d #dolet_done	[09]
1e83		slil d #dolet_done	[04]
1e84		jalr	d d		

1e85	#dolet_error	; calling global function mark_error

1e85		push	d
1e86		push	c
1e87		push	b
1e88		sliu d 1
1e89		slil d 14
1e8a		push	d
1e8b		push	c
1e8c		sliu c 1
1e8d		slil c 12
1e8e		sliu d #mark_error	[00]
1e8f		slil d #mark_error	[00]
1e90		jmpfar	d d
1e91		pop	b
1e92		pop	c
1e93		pop	d
1e94	#dolet_done
1e94		pop	d
1e95		pop	c
1e96		jmpfar	d d	
	; doLET ends
	
	
	
	; ------- GLOBAL FUNCTION doLIST -------

1e97	#doLIST
1e97		pop	c
1e98		push	d
1e99		sliu c 9
1e9a		slil c 0
1e9b		sliu b 0
1e9c		slil b 0
1e9d	#doLIST_loop
1e9d		page	c
1e9e		load	a [b]
1e9f		sliu d #doLIST_skipline	[0b]
1ea0		slil d #doLIST_skipline	[0a]
1ea1		skipnz	a
1ea2		jalr	d d
1ea3		sliu a 0
1ea4		slil a 13
1ea5		out	a
1ea6		sliu a 2
1ea7		slil a 0
1ea8		out	a
1ea9		sub	a a
1eaa		add	a c	; calling global function printstring

1eab		push	d
1eac		push	c
1ead		push	b
1eae		sliu d 1
1eaf		slil d 14
1eb0		push	d
1eb1		push	c
1eb2		sliu c 0
1eb3		slil c 5
1eb4		sliu d #printstring	[00]
1eb5		slil d #printstring	[00]
1eb6		jmpfar	d d
1eb7		pop	b
1eb8		pop	c
1eb9		pop	d
1eba	#doLIST_skipline
1eba		sliu d 2
1ebb		slil d 0
1ebc		add	b d
1ebd		sliu d #doLIST_loop	[09]
1ebe		slil d #doLIST_loop	[0d]
1ebf		skipz	b
1ec0		jalr	d d
1ec1		inc	c
1ec2		push	c
1ec3		sliu d 11
1ec4		slil d 0
1ec5		sub	c d
1ec6		sliu d #@doLIST0	[0c]
1ec7		slil d #@doLIST0	[0e]
1ec8		skipnz	c
1ec9		jalr	d d
1eca		pop	c
1ecb		sliu d #doLIST_loop	[09]
1ecc		slil d #doLIST_loop	[0d]
1ecd		jalr	d d
1ece	#@doLIST0
1ece		pop	c
1ecf		pop	d
1ed0		pop	c
1ed1		jmpfar	d d	
	; doLIST ends
	
	
	
	; ------- GLOBAL FUNCTION doCLS -------

1ed2	#doCLS
1ed2		pop	c
1ed3		push	d
1ed4		sliu d 0
1ed5		slil d 1
1ed6		out	d
1ed7		sliu d 8
1ed8		slil d 0
1ed9		out	d
1eda		sliu d 15
1edb		slil d 15
1edc		sliu d #docls_delay	[0e]
1edd		slil d #docls_delay	[00]
1ede		sliu c 15
1edf		slil c 15
1ee0	#docls_delay
1ee0		dec	c
1ee1		skipz	c
1ee2		jalr	d d
1ee3		sliu d 2
1ee4		slil d 0
1ee5		out	d
1ee6		pop	d
1ee7		pop	c
1ee8		jmpfar	d d	
	; doCLS ends
	
	

1ee9		org 7e00
7e00	#keychars
7e00		db	0x3d
7e01		db	0
7e02		db	0x3d
7e03		db	0
7e04		db	0x3c
7e05		db	0
7e06		db	0x3c
7e07		db	0
7e08		db	0x3e
7e09		db	0
7e0a		db	0x3e
7e0b		db	0
7e0c		db	0x2b
7e0d		db	0
7e0e		db	0x2b
7e0f		db	0
7e10		db	0x2d
7e11		db	0
7e12		db	0x2d
7e13		db	0
7e14		db	0x2a
7e15		db	0
7e16		db	0x2a
7e17		db	0
7e18		db	0x2f
7e19		db	0
7e1a		db	0x2f
7e1b		db	0
7e1c		db	0x28
7e1d		db	0
7e1e		db	0x28
7e1f		db	0
7e20		db	0x29
7e21		db	0
7e22		db	0x29
7e23		db	0
7e24		db	0x2c
7e25		db	0
7e26		db	0x2c
7e27		db	0		; ; char

7e28		db	0x3b
7e29		db	0
7e2a			db	0x3b
7e2b			db	0
7e2c		db	0
7e2d	#keywords
7e2d		db	0x50
7e2e		db	0x52
7e2f		db	0x49
7e30		db	0x4e
7e31		db	0x54
7e32		db	0
7e33		db	0x50
7e34		db	0
7e35		db	0x49
7e36		db	0x46
7e37		db	0
7e38		db	0x49
7e39		db	0
7e3a		db	0x54
7e3b		db	0x48
7e3c		db	0x45
7e3d		db	0x4e
7e3e		db	0
7e3f		db	0x54
7e40		db	0
7e41		db	0x47
7e42		db	0x4f
7e43		db	0x54
7e44		db	0x4f
7e45		db	0
7e46		db	0x47
7e47		db	0
7e48		db	0x49
7e49		db	0x4e
7e4a		db	0x50
7e4b		db	0x55
7e4c		db	0x54
7e4d		db	0
7e4e		db	0x69
7e4f		db	0
7e50		db	0x4c
7e51		db	0x45
7e52		db	0x54
7e53		db	0
7e54		db	0x4c
7e55		db	0
7e56		db	0x47
7e57		db	0x4f
7e58		db	0x53
7e59		db	0x55
7e5a		db	0x42
7e5b		db	0
7e5c		db	0x53
7e5d		db	0
7e5e		db	0x52
7e5f		db	0x45
7e60		db	0x54
7e61		db	0x55
7e62		db	0x52
7e63		db	0x4e
7e64		db	0
7e65		db	0x52
7e66		db	0
7e67		db	0x4c
7e68		db	0x49
7e69		db	0x53
7e6a		db	0x54
7e6b		db	0
7e6c		db	0x73
7e6d		db	0
7e6e		db	0x52
7e6f		db	0x55
7e70		db	0x4e
7e71		db	0
7e72		db	0x72
7e73		db	0
7e74		db	0x45
7e75		db	0x4e
7e76		db	0x44
7e77		db	0
7e78		db	0x45
7e79		db	0
7e7a		db	0x46
7e7b		db	0x4f
7e7c		db	0x52
7e7d		db	0
7e7e		db	0x46
7e7f		db	0
7e80		db	0x54
7e81		db	0x4f
7e82		db	0
7e83		db	0x74
7e84		db	0
7e85		db	0x4e
7e86		db	0x45
7e87		db	0x58
7e88		db	0x54
7e89		db	0
7e8a		db	0x58
7e8b		db	0
7e8c		db	0x53
7e8d		db	0x54
7e8e		db	0x45
7e8f		db	0x50
7e90		db	0
7e91		db	0x70
7e92		db	0
7e93		db	0x44
7e94		db	0x49
7e95		db	0x4d
7e96		db	0
7e97		db	0x44
7e98		db	0
7e99		db	0x52
7e9a		db	0x4e
7e9b		db	0x44
7e9c		db	0
7e9d		db	0x6e
7e9e		db	0
7e9f		db	0x43
7ea0		db	0x4c
7ea1		db	0x53
7ea2		db	0
7ea3		db	0x63
7ea4		db	0
7ea5		db	0x4c
7ea6		db	0x4f
7ea7		db	0x41
7ea8		db	0x44
7ea9		db	0
7eaa		db	0x64
7eab		db	0
7eac		db	0x4d
7ead		db	0x4f
7eae		db	0x44
7eaf		db	0
7eb0		db	0x25
7eb1		db	0
7eb2		db	0x43
7eb3		db	0x4c
7eb4		db	0x45
7eb5		db	0x41
7eb6		db	0x52
7eb7		db	0
7eb8		db	0x65
7eb9		db	0
7eba		db	0x4e
7ebb		db	0x45
7ebc		db	0x57
7ebd		db	0
7ebe		db	0x57
7ebf		db	0
7ec0		db	0x3c
7ec1		db	0x3e
7ec2		db	0
7ec3		db	0x21
7ec4		db	0
7ec5		db	0x3c
7ec6		db	0x3d
7ec7		db	0
7ec8		db	0x6c
7ec9		db	0
7eca		db	0x3e
7ecb		db	0x3d
7ecc		db	0
7ecd		db	0x67
7ece		db	0
7ecf		db	0	

7ed0		org 7f00
7f00	#monitor_message
7f00		db	0x52
7f01		db	0x49
7f02		db	0x53
7f03		db	0x43
7f04		db	0x59
7f05		db	0x20
7f06		db	0x4d
7f07		db	0x4f
7f08		db	0x4e
7f09		db	0x49
7f0a		db	0x54
7f0b		db	0x4f
7f0c		db	0x52
7f0d		db	0
7f0e	#basic_message
7f0e		db	0x54
7f0f		db	0x49
7f10		db	0x4e
7f11		db	0x59
7f12		db	0x20
7f13		db	0x42
7f14		db	0x41
7f15		db	0x53
7f16		db	0x49
7f17		db	0x43
7f18		db	0
7f19	#basic_prompt
7f19		db	0x4f
7f1a		db	0x4b
7f1b		db	0
7f1c	#newline
7f1c		db	0x0d
7f1d		db	0x20
7f1e		db	0x00
7f1f	#lexical_error
7f1f		db	0x43
7f20		db	0x41
7f21		db	0x4e
7f22		db	0x4e
7f23		db	0x4f
7f24		db	0x54
7f25		db	0x20
7f26		db	0x50
7f27		db	0x41
7f28		db	0x52
7f29		db	0x53
7f2a		db	0x45
7f2b		db	0x20
7f2c		db	0x4c
7f2d		db	0x49
7f2e		db	0x4e
7f2f		db	0x45
7f30		db	0
7f31	#syntax_error
7f31		db	0x53
7f32		db	0x59
7f33		db	0x4e
7f34		db	0x54
7f35		db	0x41
7f36		db	0x58
7f37		db	0x20
7f38		db	0x45
7f39		db	0x52
7f3a		db	0x52
7f3b		db	0x4f
7f3c		db	0x52
7f3d		db	0
