
0000		org	0
0000		sliu d 15
0001		slil d 15
0002		stackpage	d	
	; calling global function setupdisplay

0003		push	d
0004		push	c
0005		push	b
0006		sliu d 0
0007		slil d 0
0008		push	d
0009		push	c
000a		sliu c 0
000b		slil c 1
000c		sliu d #setupdisplay	[00]
000d		slil d #setupdisplay	[00]
000e		jmpfar	d d
000f		pop	b
0010		pop	c
0011		pop	d	; calling global function monitor_entry

0012		push	d
0013		push	c
0014		push	b
0015		sliu d 0
0016		slil d 0
0017		push	d
0018		push	c
0019		sliu c 0
001a		slil c 2
001b		sliu d #monitor_entry	[00]
001c		slil d #monitor_entry	[00]
001d		jmpfar	d d
001e		pop	b
001f		pop	c
0020		pop	d	

0021		halt	

0022		org	100	
	; ------- GLOBAL FUNCTION setupdisplay -------

0100	#setupdisplay
0100		pop	c
0101		push	d
0102		sliu d 0
0103		slil d 1
0104		out	d
0105		sliu d 8
0106		slil d 0
0107		out	d	;	li	d,0x02
	;	out	d
	;	li	d,0x02
	;	out	d
	;	li	d,0x0c
	;	out	d
	;	li	d,0x00
	;	out	d
	;	li	d,0x0f
	;	out	d
	;	li	d,0x00
	;	out	d
	;	li	d,0x01
	;	out	d

0108		pop	d
0109		pop	c
010a		jmpfar	d d	
	; setupdisplay ends
	
	

010b		org	200	
	; ------- GLOBAL FUNCTION monitor_entry -------

0200	#monitor_entry
0200		pop	c
0201		push	d		; print out "RISCY Monitor"

0202		sliu a 7
0203		slil a 15
0204		sliu b #monitor_message	[00]
0205		slil b #monitor_message	[00]	; calling global function printstring

0206		push	d
0207		push	c
0208		push	b
0209		sliu d 0
020a		slil d 2
020b		push	d
020c		push	c
020d		sliu c 0
020e		slil c 5
020f		sliu d #printstring	[00]
0210		slil d #printstring	[00]
0211		jmpfar	d d
0212		pop	b
0213		pop	c
0214		pop	d
0215	#monitor	; calling global function readprompt

0215		push	d
0216		push	c
0217		push	b
0218		sliu d 0
0219		slil d 2
021a		push	d
021b		push	c
021c		sliu c 0
021d		slil c 8
021e		sliu d #readprompt	[02]
021f		slil d #readprompt	[02]
0220		jmpfar	d d
0221		pop	b
0222		pop	c
0223		pop	d		; read a line into 0xfd:0

0224		sliu a 15
0225		slil a 13
0226		sliu b 0
0227		slil b 0	; calling global function readstring

0228		push	d
0229		push	c
022a		push	b
022b		sliu d 0
022c		slil d 2
022d		push	d
022e		push	c
022f		sliu c 0
0230		slil c 6
0231		sliu d #readstring	[01]
0232		slil d #readstring	[03]
0233		jmpfar	d d
0234		pop	b
0235		pop	c
0236		pop	d	
	;	.call clearscreen
		;get command

0237		sliu a 15
0238		slil a 13
0239		page	a
023a		sliu b 0
023b		slil b 0
023c		load	a [b]	
		;check command

023d		push	a
023e		sliu d 4
023f		slil d 4
0240		sub	a d
0241		sliu d #@monitor_entry0	[04]
0242		slil d #@monitor_entry0	[09]
0243		skipz	a
0244		jalr	d d
0245		pop	a
0246		sliu d #domonitordump	[07]
0247		slil d #domonitordump	[04]
0248		jalr	d d
0249	#@monitor_entry0
0249		pop	a
024a		push	a
024b		sliu d 4
024c		slil d 5
024d		sub	a d
024e		sliu d #@monitor_entry1	[05]
024f		slil d #@monitor_entry1	[06]
0250		skipz	a
0251		jalr	d d
0252		pop	a
0253		sliu d #domonitoredit	[08]
0254		slil d #domonitoredit	[06]
0255		jalr	d d
0256	#@monitor_entry1
0256		pop	a
0257		push	a
0258		sliu d 4
0259		slil d 7
025a		sub	a d
025b		sliu d #@monitor_entry2	[06]
025c		slil d #@monitor_entry2	[03]
025d		skipz	a
025e		jalr	d d
025f		pop	a
0260		sliu d #domonitorgo	[0a]
0261		slil d #domonitorgo	[0a]
0262		jalr	d d
0263	#@monitor_entry2
0263		pop	a
0264		push	a
0265		sliu d 4
0266		slil d 2
0267		sub	a d
0268		sliu d #@monitor_entry3	[07]
0269		slil d #@monitor_entry3	[00]
026a		skipz	a
026b		jalr	d d
026c		pop	a
026d		sliu d #domonitorbasic	[09]
026e		slil d #domonitorbasic	[08]
026f		jalr	d d
0270	#@monitor_entry3
0270		pop	a	

0271		sliu d #monitor	[01]
0272		slil d #monitor	[05]
0273		jalr	d d	

0274	#domonitordump	; calling global function monitordump

0274		push	d
0275		push	c
0276		push	b
0277		sliu d 0
0278		slil d 2
0279		push	d
027a		push	c
027b		sliu c 0
027c		slil c 3
027d		sliu d #monitordump	[00]
027e		slil d #monitordump	[00]
027f		jmpfar	d d
0280		pop	b
0281		pop	c
0282		pop	d
0283		sliu d #monitor	[01]
0284		slil d #monitor	[05]
0285		jalr	d d
0286	#domonitoredit	; calling global function monitoredit

0286		push	d
0287		push	c
0288		push	b
0289		sliu d 0
028a		slil d 2
028b		push	d
028c		push	c
028d		sliu c 0
028e		slil c 3
028f		sliu d #monitoredit	[09]
0290		slil d #monitoredit	[0c]
0291		jmpfar	d d
0292		pop	b
0293		pop	c
0294		pop	d
0295		sliu d #monitor	[01]
0296		slil d #monitor	[05]
0297		jalr	d d
0298	#domonitorbasic	; calling global function basic

0298		push	d
0299		push	c
029a		push	b
029b		sliu d 0
029c		slil d 2
029d		push	d
029e		push	c
029f		sliu c 1
02a0		slil c 2
02a1		sliu d #basic	[00]
02a2		slil d #basic	[00]
02a3		jmpfar	d d
02a4		pop	b
02a5		pop	c
02a6		pop	d
02a7		sliu d #monitor	[01]
02a8		slil d #monitor	[05]
02a9		jalr	d d
02aa	#domonitorgo
02aa		sliu b 0
02ab		slil b 2
02ac		load	a [b]
02ad		inc	b
02ae		load	b [b]	; calling global function hextobin

02af		push	d
02b0		push	c
02b1		push	b
02b2		sliu d 0
02b3		slil d 2
02b4		push	d
02b5		push	c
02b6		sliu c 0
02b7		slil c 4
02b8		sliu d #hextobin	[08]
02b9		slil d #hextobin	[0f]
02ba		jmpfar	d d
02bb		pop	b
02bc		pop	c
02bd		pop	d
02be		pop	b
02bf		push	a
02c0		sliu d 0
02c1		slil d 4
02c2		add	b d
02c3		load	a [b]
02c4		inc	b
02c5		load	b [b]	; calling global function hextobin

02c6		push	d
02c7		push	c
02c8		push	b
02c9		sliu d 0
02ca		slil d 2
02cb		push	d
02cc		push	c
02cd		sliu c 0
02ce		slil c 4
02cf		sliu d #hextobin	[08]
02d0		slil d #hextobin	[0f]
02d1		jmpfar	d d
02d2		pop	b
02d3		pop	c
02d4		pop	d
02d5		pop	c
02d6		jmpfar	a a	

02d7		pop	d
02d8		pop	c
02d9		jmpfar	d d	
	; monitor_entry ends
	
	

02da		org 300	
	; ------- GLOBAL FUNCTION monitordump -------

0300	#monitordump
0300		pop	c
0301		push	d	; calling global function monitor_printaddress

0302		push	d
0303		push	c
0304		push	b
0305		sliu d 0
0306		slil d 3
0307		push	d
0308		push	c
0309		sliu c 0
030a		slil c 4
030b		sliu d #monitor_printaddress	[00]
030c		slil d #monitor_printaddress	[00]
030d		jmpfar	d d
030e		pop	b
030f		pop	c
0310		pop	d
0311		sub	b b	; calling global function monitor_getaddress

0312		push	d
0313		push	c
0314		push	b
0315		sliu d 0
0316		slil d 3
0317		push	d
0318		push	c
0319		sliu c 0
031a		slil c 4
031b		sliu d #monitor_getaddress	[05]
031c		slil d #monitor_getaddress	[0c]
031d		jmpfar	d d
031e		pop	b
031f		pop	c
0320		pop	d
0321		sub	b b
0322		add	b a
0323		load	a [b]	; calling global function printhex

0324		push	d
0325		push	c
0326		push	b
0327		sliu d 0
0328		slil d 3
0329		push	d
032a		push	c
032b		sliu c 0
032c		slil c 5
032d		sliu d #printhex	[01]
032e		slil d #printhex	[0f]
032f		jmpfar	d d
0330		pop	b
0331		pop	c
0332		pop	d
0333		sliu a 2
0334		slil a 0	; calling global function printchar

0335		push	d
0336		push	c
0337		push	b
0338		sliu d 0
0339		slil d 3
033a		push	d
033b		push	c
033c		sliu c 0
033d		slil c 5
033e		sliu d #printchar	[01]
033f		slil d #printchar	[09]
0340		jmpfar	d d
0341		pop	b
0342		pop	c
0343		pop	d
0344		inc	b
0345		load	a [b]	; calling global function printhex

0346		push	d
0347		push	c
0348		push	b
0349		sliu d 0
034a		slil d 3
034b		push	d
034c		push	c
034d		sliu c 0
034e		slil c 5
034f		sliu d #printhex	[01]
0350		slil d #printhex	[0f]
0351		jmpfar	d d
0352		pop	b
0353		pop	c
0354		pop	d
0355		sliu a 2
0356		slil a 0	; calling global function printchar

0357		push	d
0358		push	c
0359		push	b
035a		sliu d 0
035b		slil d 3
035c		push	d
035d		push	c
035e		sliu c 0
035f		slil c 5
0360		sliu d #printchar	[01]
0361		slil d #printchar	[09]
0362		jmpfar	d d
0363		pop	b
0364		pop	c
0365		pop	d
0366		inc	b
0367		load	a [b]	; calling global function printhex

0368		push	d
0369		push	c
036a		push	b
036b		sliu d 0
036c		slil d 3
036d		push	d
036e		push	c
036f		sliu c 0
0370		slil c 5
0371		sliu d #printhex	[01]
0372		slil d #printhex	[0f]
0373		jmpfar	d d
0374		pop	b
0375		pop	c
0376		pop	d
0377		sliu a 2
0378		slil a 0	; calling global function printchar

0379		push	d
037a		push	c
037b		push	b
037c		sliu d 0
037d		slil d 3
037e		push	d
037f		push	c
0380		sliu c 0
0381		slil c 5
0382		sliu d #printchar	[01]
0383		slil d #printchar	[09]
0384		jmpfar	d d
0385		pop	b
0386		pop	c
0387		pop	d
0388		inc	b
0389		load	a [b]	; calling global function printhex

038a		push	d
038b		push	c
038c		push	b
038d		sliu d 0
038e		slil d 3
038f		push	d
0390		push	c
0391		sliu c 0
0392		slil c 5
0393		sliu d #printhex	[01]
0394		slil d #printhex	[0f]
0395		jmpfar	d d
0396		pop	b
0397		pop	c
0398		pop	d
0399		pop	d
039a		pop	c
039b		jmpfar	d d	
	; monitordump ends
	
	
	
	; ------- GLOBAL FUNCTION monitoredit -------

039c	#monitoredit
039c		pop	c
039d		push	d		; get value byte

039e		sliu b 0
039f		slil b 7
03a0		load	a [b]
03a1		inc	b
03a2		load	b [b]	; calling global function hextobin

03a3		push	d
03a4		push	c
03a5		push	b
03a6		sliu d 0
03a7		slil d 3
03a8		push	d
03a9		push	c
03aa		sliu c 0
03ab		slil c 4
03ac		sliu d #hextobin	[08]
03ad		slil d #hextobin	[0f]
03ae		jmpfar	d d
03af		pop	b
03b0		pop	c
03b1		pop	d
03b2		push	a
03b3		sub	b b	; calling global function monitor_getaddress

03b4		push	d
03b5		push	c
03b6		push	b
03b7		sliu d 0
03b8		slil d 3
03b9		push	d
03ba		push	c
03bb		sliu c 0
03bc		slil c 4
03bd		sliu d #monitor_getaddress	[05]
03be		slil d #monitor_getaddress	[0c]
03bf		jmpfar	d d
03c0		pop	b
03c1		pop	c
03c2		pop	d
03c3		pop	b
03c4		store	b [a]
03c5		pop	d
03c6		pop	c
03c7		jmpfar	d d	
	; monitoredit ends
	
	

03c8		org 400	
	; ------- GLOBAL FUNCTION monitor_printaddress -------

0400	#monitor_printaddress
0400		pop	c
0401		push	d
0402		sliu b 0
0403		slil b 2
0404		load	a [b]	; calling global function printchar

0405		push	d
0406		push	c
0407		push	b
0408		sliu d 0
0409		slil d 4
040a		push	d
040b		push	c
040c		sliu c 0
040d		slil c 5
040e		sliu d #printchar	[01]
040f		slil d #printchar	[09]
0410		jmpfar	d d
0411		pop	b
0412		pop	c
0413		pop	d
0414		inc	b
0415		load	a [b]	; calling global function printchar

0416		push	d
0417		push	c
0418		push	b
0419		sliu d 0
041a		slil d 4
041b		push	d
041c		push	c
041d		sliu c 0
041e		slil c 5
041f		sliu d #printchar	[01]
0420		slil d #printchar	[09]
0421		jmpfar	d d
0422		pop	b
0423		pop	c
0424		pop	d
0425		inc	b
0426		load	a [b]	; calling global function printchar

0427		push	d
0428		push	c
0429		push	b
042a		sliu d 0
042b		slil d 4
042c		push	d
042d		push	c
042e		sliu c 0
042f		slil c 5
0430		sliu d #printchar	[01]
0431		slil d #printchar	[09]
0432		jmpfar	d d
0433		pop	b
0434		pop	c
0435		pop	d
0436		inc	b
0437		load	a [b]	; calling global function printchar

0438		push	d
0439		push	c
043a		push	b
043b		sliu d 0
043c		slil d 4
043d		push	d
043e		push	c
043f		sliu c 0
0440		slil c 5
0441		sliu d #printchar	[01]
0442		slil d #printchar	[09]
0443		jmpfar	d d
0444		pop	b
0445		pop	c
0446		pop	d
0447		inc	b
0448		sliu a 2
0449		slil a 0	; calling global function printchar

044a		push	d
044b		push	c
044c		push	b
044d		sliu d 0
044e		slil d 4
044f		push	d
0450		push	c
0451		sliu c 0
0452		slil c 5
0453		sliu d #printchar	[01]
0454		slil d #printchar	[09]
0455		jmpfar	d d
0456		pop	b
0457		pop	c
0458		pop	d
0459		pop	d
045a		pop	c
045b		jmpfar	d d	
	; monitor_printaddress ends
	
	
	
	; ------- GLOBAL FUNCTION monitor_getaddress -------

045c	#monitor_getaddress
045c		pop	c
045d		push	d		; sets the data page to the page entered, returns the address in A

045e		push	b
045f		sliu b 0
0460		slil b 2
0461		load	a [b]
0462		inc	b
0463		load	b [b]	; calling global function hextobin

0464		push	d
0465		push	c
0466		push	b
0467		sliu d 0
0468		slil d 4
0469		push	d
046a		push	c
046b		sliu c 0
046c		slil c 4
046d		sliu d #hextobin	[08]
046e		slil d #hextobin	[0f]
046f		jmpfar	d d
0470		pop	b
0471		pop	c
0472		pop	d
0473		pop	b
0474		push	a
0475		sliu d 0
0476		slil d 4
0477		add	b d
0478		load	a [b]
0479		inc	b
047a		load	b [b]	; calling global function hextobin

047b		push	d
047c		push	c
047d		push	b
047e		sliu d 0
047f		slil d 4
0480		push	d
0481		push	c
0482		sliu c 0
0483		slil c 4
0484		sliu d #hextobin	[08]
0485		slil d #hextobin	[0f]
0486		jmpfar	d d
0487		pop	b
0488		pop	c
0489		pop	d
048a		pop	b
048b		page	b
048c		pop	d
048d		pop	c
048e		jmpfar	d d	
	; monitor_getaddress ends
	
	
	
	; ------- GLOBAL FUNCTION hextobin -------

048f	#hextobin
048f		pop	c
0490		push	d		; A,B are two chars.  returns num in A

0491		push	a
0492		sliu d 3
0493		slil d 10
0494		sub	a d
0495		sliu d #@hextobin0	[09]
0496		slil d #@hextobin0	[0d]
0497		skipge	a
0498		jalr	d d
0499		pop	a
049a		sliu d #hextobin_letter1	[0a]
049b		slil d #hextobin_letter1	[01]
049c		jalr	d d
049d	#@hextobin0
049d		pop	a
049e		sliu d #hextobin_number1	[0a]
049f		slil d #hextobin_number1	[0a]
04a0		jalr	d d
04a1	#hextobin_letter1
04a1		sliu d 4
04a2		slil d 1
04a3		sub	a d
04a4		sliu d 0
04a5		slil d 10
04a6		add	a d
04a7		sliu d #hextobin2	[0a]
04a8		slil d #hextobin2	[0d]
04a9		jalr	d d
04aa	#hextobin_number1
04aa		sliu d 3
04ab		slil d 0
04ac		sub	a d
04ad	#hextobin2
04ad		add	a a
04ae		add	a a
04af		add	a a
04b0		add	a a
04b1		push	b
04b2		sliu d 3
04b3		slil d 10
04b4		sub	b d
04b5		sliu d #@hextobin1	[0b]
04b6		slil d #@hextobin1	[0d]
04b7		skipge	b
04b8		jalr	d d
04b9		pop	b
04ba		sliu d #hextobin_letter2	[0c]
04bb		slil d #hextobin_letter2	[01]
04bc		jalr	d d
04bd	#@hextobin1
04bd		pop	b
04be		sliu d #hextobin_number2	[0c]
04bf		slil d #hextobin_number2	[0a]
04c0		jalr	d d
04c1	#hextobin_letter2
04c1		sliu d 4
04c2		slil d 1
04c3		sub	b d
04c4		sliu d 0
04c5		slil d 10
04c6		add	b d
04c7		sliu d #hextobin3	[0c]
04c8		slil d #hextobin3	[0d]
04c9		jalr	d d
04ca	#hextobin_number2
04ca		sliu d 3
04cb		slil d 0
04cc		sub	b d
04cd	#hextobin3
04cd		add	a b
04ce		pop	d
04cf		pop	c
04d0		jmpfar	d d	
	; hextobin ends
	
	

04d1		org 500	
	; ------- GLOBAL FUNCTION printstring -------

0500	#printstring
0500		pop	c
0501		push	d		; page in A, string addr in B

0502		page	a
0503	#printstring_loop
0503		load	a [b]
0504		push	a
0505		sliu d 0
0506		slil d 0
0507		sub	a d
0508		sliu d #@printstring0	[01]
0509		slil d #@printstring0	[00]
050a		skipz	a
050b		jalr	d d
050c		pop	a
050d		sliu d #printstring_done	[01]
050e		slil d #printstring_done	[06]
050f		jalr	d d
0510	#@printstring0
0510		pop	a	
	;	.call printchar

0511		out	a	

0512		inc	b
0513		sliu d #printstring_loop	[00]
0514		slil d #printstring_loop	[03]
0515		jalr	d d
0516	#printstring_done
0516		pop	d
0517		pop	c
0518		jmpfar	d d	
	; printstring ends
	
	
	
	; ------- GLOBAL FUNCTION printchar -------

0519	#printchar
0519		pop	c
051a		push	d	;	 prints char in A

051b		out	a	
	;	push	a
	;	push	a
	;	li	d,0xf0
	;	nand	a,d
	;	nand	a,a
	;	li	b,0x10
	;	.call div_even
	;	li	c,0x7f
	;	nand	a,c
	;	nand	a,c
	;	out	a
	;	pop	a
	;	li	d,0x0f
	;	nand	a,d
	;	nand	a,a
	;	li	d,0x7f
	;	nand	a,d
	;	nand	a,d
	;	out	a
	;	pop	a

051c		pop	d
051d		pop	c
051e		jmpfar	d d	
	; printchar ends
	
	
	
	; ------- GLOBAL FUNCTION printhex -------

051f	#printhex
051f		pop	c
0520		push	d		; prints a byte in A as two hex chars

0521		push	a
0522		push	a
0523		sliu d 15
0524		slil d 0
0525		nand	a d
0526		nand	a a
0527		sliu b 1
0528		slil b 0	; calling global function div_even

0529		push	d
052a		push	c
052b		push	b
052c		sliu d 0
052d		slil d 5
052e		push	d
052f		push	c
0530		sliu c 0
0531		slil c 7
0532		sliu d #div_even	[06]
0533		slil d #div_even	[0a]
0534		jmpfar	d d
0535		pop	b
0536		pop	c
0537		pop	d
0538		push	a
0539		sliu d 0
053a		slil d 10
053b		sub	a d
053c		sliu d #@printhex0	[04]
053d		slil d #@printhex0	[04]
053e		skipl	a
053f		jalr	d d
0540		pop	a
0541		sliu d #printhex_num1	[04]
0542		slil d #printhex_num1	[0e]
0543		jalr	d d
0544	#@printhex0
0544		pop	a
0545		sliu d 0
0546		slil d 10
0547		sub	a d
0548		sliu d 4
0549		slil d 1
054a		add	a d
054b		sliu d #printhex2	[05]
054c		slil d #printhex2	[01]
054d		jalr	d d
054e	#printhex_num1
054e		sliu d 3
054f		slil d 0
0550		add	a d
0551	#printhex2	; calling global function printchar

0551		push	d
0552		push	c
0553		push	b
0554		sliu d 0
0555		slil d 5
0556		push	d
0557		push	c
0558		sliu c 0
0559		slil c 5
055a		sliu d #printchar	[01]
055b		slil d #printchar	[09]
055c		jmpfar	d d
055d		pop	b
055e		pop	c
055f		pop	d
0560		pop	a
0561		sliu b 0
0562		slil b 15
0563		nand	a b
0564		nand	a a
0565		push	a
0566		sliu d 0
0567		slil d 10
0568		sub	a d
0569		sliu d #@printhex1	[07]
056a		slil d #@printhex1	[01]
056b		skipl	a
056c		jalr	d d
056d		pop	a
056e		sliu d #printhex_num2	[07]
056f		slil d #printhex_num2	[0b]
0570		jalr	d d
0571	#@printhex1
0571		pop	a
0572		sliu d 0
0573		slil d 10
0574		sub	a d
0575		sliu d 4
0576		slil d 1
0577		add	a d
0578		sliu d #printhex3	[07]
0579		slil d #printhex3	[0e]
057a		jalr	d d
057b	#printhex_num2
057b		sliu d 3
057c		slil d 0
057d		add	a d
057e	#printhex3	; calling global function printchar

057e		push	d
057f		push	c
0580		push	b
0581		sliu d 0
0582		slil d 5
0583		push	d
0584		push	c
0585		sliu c 0
0586		slil c 5
0587		sliu d #printchar	[01]
0588		slil d #printchar	[09]
0589		jmpfar	d d
058a		pop	b
058b		pop	c
058c		pop	d
058d		pop	a
058e		pop	d
058f		pop	c
0590		jmpfar	d d	
	; printhex ends
	
	

0591		org	600	
	; ------- GLOBAL FUNCTION readchar -------

0600	#readchar
0600		pop	c
0601		push	d		; reads a char in A

0602	#inloop
0602		in	a
0603		push	a
0604		sliu d 0
0605		slil d 0
0606		sub	a d
0607		sliu d #@readchar0	[00]
0608		slil d #@readchar0	[0f]
0609		skipz	a
060a		jalr	d d
060b		pop	a
060c		sliu d #inloop	[00]
060d		slil d #inloop	[02]
060e		jalr	d d
060f	#@readchar0
060f		pop	a
0610		pop	d
0611		pop	c
0612		jmpfar	d d	
	; readchar ends
	
	
	
	; ------- GLOBAL FUNCTION readstring -------

0613	#readstring
0613		pop	c
0614		push	d		;A = buffer page, B = buffer addr
		; reads a string until RETURN, puts in buffer and null terminates
	

0615		page	a
0616	#readstring_readloop	; calling global function readchar

0616		push	d
0617		push	c
0618		push	b
0619		sliu d 0
061a		slil d 6
061b		push	d
061c		push	c
061d		sliu c 0
061e		slil c 6
061f		sliu d #readchar	[00]
0620		slil d #readchar	[00]
0621		jmpfar	d d
0622		pop	b
0623		pop	c
0624		pop	d
0625		push	a
0626		sliu d 0
0627		slil d 13
0628		sub	a d
0629		sliu d #@readstring0	[03]
062a		slil d #@readstring0	[01]
062b		skipz	a
062c		jalr	d d
062d		pop	a
062e		sliu d #readstring_return	[06]
062f		slil d #readstring_return	[0d]
0630		jalr	d d
0631	#@readstring0
0631		pop	a
0632		push	a
0633		sliu d 0
0634		slil d 8
0635		sub	a d
0636		sliu d #@readstring1	[03]
0637		slil d #@readstring1	[0e]
0638		skipz	a
0639		jalr	d d
063a		pop	a
063b		sliu d #readstring_backspace	[05]
063c		slil d #readstring_backspace	[03]
063d		jalr	d d
063e	#@readstring1
063e		pop	a	; calling global function printchar

063f		push	d
0640		push	c
0641		push	b
0642		sliu d 0
0643		slil d 6
0644		push	d
0645		push	c
0646		sliu c 0
0647		slil c 5
0648		sliu d #printchar	[01]
0649		slil d #printchar	[09]
064a		jmpfar	d d
064b		pop	b
064c		pop	c
064d		pop	d
064e		store	a [b]
064f		inc	b
0650		sliu d #readstring_readloop	[01]
0651		slil d #readstring_readloop	[06]
0652		jalr	d d	

0653	#readstring_backspace		; ignore if beginning of line
		;;; TODO bug what if buffer doesn't start at 0?

0653		push	b
0654		sliu d 0
0655		slil d 0
0656		sub	b d
0657		sliu d #@readstring2	[05]
0658		slil d #@readstring2	[0f]
0659		skipz	b
065a		jalr	d d
065b		pop	b
065c		sliu d #readstring_readloop	[01]
065d		slil d #readstring_readloop	[06]
065e		jalr	d d
065f	#@readstring2
065f		pop	b
0660		dec	b	;	li	d,0x00
	;	out	d
	;	li	d,0x04
	;	out	d
	;	li	d,0x82
	;	out	d
	;	li	d,0x80
	;	out	d
	;	li	d,0x00
	;	out	d
	;	li	d,0x00
	;	out	d

0661		sliu d 0
0662		slil d 8
0663		out	d
0664		sliu d 2
0665		slil d 0
0666		out	d
0667		sliu d 0
0668		slil d 8
0669		out	d
066a		sliu d #readstring_readloop	[01]
066b		slil d #readstring_readloop	[06]
066c		jalr	d d	

066d	#readstring_return
066d		sliu d 0
066e		slil d 13
066f		out	d
0670		sliu d 2
0671		slil d 0
0672		out	d	;	; home
	;	li	d,0x00
	;	out	d
	;	li	d,0x03
	;	out	d
	
		;null terminate

0673		sliu a 0
0674		slil a 0
0675		store	a [b]
0676		pop	d
0677		pop	c
0678		jmpfar	d d	
	; readstring ends
	
	

0679		org	700	
	; ------- GLOBAL FUNCTION div -------

0700	#div
0700		pop	c
0701		push	d		; A = A / B

0702		sliu c 0
0703		slil c 0
0704		push	b
0705		sliu d 0
0706		slil d 0
0707		sub	b d
0708		sliu d #@div0	[01]
0709		slil d #@div0	[00]
070a		skipz	b
070b		jalr	d d
070c		pop	b
070d		sliu d #div_done	[06]
070e		slil d #div_done	[05]
070f		jalr	d d
0710	#@div0
0710		pop	b	
		; check special cases: b is negative (b>128)

0711		push	b
0712		sliu d 0
0713		slil d 0
0714		sub	b d
0715		sliu d #@div1	[01]
0716		slil d #@div1	[0d]
0717		skipl	b
0718		jalr	d d
0719		pop	b
071a		sliu d #div_neg_b	[04]
071b		slil d #div_neg_b	[00]
071c		jalr	d d
071d	#@div1
071d		pop	b		;if a is negative initially (a>127) then subtract b until a becomes positive

071e	#div_negadjust
071e		push	a
071f		sliu d 0
0720		slil d 0
0721		sub	a d
0722		sliu d #@div2	[02]
0723		slil d #@div2	[0a]
0724		skipge	a
0725		jalr	d d
0726		pop	a
0727		sliu d #divwhile	[03]
0728		slil d #divwhile	[00]
0729		jalr	d d
072a	#@div2
072a		pop	a
072b		sub	a b
072c		inc	c
072d		sliu d #div_negadjust	[01]
072e		slil d #div_negadjust	[0e]
072f		jalr	d d
0730	#divwhile
0730		push	a
0731		sub	a b
0732		sliu d #@div3	[03]
0733		slil d #@div3	[0a]
0734		skipl	a
0735		jalr	d d
0736		pop	a
0737		sliu d #div_done	[06]
0738		slil d #div_done	[05]
0739		jalr	d d
073a	#@div3
073a		pop	a
073b		sub	a b
073c		inc	c
073d		sliu d #divwhile	[03]
073e		slil d #divwhile	[00]
073f		jalr	d d
0740	#div_neg_b		; b is very large.  if a is positive, then a/b==0

0740		push	a
0741		sliu d 0
0742		slil d 0
0743		sub	a d
0744		sliu d #@div4	[04]
0745		slil d #@div4	[0c]
0746		skipge	a
0747		jalr	d d
0748		pop	a
0749		sliu d #div_done	[06]
074a		slil d #div_done	[05]
074b		jalr	d d
074c	#@div4
074c		pop	a
074d		push	a
074e		sub	a b
074f		sliu d #@div5	[05]
0750		slil d #@div5	[07]
0751		skipl	a
0752		jalr	d d
0753		pop	a
0754		sliu d #div_done	[06]
0755		slil d #div_done	[05]
0756		jalr	d d
0757	#@div5
0757		pop	a
0758		push	a
0759		sub	a b
075a		sliu d #@div6	[06]
075b		slil d #@div6	[02]
075c		skipnz	a
075d		jalr	d d
075e		pop	a
075f		sliu d #div_negadjust	[01]
0760		slil d #div_negadjust	[0e]
0761		jalr	d d
0762	#@div6
0762		pop	a		; a==b

0763		sliu c 0
0764		slil c 1
0765	#div_done
0765		sub	a a
0766		add	a c
0767		pop	d
0768		pop	c
0769		jmpfar	d d	
	; div ends
	
	
	
	; ------- GLOBAL FUNCTION div_even -------

076a	#div_even
076a		pop	c
076b		push	d		; A = A / B
		; only works if A%B is 0

076c		sliu c 0
076d		slil c 0
076e	#divewhile
076e		push	a
076f		sliu d 0
0770		slil d 0
0771		sub	a d
0772		sliu d #@div_even0	[07]
0773		slil d #@div_even0	[0a]
0774		skipz	a
0775		jalr	d d
0776		pop	a
0777		sliu d #divewhileend	[08]
0778		slil d #divewhileend	[00]
0779		jalr	d d
077a	#@div_even0
077a		pop	a
077b		sub	a b
077c		inc	c
077d		sliu d #divewhile	[06]
077e		slil d #divewhile	[0e]
077f		jalr	d d
0780	#divewhileend
0780		sub	a a
0781		add	a c
0782		pop	d
0783		pop	c
0784		jmpfar	d d	
	; div_even ends
	
	
	
	; ------- GLOBAL FUNCTION mod -------

0785	#mod
0785		pop	c
0786		push	d		; A = A % B

0787		push	b
0788		sliu d 0
0789		slil d 0
078a		sub	b d
078b		sliu d #@mod0	[09]
078c		slil d #@mod0	[03]
078d		skipz	b
078e		jalr	d d
078f		pop	b
0790		sliu d #mod0	[0c]
0791		slil d #mod0	[01]
0792		jalr	d d
0793	#@mod0
0793		pop	b		; special case: b>127

0794		push	b
0795		sliu d 0
0796		slil d 0
0797		sub	b d
0798		sliu d #@mod1	[0a]
0799		slil d #@mod1	[00]
079a		skipl	b
079b		jalr	d d
079c		pop	b
079d		sliu d #mod_neg_b	[0c]
079e		slil d #mod_neg_b	[06]
079f		jalr	d d
07a0	#@mod1
07a0		pop	b
07a1	#mod_negadjust
07a1		push	a
07a2		sliu d 0
07a3		slil d 0
07a4		sub	a d
07a5		sliu d #@mod2	[0a]
07a6		slil d #@mod2	[0d]
07a7		skipge	a
07a8		jalr	d d
07a9		pop	a
07aa		sliu d #modwhile	[0b]
07ab		slil d #modwhile	[02]
07ac		jalr	d d
07ad	#@mod2
07ad		pop	a
07ae		sub	a b
07af		sliu d #mod_negadjust	[0a]
07b0		slil d #mod_negadjust	[01]
07b1		jalr	d d
07b2	#modwhile
07b2		push	a
07b3		sub	a b
07b4		sliu d #@mod3	[0b]
07b5		slil d #@mod3	[0c]
07b6		skipl	a
07b7		jalr	d d
07b8		pop	a
07b9		sliu d #modwhileend	[0e]
07ba		slil d #modwhileend	[0b]
07bb		jalr	d d
07bc	#@mod3
07bc		pop	a
07bd		sub	a b
07be		sliu d #modwhile	[0b]
07bf		slil d #modwhile	[02]
07c0		jalr	d d
07c1	#mod0
07c1		sliu a 0
07c2		slil a 0
07c3		sliu d #modwhileend	[0e]
07c4		slil d #modwhileend	[0b]
07c5		jalr	d d
07c6	#mod_neg_b		; b is > 127
		; if a is positive, then just return a

07c6		push	a
07c7		sliu d 0
07c8		slil d 0
07c9		sub	a d
07ca		sliu d #@mod4	[0d]
07cb		slil d #@mod4	[02]
07cc		skipge	a
07cd		jalr	d d
07ce		pop	a
07cf		sliu d #modwhileend	[0e]
07d0		slil d #modwhileend	[0b]
07d1		jalr	d d
07d2	#@mod4
07d2		pop	a		; if a < b then return a

07d3		push	a
07d4		sub	a b
07d5		sliu d #@mod5	[0d]
07d6		slil d #@mod5	[0d]
07d7		skipl	a
07d8		jalr	d d
07d9		pop	a
07da		sliu d #modwhileend	[0e]
07db		slil d #modwhileend	[0b]
07dc		jalr	d d
07dd	#@mod5
07dd		pop	a
07de		push	a
07df		sub	a b
07e0		sliu d #@mod6	[0e]
07e1		slil d #@mod6	[08]
07e2		skipnz	a
07e3		jalr	d d
07e4		pop	a
07e5		sliu d #mod_negadjust	[0a]
07e6		slil d #mod_negadjust	[01]
07e7		jalr	d d
07e8	#@mod6
07e8		pop	a		; a == b, so return 0

07e9		sliu a 0
07ea		slil a 0
07eb	#modwhileend
07eb		pop	d
07ec		pop	c
07ed		jmpfar	d d	
	; mod ends
	
	

07ee		org 800	
	; ------- GLOBAL FUNCTION mul -------

0800	#mul
0800		pop	c
0801		push	d		; A = A * B

0802		sub	c c
0803	#mulloop
0803		push	b
0804		sliu d 0
0805		slil d 0
0806		sub	b d
0807		sliu d #@mul0	[00]
0808		slil d #@mul0	[0f]
0809		skipz	b
080a		jalr	d d
080b		pop	b
080c		sliu d #mulend	[01]
080d		slil d #mulend	[05]
080e		jalr	d d
080f	#@mul0
080f		pop	b
0810		add	c a
0811		dec	b
0812		sliu d #mulloop	[00]
0813		slil d #mulloop	[03]
0814		jalr	d d
0815	#mulend
0815		sub	a a
0816		add	a c
0817		pop	d
0818		pop	c
0819		jmpfar	d d	
	; mul ends
	
	
	
	; ------- GLOBAL FUNCTION clearscreen -------

081a	#clearscreen
081a		pop	c
081b		push	d		; resets screen and homes cursor

081c		sliu d 8
081d		slil d 0
081e		out	d	;	; home
	;	li	d,0x00
	;	out	d
	;	li	d,0x03
	;	out	d
	;	; clear
	;	li	d,0x00
	;	out	d
	;	li	d,0x01
	;	out	d
	

081f		pop	d
0820		pop	c
0821		jmpfar	d d	
	; clearscreen ends
	
	
	
	; ------- GLOBAL FUNCTION readprompt -------

0822	#readprompt
0822		pop	c
0823		push	d		;move to new line and display > prompt

0824		sliu d 0
0825		slil d 13
0826		out	d
0827		sliu d 2
0828		slil d 0
0829		out	d
082a		sliu d 3
082b		slil d 14
082c		out	d	
	;	;clears second line, puts cursor at beginning, prints prompt
	;	
	;	; put cursor on second line
	;	li	d,0x0c
	;	out	d
	;	li	d,0x00
	;	out	d
	;
	;	;print 16 spaces
	;	li	c,16
	;#readprompt_clr
	;	li	d,0x82
	;	out	d
	;	li	d,0x80
	;	out	d
	;	dec	c
	;	.if c != 0 then readprompt_clr
	;
	;	; put cursor on second line again
	;	li	d,0x0c
	;	out	d
	;	li	d,0x00
	;	out	d
	;
	;	; print a > prompt
	;	li	d,0x83
	;	out	d
	;	li	d,0x8e
	;	out	d

082d		pop	d
082e		pop	c
082f		jmpfar	d d	
	; readprompt ends
	
	

0830		org f00	
	; ------- GLOBAL FUNCTION identify_keychar -------

0f00	#identify_keychar
0f00		pop	c
0f01		push	d		; A is page, B is testchar
		; returns 0 if no match, otherwise keychar in A
	
		; push data page

0f02		push	a
0f03		sliu a 7
0f04		slil a 14
0f05		page	a		
		; c holds keychar addr

0f06		sliu c #keychars	[00]
0f07		slil c #keychars	[00]	

0f08	#identify_keychar_loop		;compare
		;get char from keyword list

0f08		load	a [c]	

0f09		push	a
0f0a		sub	a b
0f0b		sliu d #@identify_keychar0	[01]
0f0c		slil d #@identify_keychar0	[03]
0f0d		skipz	a
0f0e		jalr	d d
0f0f		pop	a
0f10		sliu d #identify_keychar_match	[02]
0f11		slil d #identify_keychar_match	[00]
0f12		jalr	d d
0f13	#@identify_keychar0
0f13		pop	a	

0f14	#identify_keychar_doesntmatch	
		;not a match.  move to next keychar
	
		; advance c four forwards

0f14		inc	c
0f15		inc	c
0f16		inc	c
0f17		inc	c		; if it is zero, no keychars match

0f18		load	a [c]
0f19		sliu d #identify_keychar_nomatches	[02]
0f1a		slil d #identify_keychar_nomatches	[06]
0f1b		skipnz	a
0f1c		jalr	d d
0f1d		sliu d #identify_keychar_loop	[00]
0f1e		slil d #identify_keychar_loop	[08]
0f1f		jalr	d d	

0f20	#identify_keychar_match		; the next char is the token

0f20		inc	c
0f21		inc	c
0f22		load	a [c]
0f23		sliu d #identify_keychar_done	[02]
0f24		slil d #identify_keychar_done	[07]
0f25		jalr	d d	

0f26	#identify_keychar_nomatches	

0f26		sub	a a	

0f27	#identify_keychar_done
0f27		pop	d
0f28		page	d
0f29		pop	d
0f2a		pop	c
0f2b		jmpfar	d d	
	; identify_keychar ends
	
	
	; tokens:
	; known keywords are reduced to a single character
	; integers consist of one or more digits
	; strings are surrounded by ""
	; vars are # then one or more capital letters
	

0f2c		org 1000	
	; ------- GLOBAL FUNCTION tokenize -------

1000	#tokenize
1000		pop	c
1001		push	d		; generates a new command string with tokens replacing keywords
		; A=buffer page, B=buffer addr, C=dest buffer addr
		; returns 0 if no error, 1 if syntax error
	

1002		page	a		;push the page

1003		push	a	
		;save dest addr on stack

1004		push	c	

1005	#tokenize_loop		;get next char

1005		load	a [b]	
		;if it's 0, end of line

1006		sliu d #tokenize_done	[0e]
1007		slil d #tokenize_done	[09]
1008		skipnz	a
1009		jalr	d d	
		; is it a space? just move forward

100a		load	a [b]
100b		sliu d 2
100c		slil d 0
100d		sub	a d
100e		sliu d #tokenize_notspace	[01]
100f		slil d #tokenize_notspace	[06]
1010		skipz	a
1011		jalr	d d
1012		inc	b
1013		sliu d #tokenize_loop	[00]
1014		slil d #tokenize_loop	[05]
1015		jalr	d d	

1016	#tokenize_notspace		; is it a string? then copy and advance to next "

1016		load	a [b]
1017		sliu d 2
1018		slil d 2
1019		sub	a d
101a		sliu d #tokenize_notstring	[03]
101b		slil d #tokenize_notstring	[08]
101c		skipz	a
101d		jalr	d d
101e		pop	c	

101f	#tokenize_stringcopyloop
101f		load	a [b]
1020		store	a [c]
1021		inc	b
1022		inc	c
1023		load	a [b]
1024		sliu d 2
1025		slil d 2
1026		sub	a d
1027		sliu d #tokenize_stringcopyloop	[01]
1028		slil d #tokenize_stringcopyloop	[0f]
1029		skipz	a
102a		jalr	d d	
		;put a space after the string

102b		inc	b
102c		sliu d 2
102d		slil d 2
102e		store	d [c]
102f		inc	c
1030		sliu d 2
1031		slil d 0
1032		store	d [c]
1033		inc	c
1034		push	c
1035		sliu d #tokenize_loop	[00]
1036		slil d #tokenize_loop	[05]
1037		jalr	d d	

1038	#tokenize_notstring		;is it a number? match 0-9

1038		load	a [b]
1039		sliu d 3
103a		slil d 0
103b		sub	a d
103c		sliu d #tokenize_notnumber	[06]
103d		slil d #tokenize_notnumber	[03]
103e		skipge	a
103f		jalr	d d
1040		sliu d 0
1041		slil d 10
1042		sub	a d
1043		sliu d #tokenize_notnumber	[06]
1044		slil d #tokenize_notnumber	[03]
1045		skipl	a
1046		jalr	d d	
		; copy the number over

1047		pop	c
1048	#tokenize_numbercopyloop
1048		load	a [b]
1049		store	a [c]
104a		inc	b
104b		inc	c
104c		load	a [b]
104d		sliu d 3
104e		slil d 0
104f		sub	a d
1050		sliu d #tokenize_numbercopyloopdone	[05]
1051		slil d #tokenize_numbercopyloopdone	[0b]
1052		skipge	a
1053		jalr	d d
1054		sliu d 0
1055		slil d 10
1056		sub	a d
1057		sliu d #tokenize_numbercopyloop	[04]
1058		slil d #tokenize_numbercopyloop	[08]
1059		skipge	a
105a		jalr	d d	

105b	#tokenize_numbercopyloopdone		; save a space

105b		sliu d 2
105c		slil d 0
105d		store	d [c]
105e		inc	c
105f		push	c
1060		sliu d #tokenize_loop	[00]
1061		slil d #tokenize_loop	[05]
1062		jalr	d d	

1063	#tokenize_notnumber	
		; check if it's a keychar

1063		pop	c
1064		pop	a
1065		push	a
1066		push	c
1067		push	b
1068		load	b [b]	; calling global function identify_keychar

1069		push	d
106a		push	c
106b		push	b
106c		sliu d 1
106d		slil d 0
106e		push	d
106f		push	c
1070		sliu c 0
1071		slil c 15
1072		sliu d #identify_keychar	[00]
1073		slil d #identify_keychar	[00]
1074		jmpfar	d d
1075		pop	b
1076		pop	c
1077		pop	d
1078		pop	b
1079		sliu d #tokenize_notkeychar	[08]
107a		slil d #tokenize_notkeychar	[09]
107b		skipnz	a
107c		jalr	d d	
		;save keychar to output string

107d		pop	c
107e		store	a [c]
107f		inc	c		;include space

1080		sliu d 2
1081		slil d 0
1082		store	d [c]
1083		inc	c
1084		push	c	
		;advance one char

1085		inc	b
1086		sliu d #tokenize_loop	[00]
1087		slil d #tokenize_loop	[05]
1088		jalr	d d	

1089	#tokenize_notkeychar		; check if it's a keyword
	

1089		pop	c
108a		pop	a
108b		push	a
108c		push	c	
	; calling global function identify_keyword

108d		push	d
108e		push	c
108f		push	b
1090		sliu d 1
1091		slil d 0
1092		push	d
1093		push	c
1094		sliu c 1
1095		slil c 1
1096		sliu d #identify_keyword	[00]
1097		slil d #identify_keyword	[00]
1098		jmpfar	d d
1099		pop	b
109a		pop	c
109b		pop	d
109c		sliu d #tokenize_notkey	[0b]
109d		slil d #tokenize_notkey	[08]
109e		skipnz	a
109f		jalr	d d	
		;save keyword token to output string

10a0		pop	c
10a1		store	a [c]
10a2		inc	c		;include space separator

10a3		sliu d 2
10a4		slil d 0
10a5		store	d [c]
10a6		inc	c
10a7		push	c	
		;advance b to next space or EOL

10a8	#tokenize_advance
10a8		inc	b
10a9		load	a [b]	
		; if a == 0 then done

10aa		sliu d #tokenize_done	[0e]
10ab		slil d #tokenize_done	[09]
10ac		skipnz	a
10ad		jalr	d d		; if a == ' ' then stop

10ae		sliu d 2
10af		slil d 0
10b0		sub	a d
10b1		sliu d #tokenize_advance	[0a]
10b2		slil d #tokenize_advance	[08]
10b3		skipz	a
10b4		jalr	d d	

10b5		sliu d #tokenize_loop	[00]
10b6		slil d #tokenize_loop	[05]
10b7		jalr	d d	

10b8	#tokenize_notkey		;is it a var? match A-Z

10b8		load	a [b]
10b9		sliu d 4
10ba		slil d 1
10bb		sub	a d
10bc		sliu d #tokenize_notvar	[0e]
10bd		slil d #tokenize_notvar	[04]
10be		skipge	a
10bf		jalr	d d
10c0		sliu d 1
10c1		slil d 10
10c2		sub	a d
10c3		sliu d #tokenize_notvar	[0e]
10c4		slil d #tokenize_notvar	[04]
10c5		skipl	a
10c6		jalr	d d	

10c7		pop	c	
		;plant a # at beginning

10c8		sliu d 2
10c9		slil d 3
10ca		store	d [c]
10cb		inc	c	
		; copy the letters over

10cc	#tokenize_varcopyloop
10cc		load	a [b]
10cd		store	a [c]
10ce		inc	b
10cf		inc	c
10d0		load	a [b]
10d1		sliu d #tokenize_varcopyloopdone	[0d]
10d2		slil d #tokenize_varcopyloopdone	[0c]
10d3		skipnz	a
10d4		jalr	d d
10d5		sliu d 4
10d6		slil d 1
10d7		sub	a d
10d8		sliu d #tokenize_varcopyloop	[0c]
10d9		slil d #tokenize_varcopyloop	[0c]
10da		skipl	a
10db		jalr	d d	

10dc	#tokenize_varcopyloopdone		; save a space

10dc		sliu d 2
10dd		slil d 0
10de		store	d [c]
10df		inc	c
10e0		push	c
10e1		sliu d #tokenize_loop	[00]
10e2		slil d #tokenize_loop	[05]
10e3		jalr	d d	

10e4	#tokenize_notvar		;syntax error

10e4		sliu a 0
10e5		slil a 1
10e6		sliu d #tokenize_done_return	[0e]
10e7		slil d #tokenize_done_return	[0f]
10e8		jalr	d d	

10e9	#tokenize_done
10e9		pop	c
10ea		push	c
10eb		# null terminate output string
10eb		sliu d 0
10ec		slil d 0
10ed		store	d [c]
10ee		sub	a a
10ef	#tokenize_done_return
10ef		pop	c
10f0		pop	d
10f1		pop	d
10f2		pop	c
10f3		jmpfar	d d	
	; tokenize ends
	
	

10f4		org 1100	
	
	; ------- GLOBAL FUNCTION identify_keyword -------

1100	#identify_keyword
1100		pop	c
1101		push	d		; A is page, B is address
		; returns 0 if no match, otherwise keyword char in A
	
		; push test address and data page

1102		push	b
1103		push	a		
		; c holds keyword addr

1104		sliu c #keywords	[03]
1105		slil c #keywords	[01]	

1106	#identify_keyword_loop		;compare
		;get char from keyword list

1106		sliu a 7
1107		slil a 14
1108		page	a
1109		load	a [c]	
		;is the keyword 0? then test better be 0 or ' '

110a		push	a
110b		sliu d 0
110c		slil d 0
110d		sub	a d
110e		sliu d #@identify_keyword0	[01]
110f		slil d #@identify_keyword0	[06]
1110		skipnz	a
1111		jalr	d d
1112		pop	a
1113		sliu d #identify_keyword_notendofkeyword	[05]
1114		slil d #identify_keyword_notendofkeyword	[00]
1115		jalr	d d
1116	#@identify_keyword0
1116		pop	a		
		;get char from test

1117		pop	a
1118		page	a
1119		push	a
111a		load	a [b]	
		;if it's 0 or ' ', then match

111b		push	a
111c		sliu d 0
111d		slil d 0
111e		sub	a d
111f		sliu d #@identify_keyword1	[02]
1120		slil d #@identify_keyword1	[07]
1121		skipz	a
1122		jalr	d d
1123		pop	a
1124		sliu d #identify_keyword_match	[07]
1125		slil d #identify_keyword_match	[0c]
1126		jalr	d d
1127	#@identify_keyword1
1127		pop	a
1128		push	a
1129		sliu d 2
112a		slil d 0
112b		sub	a d
112c		sliu d #@identify_keyword2	[03]
112d		slil d #@identify_keyword2	[04]
112e		skipz	a
112f		jalr	d d
1130		pop	a
1131		sliu d #identify_keyword_match	[07]
1132		slil d #identify_keyword_match	[0c]
1133		jalr	d d
1134	#@identify_keyword2
1134		pop	a	

1135	#identify_keyword_doesntmatch	
		;not a match.  reset b and move to next keyword

1135		pop	a
1136		pop	b
1137		push	b
1138		push	a
1139		sliu a 7
113a		slil a 14
113b		page	a		;advance c to 0 if it's not there yet

113c	#identify_keyword_doesntmatch2
113c		load	a [c]
113d		sliu d #identify_keyword_doesntmatch1	[04]
113e		slil d #identify_keyword_doesntmatch1	[05]
113f		skipnz	a
1140		jalr	d d
1141		inc	c
1142		sliu d #identify_keyword_doesntmatch2	[03]
1143		slil d #identify_keyword_doesntmatch2	[0c]
1144		jalr	d d
1145	#identify_keyword_doesntmatch1	
		; advance c three forwards

1145		inc	c
1146		inc	c
1147		inc	c		; if it is zero, no keywords match

1148		load	a [c]
1149		sliu d #identify_keyword_nomatches	[08]
114a		slil d #identify_keyword_nomatches	[04]
114b		skipnz	a
114c		jalr	d d
114d		sliu d #identify_keyword_loop	[00]
114e		slil d #identify_keyword_loop	[06]
114f		jalr	d d	

1150	#identify_keyword_notendofkeyword		; are we at end of test word? if so, no match

1150		pop	a
1151		page	a
1152		push	a
1153		load	a [b]
1154		push	a
1155		sliu d 0
1156		slil d 0
1157		sub	a d
1158		sliu d #@identify_keyword3	[06]
1159		slil d #@identify_keyword3	[00]
115a		skipz	a
115b		jalr	d d
115c		pop	a
115d		sliu d #identify_keyword_doesntmatch	[03]
115e		slil d #identify_keyword_doesntmatch	[05]
115f		jalr	d d
1160	#@identify_keyword3
1160		pop	a
1161		push	a
1162		sliu d 2
1163		slil d 0
1164		sub	a d
1165		sliu d #@identify_keyword4	[06]
1166		slil d #@identify_keyword4	[0d]
1167		skipz	a
1168		jalr	d d
1169		pop	a
116a		sliu d #identify_keyword_doesntmatch	[03]
116b		slil d #identify_keyword_doesntmatch	[05]
116c		jalr	d d
116d	#@identify_keyword4
116d		pop	a	
		;test if the letters are the same

116e		sliu d 7
116f		slil d 14
1170		page	d
1171		load	d [c]	

1172		sub	a d
1173		sliu d #identify_keyword_doesntmatch	[03]
1174		slil d #identify_keyword_doesntmatch	[05]
1175		skipz	a
1176		jalr	d d	
		;not done with matching.  go to next character

1177		inc	b
1178		inc	c
1179		sliu d #identify_keyword_loop	[00]
117a		slil d #identify_keyword_loop	[06]
117b		jalr	d d	

117c	#identify_keyword_match		; the next char is the token

117c		sliu d 7
117d		slil d 14
117e		page	d
117f		inc	c
1180		load	a [c]
1181		sliu d #identify_keyword_done	[08]
1182		slil d #identify_keyword_done	[05]
1183		jalr	d d	

1184	#identify_keyword_nomatches	

1184		sub	a a	

1185	#identify_keyword_done
1185		pop	d
1186		page	d
1187		pop	d
1188		pop	d
1189		pop	c
118a		jmpfar	d d	
	; identify_keyword ends
	
	

118b		org 1200	
	; ------- GLOBAL FUNCTION basic -------

1200	#basic
1200		pop	c
1201		push	d		; print "tiny basic"

1202		sliu a 7
1203		slil a 15
1204		sliu b #basic_message	[00]
1205		slil b #basic_message	[0e]	; calling global function printstring

1206		push	d
1207		push	c
1208		push	b
1209		sliu d 1
120a		slil d 2
120b		push	d
120c		push	c
120d		sliu c 0
120e		slil c 5
120f		sliu d #printstring	[00]
1210		slil d #printstring	[00]
1211		jmpfar	d d
1212		pop	b
1213		pop	c
1214		pop	d	; calling global function basic_init

1215		push	d
1216		push	c
1217		push	b
1218		sliu d 1
1219		slil d 2
121a		push	d
121b		push	c
121c		sliu c 1
121d		slil c 3
121e		sliu d #basic_init	[01]
121f		slil d #basic_init	[0a]
1220		jmpfar	d d
1221		pop	b
1222		pop	c
1223		pop	d	; calling global function initvar

1224		push	d
1225		push	c
1226		push	b
1227		sliu d 1
1228		slil d 2
1229		push	d
122a		push	c
122b		sliu c 1
122c		slil c 13
122d		sliu d #initvar	[00]
122e		slil d #initvar	[00]
122f		jmpfar	d d
1230		pop	b
1231		pop	c
1232		pop	d	
		; main basic loop

1233	#basicloop	; calling global function clear_error

1233		push	d
1234		push	c
1235		push	b
1236		sliu d 1
1237		slil d 2
1238		push	d
1239		push	c
123a		sliu c 1
123b		slil c 12
123c		sliu d #clear_error	[01]
123d		slil d #clear_error	[0f]
123e		jmpfar	d d
123f		pop	b
1240		pop	c
1241		pop	d
1242		sliu d 0
1243		slil d 13
1244		out	d
1245		sliu d 2
1246		slil d 0
1247		out	d	
		; print "Ok" prompt

1248		sliu a 7
1249		slil a 15
124a		sliu b #basic_prompt	[01]
124b		slil b #basic_prompt	[09]	; calling global function printstring

124c		push	d
124d		push	c
124e		push	b
124f		sliu d 1
1250		slil d 2
1251		push	d
1252		push	c
1253		sliu c 0
1254		slil c 5
1255		sliu d #printstring	[00]
1256		slil d #printstring	[00]
1257		jmpfar	d d
1258		pop	b
1259		pop	c
125a		pop	d	;	li	d,0x0d
	;	out	d

125b		sliu d 2
125c		slil d 0
125d		out	d	
		; read a string to fd00

125e		sliu a 15
125f		slil a 13
1260		sliu b 0
1261		slil b 0	; calling global function readstring

1262		push	d
1263		push	c
1264		push	b
1265		sliu d 1
1266		slil d 2
1267		push	d
1268		push	c
1269		sliu c 0
126a		slil c 6
126b		sliu d #readstring	[01]
126c		slil d #readstring	[03]
126d		jmpfar	d d
126e		pop	b
126f		pop	c
1270		pop	d	
		; convert it to tokens at fd80
	; calling global function tokenizeline

1271		push	d
1272		push	c
1273		push	b
1274		sliu d 1
1275		slil d 2
1276		push	d
1277		push	c
1278		sliu c 1
1279		slil c 3
127a		sliu d #tokenizeline	[00]
127b		slil d #tokenizeline	[00]
127c		jmpfar	d d
127d		pop	b
127e		pop	c
127f		pop	d
1280		push	a
1281		sliu d 0
1282		slil d 0
1283		sub	a d
1284		sliu d #@basic0	[08]
1285		slil d #@basic0	[0c]
1286		skipz	a
1287		jalr	d d
1288		pop	a
1289		sliu d #basicloop_handle	[0a]
128a		slil d #basicloop_handle	[03]
128b		jalr	d d
128c	#@basic0
128c		pop	a		; print error

128d		sliu a 7
128e		slil a 15
128f		sliu b #lexical_error	[01]
1290		slil b #lexical_error	[0f]	; calling global function printstring

1291		push	d
1292		push	c
1293		push	b
1294		sliu d 1
1295		slil d 2
1296		push	d
1297		push	c
1298		sliu c 0
1299		slil c 5
129a		sliu d #printstring	[00]
129b		slil d #printstring	[00]
129c		jmpfar	d d
129d		pop	b
129e		pop	c
129f		pop	d
12a0		sliu d #basicloop	[03]
12a1		slil d #basicloop	[03]
12a2		jalr	d d	

12a3	#basicloop_handle		; if the first token is a line number, save line in program space

12a3		sliu a 15
12a4		slil a 13
12a5		page	a
12a6		sliu c 8
12a7		slil c 0
12a8		load	a [c]
12a9		push	a
12aa		sliu d 3
12ab		slil d 0
12ac		sub	a d
12ad		sliu d #@basic1	[0b]
12ae		slil d #@basic1	[05]
12af		skipl	a
12b0		jalr	d d
12b1		pop	a
12b2		sliu d #basic_notprog	[0d]
12b3		slil d #basic_notprog	[05]
12b4		jalr	d d
12b5	#@basic1
12b5		pop	a
12b6		push	a
12b7		sliu d 3
12b8		slil d 10
12b9		sub	a d
12ba		sliu d #@basic2	[0c]
12bb		slil d #@basic2	[02]
12bc		skipge	a
12bd		jalr	d d
12be		pop	a
12bf		sliu d #basic_notprog	[0d]
12c0		slil d #basic_notprog	[05]
12c1		jalr	d d
12c2	#@basic2
12c2		pop	a	
	; calling global function basic_saveline

12c3		push	d
12c4		push	c
12c5		push	b
12c6		sliu d 1
12c7		slil d 2
12c8		push	d
12c9		push	c
12ca		sliu c 1
12cb		slil c 3
12cc		sliu d #basic_saveline	[03]
12cd		slil d #basic_saveline	[0c]
12ce		jmpfar	d d
12cf		pop	b
12d0		pop	c
12d1		pop	d
12d2		sliu d #basicloop	[03]
12d3		slil d #basicloop	[03]
12d4		jalr	d d	

12d5	#basic_notprog	; calling global function basic_doline

12d5		push	d
12d6		push	c
12d7		push	b
12d8		sliu d 1
12d9		slil d 2
12da		push	d
12db		push	c
12dc		sliu c 2
12dd		slil c 7
12de		sliu d #basic_doline	[00]
12df		slil d #basic_doline	[00]
12e0		jmpfar	d d
12e1		pop	b
12e2		pop	c
12e3		pop	d
12e4		sliu d #basicloop	[03]
12e5		slil d #basicloop	[03]
12e6		jalr	d d
12e7		pop	d
12e8		pop	c
12e9		jmpfar	d d	
	; basic ends
	
	

12ea		org 1300	
	; ------- GLOBAL FUNCTION tokenizeline -------

1300	#tokenizeline
1300		pop	c
1301		push	d
1302		sliu a 15
1303		slil a 13
1304		sliu b 0
1305		slil b 0
1306		sliu c 8
1307		slil c 0	; calling global function tokenize

1308		push	d
1309		push	c
130a		push	b
130b		sliu d 1
130c		slil d 3
130d		push	d
130e		push	c
130f		sliu c 1
1310		slil c 0
1311		sliu d #tokenize	[00]
1312		slil d #tokenize	[00]
1313		jmpfar	d d
1314		pop	b
1315		pop	c
1316		pop	d	;	li	a,0xfd
	;	li	b,0x80
	;	.call printstring
	;	li	a,0x0d
	;	out	a
	;	li	a,0x0a
	;	out	a
	;	li	a,0x20
	;	out	a

1317		pop	d
1318		pop	c
1319		jmpfar	d d	
	; tokenizeline ends
	
	
	
	; ------- GLOBAL FUNCTION basic_init -------

131a	#basic_init
131a		pop	c
131b		push	d		; goes from pages 0x90 to 0xcf and sets to 0

131c		sliu a 0
131d		slil a 0
131e		sliu c 9
131f		slil c 0
1320	#basic_init_pageloop
1320		page	c
1321		sliu b 0
1322		slil b 0
1323	#basic_init_addrloop
1323		sliu d 2
1324		slil d 0
1325		sub	b d
1326		store	a [b]
1327		sliu d #basic_init_addrloop	[02]
1328		slil d #basic_init_addrloop	[03]
1329		skipz	b
132a		jalr	d d
132b		inc	c
132c		push	c
132d		sliu d 13
132e		slil d 0
132f		sub	c d
1330		sliu d #@basic_init0	[03]
1331		slil d #@basic_init0	[08]
1332		skipnz	c
1333		jalr	d d
1334		pop	c
1335		sliu d #basic_init_pageloop	[02]
1336		slil d #basic_init_pageloop	[00]
1337		jalr	d d
1338	#@basic_init0
1338		pop	c
1339		pop	d
133a		pop	c
133b		jmpfar	d d	
	; basic_init ends
	
	
	
	; ------- GLOBAL FUNCTION basic_saveline -------

133c	#basic_saveline
133c		pop	c
133d		push	d		; copy line at fd80 to program space and link line number
		; program space from pages 90 to af, tokenized program from b0 to cf
		; each program line is given 0x20 space
	
		; find end of line number in line

133e		sliu a 15
133f		slil a 13
1340		page	a
1341		sliu b 8
1342		slil b 0
1343	#basic_saveline_passlinenumber
1343		inc	b
1344		load	a [b]
1345		push	a
1346		sliu d 2
1347		slil d 0
1348		sub	a d
1349		sliu d #@basic_saveline0	[05]
134a		slil d #@basic_saveline0	[01]
134b		skipnz	a
134c		jalr	d d
134d		pop	a
134e		sliu d #basic_saveline_passlinenumber	[04]
134f		slil d #basic_saveline_passlinenumber	[03]
1350		jalr	d d
1351	#@basic_saveline0
1351		pop	a	
		; now work forward to find the 0x00

1352		sub	c c
1353	#basic_saveline_findeol
1353		inc	b
1354		inc	c
1355		load	a [b]
1356		push	a
1357		sliu d 0
1358		slil d 0
1359		sub	a d
135a		sliu d #@basic_saveline1	[06]
135b		slil d #@basic_saveline1	[02]
135c		skipnz	a
135d		jalr	d d
135e		pop	a
135f		sliu d #basic_saveline_findeol	[05]
1360		slil d #basic_saveline_findeol	[03]
1361		jalr	d d
1362	#@basic_saveline1
1362		pop	a	
		; c now holds number of bytes to save
		
		; push tokenized line between fd9f-fd80 to stack

1363	#basic_saveline_pushloop
1363		load	a [b]
1364		push	a
1365		dec	b
1366		dec	c
1367		push	c
1368		sliu d 0
1369		slil d 0
136a		sub	c d
136b		sliu d #@basic_saveline2	[07]
136c		slil d #@basic_saveline2	[03]
136d		skipnz	c
136e		jalr	d d
136f		pop	c
1370		sliu d #basic_saveline_pushloop	[06]
1371		slil d #basic_saveline_pushloop	[03]
1372		jalr	d d
1373	#@basic_saveline2
1373		pop	c	
		; push fd1f to fd00 to stack

1374		sliu b 1
1375		slil b 15
1376	#basic_saveline_pushloop2
1376		load	a [b]
1377		push	a
1378		dec	b
1379		push	b
137a		sliu d 15
137b		slil d 15
137c		sub	b d
137d		sliu d #@basic_saveline3	[08]
137e		slil d #@basic_saveline3	[05]
137f		skipnz	b
1380		jalr	d d
1381		pop	b
1382		sliu d #basic_saveline_pushloop2	[07]
1383		slil d #basic_saveline_pushloop2	[06]
1384		jalr	d d
1385	#@basic_saveline3
1385		pop	b	
		; get line number

1386		sliu a 15
1387		slil a 13
1388		sliu b 8
1389		slil b 0	; calling global function dectobin

138a		push	d
138b		push	c
138c		push	b
138d		sliu d 1
138e		slil d 3
138f		push	d
1390		push	c
1391		sliu c 1
1392		slil c 4
1393		sliu d #dectobin	[00]
1394		slil d #dectobin	[00]
1395		jmpfar	d d
1396		pop	b
1397		pop	c
1398		pop	d	
		; divide it by eight to get the page number

1399		push	a
139a		sliu d 15
139b		slil d 8
139c		nand	a d
139d		nand	a a
139e		sliu b 0
139f		slil b 8	; calling global function div_even

13a0		push	d
13a1		push	c
13a2		push	b
13a3		sliu d 1
13a4		slil d 3
13a5		push	d
13a6		push	c
13a7		sliu c 0
13a8		slil c 7
13a9		sliu d #div_even	[06]
13aa		slil d #div_even	[0a]
13ab		jmpfar	d d
13ac		pop	b
13ad		pop	c
13ae		pop	d
13af		sliu d 9
13b0		slil d 0
13b1		add	a d
13b2		page	a
13b3		sub	c c
13b4		add	c a	
		; last three bits * 32 is the address

13b5		pop	a
13b6		sliu d 0
13b7		slil d 7
13b8		nand	a d
13b9		nand	a a
13ba		sliu b 2
13bb		slil b 0	; calling global function mul

13bc		push	d
13bd		push	c
13be		push	b
13bf		sliu d 1
13c0		slil d 3
13c1		push	d
13c2		push	c
13c3		sliu c 0
13c4		slil c 8
13c5		sliu d #mul	[00]
13c6		slil d #mul	[00]
13c7		jmpfar	d d
13c8		pop	b
13c9		pop	c
13ca		pop	d	
		;copy string from stack

13cb		sliu b 2
13cc		slil b 0
13cd	#basic_saveline_poploop
13cd		pop	d
13ce		store	d [a]
13cf		inc	a
13d0		dec	b
13d1		sliu d #basic_saveline_poploop	[0c]
13d2		slil d #basic_saveline_poploop	[0d]
13d3		skipz	b
13d4		jalr	d d	
		;advance page by 0x20 and copy tokenized from stack

13d5		sliu d 2
13d6		slil d 0
13d7		add	c d
13d8		page	c
13d9		sub	a d
13da	#basic_saveline_poploop2
13da		pop	c
13db		store	c [a]
13dc		inc	a
13dd		sliu d #basic_saveline_poploop2	[0d]
13de		slil d #basic_saveline_poploop2	[0a]
13df		skipz	c
13e0		jalr	d d
13e1		pop	d
13e2		pop	c
13e3		jmpfar	d d	
	; basic_saveline ends
	
	

13e4		org 1400	
	
	; ------- GLOBAL FUNCTION dectobin -------

1400	#dectobin
1400		pop	c
1401		push	d		;page in A, string addr in B terminated in ' ' or 0, returns num in A
	

1402		page	a
1403		sub	a a
1404	#dectobin_digloop
1404		load	c [b]		; check if digit is a ' ' or  \0

1405		sliu d #dectobin_digdone	[02]
1406		slil d #dectobin_digdone	[0c]
1407		skipnz	c
1408		jalr	d d
1409		sliu d 2
140a		slil d 0
140b		sub	c d
140c		sliu d #dectobin_digdone	[02]
140d		slil d #dectobin_digdone	[0c]
140e		skipnz	c
140f		jalr	d d	
		; multiply a = a * 10

1410		push	b
1411		sliu b 0
1412		slil b 10	; calling global function mul

1413		push	d
1414		push	c
1415		push	b
1416		sliu d 1
1417		slil d 4
1418		push	d
1419		push	c
141a		sliu c 0
141b		slil c 8
141c		sliu d #mul	[00]
141d		slil d #mul	[00]
141e		jmpfar	d d
141f		pop	b
1420		pop	c
1421		pop	d
1422		pop	b	
		; add digit

1423		load	c [b]
1424		add	a c
1425		sliu d 3
1426		slil d 0
1427		sub	a d	

1428		inc	b
1429		sliu d #dectobin_digloop	[00]
142a		slil d #dectobin_digloop	[04]
142b		jalr	d d
142c	#dectobin_digdone
142c		pop	d
142d		pop	c
142e		jmpfar	d d	
	; dectobin ends
	
	

142f		org 1600	
	; ------- GLOBAL FUNCTION doPRINT -------

1600	#doPRINT
1600		pop	c
1601		push	d		; start at beginning of line

1602		sliu c 8
1603		slil c 2	

1604	#doprint_loop		; get the token

1604		load	a [c]		; handle " 

1605		push	a
1606		sliu d 2
1607		slil d 2
1608		sub	a d
1609		sliu d #@doPRINT0	[01]
160a		slil d #@doPRINT0	[01]
160b		skipz	a
160c		jalr	d d
160d		pop	a
160e		sliu d #doprint_str	[07]
160f		slil d #doprint_str	[04]
1610		jalr	d d
1611	#@doPRINT0
1611		pop	a		; handle ,

1612		push	a
1613		sliu d 2
1614		slil d 12
1615		sub	a d
1616		sliu d #@doPRINT1	[01]
1617		slil d #@doPRINT1	[0e]
1618		skipz	a
1619		jalr	d d
161a		pop	a
161b		sliu d #doprint_comma	[06]
161c		slil d #doprint_comma	[03]
161d		jalr	d d
161e	#@doPRINT1
161e		pop	a		; handle ;

161f		push	a
1620		sliu d 3
1621		slil d 11
1622		sub	a d
1623		sliu d #@doPRINT2	[02]
1624		slil d #@doPRINT2	[0b]
1625		skipz	a
1626		jalr	d d
1627		pop	a
1628		sliu d #doprint_semicolon	[05]
1629		slil d #doprint_semicolon	[0d]
162a		jalr	d d
162b	#@doPRINT2
162b		pop	a		; handle eol

162c		push	a
162d		sliu d 0
162e		slil d 0
162f		sub	a d
1630		sliu d #@doPRINT3	[03]
1631		slil d #@doPRINT3	[08]
1632		skipz	a
1633		jalr	d d
1634		pop	a
1635		sliu d #doprint_eol	[06]
1636		slil d #doprint_eol	[0b]
1637		jalr	d d
1638	#@doPRINT3
1638		pop	a		; evaluate expression
	; calling global function eval_expression

1639		push	d
163a		push	c
163b		push	b
163c		sliu d 1
163d		slil d 6
163e		push	d
163f		push	c
1640		sliu c 1
1641		slil c 7
1642		sliu d #eval_expression	[00]
1643		slil d #eval_expression	[00]
1644		jmpfar	d d
1645		pop	b
1646		pop	c
1647		pop	d
1648		sliu c 15
1649		slil c 15
164a		load	c [c]	; calling global function print_integer

164b		push	d
164c		push	c
164d		push	b
164e		sliu d 1
164f		slil d 6
1650		push	d
1651		push	c
1652		sliu c 1
1653		slil c 11
1654		sliu d #print_integer	[00]
1655		slil d #print_integer	[00]
1656		jmpfar	d d
1657		pop	b
1658		pop	c
1659		pop	d
165a		sliu d #doprint_loop	[00]
165b		slil d #doprint_loop	[04]
165c		jalr	d d	

165d	#doprint_semicolon		; print a space separator and end

165d		sliu d 2
165e		slil d 0
165f		out	d	

1660		sliu d #doprint_done	[09]
1661		slil d #doprint_done	[09]
1662		jalr	d d	

1663	#doprint_comma		; print a space separator

1663		sliu d 2
1664		slil d 0
1665		out	d
1666		inc	c
1667		inc	c
1668		sliu d #doprint_loop	[00]
1669		slil d #doprint_loop	[04]
166a		jalr	d d	

166b	#doprint_eol		; print a newline and end

166b		sliu d 0
166c		slil d 13
166d		out	d
166e		sliu d 2
166f		slil d 0
1670		out	d
1671		sliu d #doprint_done	[09]
1672		slil d #doprint_done	[09]
1673		jalr	d d	

1674	#doprint_str		; advance past "

1674		inc	c		; read chars and print until reach other "

1675		load	a [c]
1676		push	a
1677		sliu d 2
1678		slil d 2
1679		sub	a d
167a		sliu d #@doPRINT4	[08]
167b		slil d #@doPRINT4	[02]
167c		skipz	a
167d		jalr	d d
167e		pop	a
167f		sliu d #doprint_str_done	[09]
1680		slil d #doprint_str_done	[04]
1681		jalr	d d
1682	#@doPRINT4
1682		pop	a
1683		push	a
1684		sliu d 0
1685		slil d 0
1686		sub	a d
1687		sliu d #@doPRINT5	[08]
1688		slil d #@doPRINT5	[0f]
1689		skipz	a
168a		jalr	d d
168b		pop	a
168c		sliu d #doprint_eol	[06]
168d		slil d #doprint_eol	[0b]
168e		jalr	d d
168f	#@doPRINT5
168f		pop	a
1690		out	a
1691		sliu d #doprint_str	[07]
1692		slil d #doprint_str	[04]
1693		jalr	d d
1694	#doprint_str_done
1694		inc	c
1695		inc	c
1696		sliu d #doprint_loop	[00]
1697		slil d #doprint_loop	[04]
1698		jalr	d d
1699	#doprint_done
1699		pop	d
169a		pop	c
169b		jmpfar	d d	
	; doPRINT ends
	
	

169c		org 1700	
	; ------- GLOBAL FUNCTION eval_expression -------

1700	#eval_expression
1700		pop	c
1701		push	d	
		;C points to expression, A returns value, 0xff returns new C
	
		;expression is: term | term + term [ + term ]* | term - term [ - term]*
	
		; stop if there's a pending error
	; calling global function error_marked

1702		push	d
1703		push	c
1704		push	b
1705		sliu d 1
1706		slil d 7
1707		push	d
1708		push	c
1709		sliu c 1
170a		slil c 12
170b		sliu d #error_marked	[01]
170c		slil d #error_marked	[01]
170d		jmpfar	d d
170e		pop	b
170f		pop	c
1710		pop	d
1711		sliu d #eval_expression_end	[0e]
1712		slil d #eval_expression_end	[01]
1713		skipz	a
1714		jalr	d d	
		; get the first term
	; calling global function eval_term

1715		push	d
1716		push	c
1717		push	b
1718		sliu d 1
1719		slil d 7
171a		push	d
171b		push	c
171c		sliu c 1
171d		slil c 8
171e		sliu d #eval_term	[00]
171f		slil d #eval_term	[00]
1720		jmpfar	d d
1721		pop	b
1722		pop	c
1723		pop	d
1724		sliu c 15
1725		slil c 15
1726		load	c [c]	

1727	#eval_expression_loop		; stop if an error

1727		push	a	; calling global function error_marked

1728		push	d
1729		push	c
172a		push	b
172b		sliu d 1
172c		slil d 7
172d		push	d
172e		push	c
172f		sliu c 1
1730		slil c 12
1731		sliu d #error_marked	[01]
1732		slil d #error_marked	[01]
1733		jmpfar	d d
1734		pop	b
1735		pop	c
1736		pop	d
1737		sliu d #eval_expression_errorstop	[0c]
1738		slil d #eval_expression_errorstop	[0b]
1739		skipz	a
173a		jalr	d d
173b		pop	a	
		; check for valid end tokens

173c		push	a
173d		load	b [c]
173e		push	c
173f		sliu d 7
1740		slil d 14
1741		page	d
1742		sliu c #endtokenlist	[0b]
1743		slil c #endtokenlist	[09]
1744	#eval_validloop
1744		load	a [c]
1745		push	a
1746		sub	a b
1747		sliu d #@eval_expression0	[04]
1748		slil d #@eval_expression0	[0f]
1749		skipz	a
174a		jalr	d d
174b		pop	a
174c		sliu d #eval_validend	[06]
174d		slil d #eval_validend	[01]
174e		jalr	d d
174f	#@eval_expression0
174f		pop	a
1750		push	a
1751		sliu d 0
1752		slil d 0
1753		sub	a d
1754		sliu d #@eval_expression1	[05]
1755		slil d #@eval_expression1	[0c]
1756		skipz	a
1757		jalr	d d
1758		pop	a
1759		sliu d #eval_notvalidend	[06]
175a		slil d #eval_notvalidend	[09]
175b		jalr	d d
175c	#@eval_expression1
175c		pop	a
175d		inc	c
175e		sliu d #eval_validloop	[04]
175f		slil d #eval_validloop	[04]
1760		jalr	d d	

1761	#eval_validend
1761		sliu d 15
1762		slil d 13
1763		page	d
1764		pop	c
1765		pop	a
1766		sliu d #eval_expression_end	[0e]
1767		slil d #eval_expression_end	[01]
1768		jalr	d d
1769	#eval_notvalidend
1769		sliu d 15
176a		slil d 13
176b		page	d
176c		pop	c
176d		pop	a		
		; check for arithmetic tokens: + or -

176e		load	b [c]
176f		sliu d 2
1770		slil d 11
1771		sub	b d
1772		sliu d #eval_expression_plusminus	[08]
1773		slil d #eval_expression_plusminus	[01]
1774		skipnz	b
1775		jalr	d d
1776		load	b [c]
1777		sliu d 2
1778		slil d 13
1779		sub	b d
177a		sliu d #eval_expression_plusminus	[08]
177b		slil d #eval_expression_plusminus	[01]
177c		skipnz	b
177d		jalr	d d	
		; otherwise error

177e		sliu d #eval_expression_error	[0d]
177f		slil d #eval_expression_error	[00]
1780		jalr	d d	

1781	#eval_expression_plusminus		; push operation

1781		load	b [c]
1782		push	b	
		; save current sum into b

1783		sub	b b
1784		add	b a	
		; move to next token

1785		inc	c		; if nothing after the plus then error

1786		load	a [c]
1787		sliu d #eval_expression_errorpopop	[0c]
1788		slil d #eval_expression_errorpopop	[0f]
1789		skipnz	a
178a		jalr	d d
178b		inc	c	
		; get the next term
	; calling global function eval_term

178c		push	d
178d		push	c
178e		push	b
178f		sliu d 1
1790		slil d 7
1791		push	d
1792		push	c
1793		sliu c 1
1794		slil c 8
1795		sliu d #eval_term	[00]
1796		slil d #eval_term	[00]
1797		jmpfar	d d
1798		pop	b
1799		pop	c
179a		pop	d
179b		sliu c 15
179c		slil c 15
179d		load	c [c]	
		; stop if an error

179e		push	a	; calling global function error_marked

179f		push	d
17a0		push	c
17a1		push	b
17a2		sliu d 1
17a3		slil d 7
17a4		push	d
17a5		push	c
17a6		sliu c 1
17a7		slil c 12
17a8		sliu d #error_marked	[01]
17a9		slil d #error_marked	[01]
17aa		jmpfar	d d
17ab		pop	b
17ac		pop	c
17ad		pop	d
17ae		sliu d #eval_expression_errorstoppop	[0c]
17af		slil d #eval_expression_errorstoppop	[0a]
17b0		skipz	a
17b1		jalr	d d
17b2		pop	a	

17b3		push	c		; reload the operation

17b4		pop	d
17b5		pop	c
17b6		push	d
17b7		sliu d 2
17b8		slil d 13
17b9		sub	c d
17ba		sliu d #eval_expression_sub	[0c]
17bb		slil d #eval_expression_sub	[03]
17bc		skipnz	c
17bd		jalr	d d		; add it

17be		add	a b
17bf		pop	c
17c0		sliu d #eval_expression_loop	[02]
17c1		slil d #eval_expression_loop	[07]
17c2		jalr	d d
17c3	#eval_expression_sub		; subtract it

17c3		sub	b a
17c4		sub	a a
17c5		add	a b
17c6		pop	c
17c7		sliu d #eval_expression_loop	[02]
17c8		slil d #eval_expression_loop	[07]
17c9		jalr	d d	

17ca	#eval_expression_errorstoppop
17ca		pop	d
17cb	#eval_expression_errorstop
17cb		pop	a
17cc		sliu d #eval_expression_end	[0e]
17cd		slil d #eval_expression_end	[01]
17ce		jalr	d d
17cf	#eval_expression_errorpopop
17cf		pop	d
17d0	#eval_expression_error
17d0		sliu a 0
17d1		slil a 1	; calling global function mark_error

17d2		push	d
17d3		push	c
17d4		push	b
17d5		sliu d 1
17d6		slil d 7
17d7		push	d
17d8		push	c
17d9		sliu c 1
17da		slil c 12
17db		sliu d #mark_error	[00]
17dc		slil d #mark_error	[00]
17dd		jmpfar	d d
17de		pop	b
17df		pop	c
17e0		pop	d
17e1	#eval_expression_end
17e1		sliu d 15
17e2		slil d 15
17e3		store	c [d]
17e4		pop	d
17e5		pop	c
17e6		jmpfar	d d	
	; eval_expression ends
	
	

17e7		org 1800	
	; ------- GLOBAL FUNCTION eval_term -------

1800	#eval_term
1800		pop	c
1801		push	d	
		;C points to expression, A returns value, 0xff returns new C
	
		;expression is: paren | paren * paren [ * paren ]* | paren / paren [ / paren]*
	
		; stop if there's a pending error
	; calling global function error_marked

1802		push	d
1803		push	c
1804		push	b
1805		sliu d 1
1806		slil d 8
1807		push	d
1808		push	c
1809		sliu c 1
180a		slil c 12
180b		sliu d #error_marked	[01]
180c		slil d #error_marked	[01]
180d		jmpfar	d d
180e		pop	b
180f		pop	c
1810		pop	d
1811		sliu d #eval_term_end	[0f]
1812		slil d #eval_term_end	[00]
1813		skipz	a
1814		jalr	d d	
		; get the first term
	; calling global function eval_paren

1815		push	d
1816		push	c
1817		push	b
1818		sliu d 1
1819		slil d 8
181a		push	d
181b		push	c
181c		sliu c 1
181d		slil c 9
181e		sliu d #eval_paren	[00]
181f		slil d #eval_paren	[00]
1820		jmpfar	d d
1821		pop	b
1822		pop	c
1823		pop	d
1824		sliu c 15
1825		slil c 15
1826		load	c [c]	

1827	#eval_term_loop		; stop if an error

1827		push	a	; calling global function error_marked

1828		push	d
1829		push	c
182a		push	b
182b		sliu d 1
182c		slil d 8
182d		push	d
182e		push	c
182f		sliu c 1
1830		slil c 12
1831		sliu d #error_marked	[01]
1832		slil d #error_marked	[01]
1833		jmpfar	d d
1834		pop	b
1835		pop	c
1836		pop	d
1837		sliu d #eval_term_errorstop	[0d]
1838		slil d #eval_term_errorstop	[0a]
1839		skipz	a
183a		jalr	d d
183b		pop	a	
		; check for end token 0x00

183c		load	b [c]
183d		sliu d #eval_term_end	[0f]
183e		slil d #eval_term_end	[00]
183f		skipnz	b
1840		jalr	d d		
		; check for arithmetic tokens: * or / or %

1841		load	b [c]		;* is 2a

1842		sliu d 2
1843		slil d 10
1844		sub	b d
1845		sliu d #eval_term_multdiv	[05]
1846		slil d #eval_term_multdiv	[0a]
1847		skipnz	b
1848		jalr	d d		;/ is 2f

1849		sliu d 0
184a		slil d 5
184b		sub	b d
184c		sliu d #eval_term_multdiv	[05]
184d		slil d #eval_term_multdiv	[0a]
184e		skipnz	b
184f		jalr	d d		;% is 25

1850		sliu d 0
1851		slil d 10
1852		add	b d
1853		sliu d #eval_term_multdiv	[05]
1854		slil d #eval_term_multdiv	[0a]
1855		skipnz	b
1856		jalr	d d	
		; otherwise done

1857		sliu d #eval_term_end	[0f]
1858		slil d #eval_term_end	[00]
1859		jalr	d d	

185a	#eval_term_multdiv		; save operation

185a		load	b [c]
185b		push	b	
		; save current product into b

185c		sub	b b
185d		add	b a	
		; move to next token

185e		inc	c		; if nothing after the * then error

185f		load	a [c]
1860		sliu d #eval_term_errorpop	[0d]
1861		slil d #eval_term_errorpop	[0e]
1862		skipnz	a
1863		jalr	d d
1864		inc	c	
		; get the next term
	; calling global function eval_paren

1865		push	d
1866		push	c
1867		push	b
1868		sliu d 1
1869		slil d 8
186a		push	d
186b		push	c
186c		sliu c 1
186d		slil c 9
186e		sliu d #eval_paren	[00]
186f		slil d #eval_paren	[00]
1870		jmpfar	d d
1871		pop	b
1872		pop	c
1873		pop	d
1874		sliu c 15
1875		slil c 15
1876		load	c [c]	
		; stop if an error

1877		push	a	; calling global function error_marked

1878		push	d
1879		push	c
187a		push	b
187b		sliu d 1
187c		slil d 8
187d		push	d
187e		push	c
187f		sliu c 1
1880		slil c 12
1881		sliu d #error_marked	[01]
1882		slil d #error_marked	[01]
1883		jmpfar	d d
1884		pop	b
1885		pop	c
1886		pop	d
1887		sliu d #eval_term_errorstoppop	[0d]
1888		slil d #eval_term_errorstoppop	[09]
1889		skipz	a
188a		jalr	d d
188b		pop	a	
		;swap a and b

188c		push	a
188d		push	b
188e		pop	a
188f		pop	b	

1890		pop	d
1891		push	c		; reload the operation

1892		sliu c 2
1893		slil c 15
1894		sub	c d
1895		sliu d #eval_term_div	[0b]
1896		slil d #eval_term_div	[03]
1897		skipnz	c
1898		jalr	d d
1899		sliu d 0
189a		slil d 10
189b		sub	c d
189c		sliu d #eval_term_mod	[0c]
189d		slil d #eval_term_mod	[06]
189e		skipnz	c
189f		jalr	d d		; multiply it
	; calling global function mul

18a0		push	d
18a1		push	c
18a2		push	b
18a3		sliu d 1
18a4		slil d 8
18a5		push	d
18a6		push	c
18a7		sliu c 0
18a8		slil c 8
18a9		sliu d #mul	[00]
18aa		slil d #mul	[00]
18ab		jmpfar	d d
18ac		pop	b
18ad		pop	c
18ae		pop	d
18af		pop	c
18b0		sliu d #eval_term_loop	[02]
18b1		slil d #eval_term_loop	[07]
18b2		jalr	d d
18b3	#eval_term_div		; divide it
	; calling global function div

18b3		push	d
18b4		push	c
18b5		push	b
18b6		sliu d 1
18b7		slil d 8
18b8		push	d
18b9		push	c
18ba		sliu c 0
18bb		slil c 7
18bc		sliu d #div	[00]
18bd		slil d #div	[00]
18be		jmpfar	d d
18bf		pop	b
18c0		pop	c
18c1		pop	d
18c2		pop	c
18c3		sliu d #eval_term_loop	[02]
18c4		slil d #eval_term_loop	[07]
18c5		jalr	d d
18c6	#eval_term_mod		; mod it
	; calling global function mod

18c6		push	d
18c7		push	c
18c8		push	b
18c9		sliu d 1
18ca		slil d 8
18cb		push	d
18cc		push	c
18cd		sliu c 0
18ce		slil c 7
18cf		sliu d #mod	[08]
18d0		slil d #mod	[05]
18d1		jmpfar	d d
18d2		pop	b
18d3		pop	c
18d4		pop	d
18d5		pop	c
18d6		sliu d #eval_term_loop	[02]
18d7		slil d #eval_term_loop	[07]
18d8		jalr	d d	

18d9	#eval_term_errorstoppop
18d9		pop	d
18da	#eval_term_errorstop
18da		pop	a
18db		sliu d #eval_term_end	[0f]
18dc		slil d #eval_term_end	[00]
18dd		jalr	d d
18de	#eval_term_errorpop
18de		pop	d
18df	#eval_term_error
18df		sliu a 0
18e0		slil a 1	; calling global function mark_error

18e1		push	d
18e2		push	c
18e3		push	b
18e4		sliu d 1
18e5		slil d 8
18e6		push	d
18e7		push	c
18e8		sliu c 1
18e9		slil c 12
18ea		sliu d #mark_error	[00]
18eb		slil d #mark_error	[00]
18ec		jmpfar	d d
18ed		pop	b
18ee		pop	c
18ef		pop	d
18f0	#eval_term_end
18f0		sliu d 15
18f1		slil d 15
18f2		store	c [d]
18f3		pop	d
18f4		pop	c
18f5		jmpfar	d d	
	; eval_term ends
	
	

18f6		org 1900	
	; ------- GLOBAL FUNCTION eval_paren -------

1900	#eval_paren
1900		pop	c
1901		push	d		;expression is: numvar | ( expression )
	
		; stop if there's a pending error
	; calling global function error_marked

1902		push	d
1903		push	c
1904		push	b
1905		sliu d 1
1906		slil d 9
1907		push	d
1908		push	c
1909		sliu c 1
190a		slil c 12
190b		sliu d #error_marked	[01]
190c		slil d #error_marked	[01]
190d		jmpfar	d d
190e		pop	b
190f		pop	c
1910		pop	d
1911		sliu d #eval_paren_end	[0a]
1912		slil d #eval_paren_end	[05]
1913		skipz	a
1914		jalr	d d	
		; is the first token a ( ?

1915		load	a [c]
1916		push	a
1917		sliu d 2
1918		slil d 8
1919		sub	a d
191a		sliu d #@eval_paren0	[02]
191b		slil d #@eval_paren0	[02]
191c		skipz	a
191d		jalr	d d
191e		pop	a
191f		sliu d #eval_paren_paren	[03]
1920		slil d #eval_paren_paren	[08]
1921		jalr	d d
1922	#@eval_paren0
1922		pop	a	
		; get the first term
	; calling global function eval_numorvar

1923		push	d
1924		push	c
1925		push	b
1926		sliu d 1
1927		slil d 9
1928		push	d
1929		push	c
192a		sliu c 1
192b		slil c 10
192c		sliu d #eval_numorvar	[00]
192d		slil d #eval_numorvar	[00]
192e		jmpfar	d d
192f		pop	b
1930		pop	c
1931		pop	d
1932		sliu c 15
1933		slil c 15
1934		load	c [c]
1935		sliu d #eval_paren_end	[0a]
1936		slil d #eval_paren_end	[05]
1937		jalr	d d	

1938	#eval_paren_paren		;advance to expression

1938		inc	c		;no eol allowed

1939		load	b [c]
193a		push	b
193b		sliu d 0
193c		slil d 0
193d		sub	b d
193e		sliu d #@eval_paren1	[04]
193f		slil d #@eval_paren1	[06]
1940		skipz	b
1941		jalr	d d
1942		pop	b
1943		sliu d #eval_paren_error	[09]
1944		slil d #eval_paren_error	[00]
1945		jalr	d d
1946	#@eval_paren1
1946		pop	b
1947		inc	c	
		;parse it
	; calling global function eval_expression

1948		push	d
1949		push	c
194a		push	b
194b		sliu d 1
194c		slil d 9
194d		push	d
194e		push	c
194f		sliu c 1
1950		slil c 7
1951		sliu d #eval_expression	[00]
1952		slil d #eval_expression	[00]
1953		jmpfar	d d
1954		pop	b
1955		pop	c
1956		pop	d
1957		sliu c 15
1958		slil c 15
1959		load	c [c]	
		;don't continue if an error

195a		push	a	; calling global function error_marked

195b		push	d
195c		push	c
195d		push	b
195e		sliu d 1
195f		slil d 9
1960		push	d
1961		push	c
1962		sliu c 1
1963		slil c 12
1964		sliu d #error_marked	[01]
1965		slil d #error_marked	[01]
1966		jmpfar	d d
1967		pop	b
1968		pop	c
1969		pop	d
196a		sliu d #eval_paren_stoperror	[0a]
196b		slil d #eval_paren_stoperror	[04]
196c		skipz	a
196d		jalr	d d
196e		pop	a	
		;there better be a ) next

196f		load	b [c]
1970		push	b
1971		sliu d 2
1972		slil d 9
1973		sub	b d
1974		sliu d #@eval_paren2	[07]
1975		slil d #@eval_paren2	[0c]
1976		skipnz	b
1977		jalr	d d
1978		pop	b
1979		sliu d #eval_paren_error	[09]
197a		slil d #eval_paren_error	[00]
197b		jalr	d d
197c	#@eval_paren2
197c		pop	b
197d		inc	c
197e		load	b [c]
197f		push	b
1980		sliu d 0
1981		slil d 0
1982		sub	b d
1983		sliu d #@eval_paren3	[08]
1984		slil d #@eval_paren3	[0b]
1985		skipz	b
1986		jalr	d d
1987		pop	b
1988		sliu d #eval_paren_end	[0a]
1989		slil d #eval_paren_end	[05]
198a		jalr	d d
198b	#@eval_paren3
198b		pop	b
198c		inc	c
198d		sliu d #eval_paren_end	[0a]
198e		slil d #eval_paren_end	[05]
198f		jalr	d d	

1990	#eval_paren_error
1990		sliu a 0
1991		slil a 1	; calling global function mark_error

1992		push	d
1993		push	c
1994		push	b
1995		sliu d 1
1996		slil d 9
1997		push	d
1998		push	c
1999		sliu c 1
199a		slil c 12
199b		sliu d #mark_error	[00]
199c		slil d #mark_error	[00]
199d		jmpfar	d d
199e		pop	b
199f		pop	c
19a0		pop	d
19a1		sliu d #eval_paren_end	[0a]
19a2		slil d #eval_paren_end	[05]
19a3		jalr	d d
19a4	#eval_paren_stoperror
19a4		pop	a
19a5	#eval_paren_end
19a5		sliu d 15
19a6		slil d 15
19a7		store	c [d]
19a8		pop	d
19a9		pop	c
19aa		jmpfar	d d	
	; eval_paren ends
	
	

19ab		org 1a00	
	; ------- GLOBAL FUNCTION eval_numorvar -------

1a00	#eval_numorvar
1a00		pop	c
1a01		push	d	
		; parses an integer token or returns a variable value
	
		; stop if there's a pending error
	; calling global function error_marked

1a02		push	d
1a03		push	c
1a04		push	b
1a05		sliu d 1
1a06		slil d 10
1a07		push	d
1a08		push	c
1a09		sliu c 1
1a0a		slil c 12
1a0b		sliu d #error_marked	[01]
1a0c		slil d #error_marked	[01]
1a0d		jmpfar	d d
1a0e		pop	b
1a0f		pop	c
1a10		pop	d
1a11		push	a
1a12		sliu d 0
1a13		slil d 0
1a14		sub	a d
1a15		sliu d #@eval_numorvar0	[01]
1a16		slil d #@eval_numorvar0	[0d]
1a17		skipnz	a
1a18		jalr	d d
1a19		pop	a
1a1a		sliu d #eval_numorvar_end	[0d]
1a1b		slil d #eval_numorvar_end	[00]
1a1c		jalr	d d
1a1d	#@eval_numorvar0
1a1d		pop	a	
		; up to three numbers
		; get the first

1a1e		load	a [c]	
		; check for var

1a1f		push	a
1a20		sliu d 2
1a21		slil d 3
1a22		sub	a d
1a23		sliu d #@eval_numorvar1	[02]
1a24		slil d #@eval_numorvar1	[0b]
1a25		skipz	a
1a26		jalr	d d
1a27		pop	a
1a28		sliu d #eval_numorvar_var	[0b]
1a29		slil d #eval_numorvar_var	[0e]
1a2a		jalr	d d
1a2b	#@eval_numorvar1
1a2b		pop	a	
		; check for not number or var

1a2c		push	a
1a2d		sliu d 3
1a2e		slil d 0
1a2f		sub	a d
1a30		sliu d #@eval_numorvar2	[03]
1a31		slil d #@eval_numorvar2	[08]
1a32		skipl	a
1a33		jalr	d d
1a34		pop	a
1a35		sliu d #eval_numorvar_error	[0a]
1a36		slil d #eval_numorvar_error	[0a]
1a37		jalr	d d
1a38	#@eval_numorvar2
1a38		pop	a
1a39		push	a
1a3a		sliu d 3
1a3b		slil d 9
1a3c		sub	a d
1a3d		sub	d d
1a3e		sub	d a
1a3f		sub	a a
1a40		add	a d
1a41		sliu d #@eval_numorvar3	[04]
1a42		slil d #@eval_numorvar3	[09]
1a43		skipl	a
1a44		jalr	d d
1a45		pop	a
1a46		sliu d #eval_numorvar_error	[0a]
1a47		slil d #eval_numorvar_error	[0a]
1a48		jalr	d d
1a49	#@eval_numorvar3
1a49		pop	a	
		; adjust from ascii

1a4a		sliu b 3
1a4b		slil b 0
1a4c		sub	a b
1a4d		inc	c		; get tens place

1a4e		load	b [c]		; stop if space

1a4f		push	b
1a50		sliu d 2
1a51		slil d 0
1a52		sub	b d
1a53		sliu d #@eval_numorvar4	[05]
1a54		slil d #@eval_numorvar4	[0b]
1a55		skipz	b
1a56		jalr	d d
1a57		pop	b
1a58		sliu d #eval_numorvar_numdone	[09]
1a59		slil d #eval_numorvar_numdone	[08]
1a5a		jalr	d d
1a5b	#@eval_numorvar4
1a5b		pop	b		; multiply hundreds place by 10

1a5c		sliu b 0
1a5d		slil b 10	; calling global function mul

1a5e		push	d
1a5f		push	c
1a60		push	b
1a61		sliu d 1
1a62		slil d 10
1a63		push	d
1a64		push	c
1a65		sliu c 0
1a66		slil c 8
1a67		sliu d #mul	[00]
1a68		slil d #mul	[00]
1a69		jmpfar	d d
1a6a		pop	b
1a6b		pop	c
1a6c		pop	d		; reload tens place and add it

1a6d		load	b [c]
1a6e		add	a b
1a6f		sliu b 3
1a70		slil b 0
1a71		sub	a b
1a72		inc	c		; get ones place

1a73		load	b [c]		; stop if space

1a74		push	b
1a75		sliu d 2
1a76		slil d 0
1a77		sub	b d
1a78		sliu d #@eval_numorvar5	[08]
1a79		slil d #@eval_numorvar5	[00]
1a7a		skipz	b
1a7b		jalr	d d
1a7c		pop	b
1a7d		sliu d #eval_numorvar_numdone	[09]
1a7e		slil d #eval_numorvar_numdone	[08]
1a7f		jalr	d d
1a80	#@eval_numorvar5
1a80		pop	b		; multiply 100s and 10s by 10

1a81		sliu b 0
1a82		slil b 10	; calling global function mul

1a83		push	d
1a84		push	c
1a85		push	b
1a86		sliu d 1
1a87		slil d 10
1a88		push	d
1a89		push	c
1a8a		sliu c 0
1a8b		slil c 8
1a8c		sliu d #mul	[00]
1a8d		slil d #mul	[00]
1a8e		jmpfar	d d
1a8f		pop	b
1a90		pop	c
1a91		pop	d
1a92		load	b [c]
1a93		add	a b
1a94		sliu b 3
1a95		slil b 0
1a96		sub	a b
1a97		inc	c	

1a98	#eval_numorvar_numdone		; next thing should be space or eol

1a98		load	b [c]
1a99		push	b
1a9a		sliu d 0
1a9b		slil d 0
1a9c		sub	b d
1a9d		sliu d #@eval_numorvar6	[0a]
1a9e		slil d #@eval_numorvar6	[05]
1a9f		skipz	b
1aa0		jalr	d d
1aa1		pop	b
1aa2		sliu d #eval_numorvar_end	[0d]
1aa3		slil d #eval_numorvar_end	[00]
1aa4		jalr	d d
1aa5	#@eval_numorvar6
1aa5		pop	b
1aa6		inc	c
1aa7		sliu d #eval_numorvar_end	[0d]
1aa8		slil d #eval_numorvar_end	[00]
1aa9		jalr	d d
1aaa	#eval_numorvar_error
1aaa		sliu a 0
1aab		slil a 1	; calling global function mark_error

1aac		push	d
1aad		push	c
1aae		push	b
1aaf		sliu d 1
1ab0		slil d 10
1ab1		push	d
1ab2		push	c
1ab3		sliu c 1
1ab4		slil c 12
1ab5		sliu d #mark_error	[00]
1ab6		slil d #mark_error	[00]
1ab7		jmpfar	d d
1ab8		pop	b
1ab9		pop	c
1aba		pop	d
1abb		sliu d #eval_numorvar_end	[0d]
1abc		slil d #eval_numorvar_end	[00]
1abd		jalr	d d
1abe	#eval_numorvar_var	; calling global function eval_var

1abe		push	d
1abf		push	c
1ac0		push	b
1ac1		sliu d 1
1ac2		slil d 10
1ac3		push	d
1ac4		push	c
1ac5		sliu c 1
1ac6		slil c 11
1ac7		sliu d #eval_var	[08]
1ac8		slil d #eval_var	[02]
1ac9		jmpfar	d d
1aca		pop	b
1acb		pop	c
1acc		pop	d
1acd		sliu c 15
1ace		slil c 15
1acf		load	c [c]
1ad0	#eval_numorvar_end
1ad0		sliu d 15
1ad1		slil d 15
1ad2		store	c [d]
1ad3		pop	d
1ad4		pop	c
1ad5		jmpfar	d d	
	; eval_numorvar ends
	
	

1ad6		org 1b00	
	; ------- GLOBAL FUNCTION print_integer -------

1b00	#print_integer
1b00		pop	c
1b01		push	d		; prints integer in A

1b02		sliu c 0
1b03		slil c 0
1b04		push	a
1b05		sliu b 6
1b06		slil b 4	; calling global function div

1b07		push	d
1b08		push	c
1b09		push	b
1b0a		sliu d 1
1b0b		slil d 11
1b0c		push	d
1b0d		push	c
1b0e		sliu c 0
1b0f		slil c 7
1b10		sliu d #div	[00]
1b11		slil d #div	[00]
1b12		jmpfar	d d
1b13		pop	b
1b14		pop	c
1b15		pop	d
1b16		push	a
1b17		sliu d 0
1b18		slil d 0
1b19		sub	a d
1b1a		sliu d #@print_integer0	[02]
1b1b		slil d #@print_integer0	[02]
1b1c		skipz	a
1b1d		jalr	d d
1b1e		pop	a
1b1f		sliu d #print_value_tens	[02]
1b20		slil d #print_value_tens	[09]
1b21		jalr	d d
1b22	#@print_integer0
1b22		pop	a
1b23		sliu b 3
1b24		slil b 0
1b25		add	a b
1b26		out	a
1b27		sliu c 0
1b28		slil c 1
1b29	#print_value_tens
1b29		pop	a
1b2a		push	a
1b2b		sliu b 0
1b2c		slil b 10	; calling global function div

1b2d		push	d
1b2e		push	c
1b2f		push	b
1b30		sliu d 1
1b31		slil d 11
1b32		push	d
1b33		push	c
1b34		sliu c 0
1b35		slil c 7
1b36		sliu d #div	[00]
1b37		slil d #div	[00]
1b38		jmpfar	d d
1b39		pop	b
1b3a		pop	c
1b3b		pop	d	; calling global function mod

1b3c		push	d
1b3d		push	c
1b3e		push	b
1b3f		sliu d 1
1b40		slil d 11
1b41		push	d
1b42		push	c
1b43		sliu c 0
1b44		slil c 7
1b45		sliu d #mod	[08]
1b46		slil d #mod	[05]
1b47		jmpfar	d d
1b48		pop	b
1b49		pop	c
1b4a		pop	d
1b4b		push	c
1b4c		sliu d 0
1b4d		slil d 1
1b4e		sub	c d
1b4f		sliu d #@print_integer1	[05]
1b50		slil d #@print_integer1	[07]
1b51		skipz	c
1b52		jalr	d d
1b53		pop	c
1b54		sliu d #print_value_tens_doprint	[06]
1b55		slil d #print_value_tens_doprint	[05]
1b56		jalr	d d
1b57	#@print_integer1
1b57		pop	c
1b58		push	a
1b59		sliu d 0
1b5a		slil d 0
1b5b		sub	a d
1b5c		sliu d #@print_integer2	[06]
1b5d		slil d #@print_integer2	[04]
1b5e		skipz	a
1b5f		jalr	d d
1b60		pop	a
1b61		sliu d #print_value_ones	[06]
1b62		slil d #print_value_ones	[09]
1b63		jalr	d d
1b64	#@print_integer2
1b64		pop	a
1b65	#print_value_tens_doprint
1b65		sliu b 3
1b66		slil b 0
1b67		add	a b
1b68		out	a
1b69	#print_value_ones
1b69		pop	a
1b6a		sliu b 0
1b6b		slil b 10	; calling global function mod

1b6c		push	d
1b6d		push	c
1b6e		push	b
1b6f		sliu d 1
1b70		slil d 11
1b71		push	d
1b72		push	c
1b73		sliu c 0
1b74		slil c 7
1b75		sliu d #mod	[08]
1b76		slil d #mod	[05]
1b77		jmpfar	d d
1b78		pop	b
1b79		pop	c
1b7a		pop	d
1b7b		sliu b 3
1b7c		slil b 0
1b7d		add	a b
1b7e		out	a
1b7f		pop	d
1b80		pop	c
1b81		jmpfar	d d	
	; print_integer ends
	
	
	
	; ------- GLOBAL FUNCTION eval_var -------

1b82	#eval_var
1b82		pop	c
1b83		push	d		;look up the variable

1b84		sub	b b
1b85		add	b c	; calling global function getvar

1b86		push	d
1b87		push	c
1b88		push	b
1b89		sliu d 1
1b8a		slil d 11
1b8b		push	d
1b8c		push	c
1b8d		sliu c 1
1b8e		slil c 13
1b8f		sliu d #getvar	[05]
1b90		slil d #getvar	[0d]
1b91		jmpfar	d d
1b92		pop	b
1b93		pop	c
1b94		pop	d
1b95		push	a		; advance to whitespace

1b96	#eval_var_loop
1b96		inc	c
1b97		load	a [c]
1b98		push	a
1b99		sliu d 2
1b9a		slil d 0
1b9b		sub	a d
1b9c		sliu d #@eval_var0	[0a]
1b9d		slil d #@eval_var0	[04]
1b9e		skipz	a
1b9f		jalr	d d
1ba0		pop	a
1ba1		sliu d #eval_var_loop_incdone	[0b]
1ba2		slil d #eval_var_loop_incdone	[05]
1ba3		jalr	d d
1ba4	#@eval_var0
1ba4		pop	a
1ba5		push	a
1ba6		sliu d 0
1ba7		slil d 0
1ba8		sub	a d
1ba9		sliu d #@eval_var1	[0b]
1baa		slil d #@eval_var1	[01]
1bab		skipz	a
1bac		jalr	d d
1bad		pop	a
1bae		sliu d #eval_var_loop_done	[0b]
1baf		slil d #eval_var_loop_done	[06]
1bb0		jalr	d d
1bb1	#@eval_var1
1bb1		pop	a
1bb2		sliu d #eval_var_loop	[09]
1bb3		slil d #eval_var_loop	[06]
1bb4		jalr	d d
1bb5	#eval_var_loop_incdone
1bb5		inc	c
1bb6	#eval_var_loop_done
1bb6		sliu d 15
1bb7		slil d 15
1bb8		store	c [d]
1bb9		pop	a
1bba		pop	d
1bbb		pop	c
1bbc		jmpfar	d d	
	; eval_var ends
	
	
	

1bbd		org 1c00	
	; ------- GLOBAL FUNCTION mark_error -------

1c00	#mark_error
1c00		pop	c
1c01		push	d		; function is called if a syntax error was detected

1c02		sliu b 2
1c03		slil b 1
1c04		out	b
1c05		sliu d 13
1c06		slil d 1
1c07		page	d
1c08		sliu d 0
1c09		slil d 1
1c0a		store	a [d]
1c0b		sliu d 15
1c0c		slil d 13
1c0d		page	d
1c0e		pop	d
1c0f		pop	c
1c10		jmpfar	d d	
	; mark_error ends
	
	
	; ------- GLOBAL FUNCTION error_marked -------

1c11	#error_marked
1c11		pop	c
1c12		push	d		; function returna A!=0 if an error was previously detected

1c13		sliu d 13
1c14		slil d 1
1c15		page	d
1c16		sliu d 0
1c17		slil d 1
1c18		load	a [d]
1c19		sliu d 15
1c1a		slil d 13
1c1b		page	d	;	li	a,0

1c1c		pop	d
1c1d		pop	c
1c1e		jmpfar	d d	
	; error_marked ends
	
	
	; ------- GLOBAL FUNCTION clear_error -------

1c1f	#clear_error
1c1f		pop	c
1c20		push	d		; function clears error codes

1c21		sliu d 13
1c22		slil d 1
1c23		page	d
1c24		sliu d 0
1c25		slil d 1
1c26		sub	c c
1c27		store	c [d]
1c28		sliu d 15
1c29		slil d 13
1c2a		page	d
1c2b		pop	d
1c2c		pop	c
1c2d		jmpfar	d d	
	; clear_error ends
	
	
	; ------- GLOBAL FUNCTION printerror -------

1c2e	#printerror
1c2e		pop	c
1c2f		push	d
1c30		sliu d 13
1c31		slil d 1
1c32		page	d
1c33		sliu d 0
1c34		slil d 1
1c35		load	c [d]
1c36		push	c
1c37		sliu d 0
1c38		slil d 1
1c39		sub	c d
1c3a		sliu d #@printerror0	[04]
1c3b		slil d #@printerror0	[02]
1c3c		skipz	c
1c3d		jalr	d d
1c3e		pop	c
1c3f		sliu d #printerror_syntax	[07]
1c40		slil d #printerror_syntax	[0a]
1c41		jalr	d d
1c42	#@printerror0
1c42		pop	c
1c43		push	c
1c44		sliu d 0
1c45		slil d 2
1c46		sub	c d
1c47		sliu d #@printerror1	[04]
1c48		slil d #@printerror1	[0f]
1c49		skipz	c
1c4a		jalr	d d
1c4b		pop	c
1c4c		sliu d #printerror_undefinedvar	[09]
1c4d		slil d #printerror_undefinedvar	[00]
1c4e		jalr	d d
1c4f	#@printerror1
1c4f		pop	c
1c50		push	c
1c51		sliu d 0
1c52		slil d 3
1c53		sub	c d
1c54		sliu d #@printerror2	[05]
1c55		slil d #@printerror2	[0c]
1c56		skipz	c
1c57		jalr	d d
1c58		pop	c
1c59		sliu d #printerror_undefinedcommand	[0a]
1c5a		slil d #printerror_undefinedcommand	[06]
1c5b		jalr	d d
1c5c	#@printerror2
1c5c		pop	c
1c5d		push	c
1c5e		sliu d 0
1c5f		slil d 5
1c60		sub	c d
1c61		sliu d #@printerror3	[06]
1c62		slil d #@printerror3	[09]
1c63		skipz	c
1c64		jalr	d d
1c65		pop	c
1c66		sliu d #printerror_return	[0b]
1c67		slil d #printerror_return	[0c]
1c68		jalr	d d
1c69	#@printerror3
1c69		pop	c
1c6a		push	c
1c6b		sliu d 0
1c6c		slil d 6
1c6d		sub	c d
1c6e		sliu d #@printerror4	[07]
1c6f		slil d #@printerror4	[06]
1c70		skipz	c
1c71		jalr	d d
1c72		pop	c
1c73		sliu d #printerror_gosub	[0d]
1c74		slil d #printerror_gosub	[02]
1c75		jalr	d d
1c76	#@printerror4
1c76		pop	c
1c77		sliu d #printerror_done	[0e]
1c78		slil d #printerror_done	[08]
1c79		jalr	d d
1c7a	#printerror_syntax
1c7a		sliu a 7
1c7b		slil a 15
1c7c		sliu b #syntax_error	[03]
1c7d		slil b #syntax_error	[01]	; calling global function printstring

1c7e		push	d
1c7f		push	c
1c80		push	b
1c81		sliu d 1
1c82		slil d 12
1c83		push	d
1c84		push	c
1c85		sliu c 0
1c86		slil c 5
1c87		sliu d #printstring	[00]
1c88		slil d #printstring	[00]
1c89		jmpfar	d d
1c8a		pop	b
1c8b		pop	c
1c8c		pop	d
1c8d		sliu d #printerror_done	[0e]
1c8e		slil d #printerror_done	[08]
1c8f		jalr	d d
1c90	#printerror_undefinedvar
1c90		sliu a 7
1c91		slil a 15
1c92		sliu b #undefinedvar_error	[03]
1c93		slil b #undefinedvar_error	[0e]	; calling global function printstring

1c94		push	d
1c95		push	c
1c96		push	b
1c97		sliu d 1
1c98		slil d 12
1c99		push	d
1c9a		push	c
1c9b		sliu c 0
1c9c		slil c 5
1c9d		sliu d #printstring	[00]
1c9e		slil d #printstring	[00]
1c9f		jmpfar	d d
1ca0		pop	b
1ca1		pop	c
1ca2		pop	d
1ca3		sliu d #printerror_done	[0e]
1ca4		slil d #printerror_done	[08]
1ca5		jalr	d d
1ca6	#printerror_undefinedcommand
1ca6		sliu a 7
1ca7		slil a 15
1ca8		sliu b #undefinedcommand_error	[05]
1ca9		slil b #undefinedcommand_error	[01]	; calling global function printstring

1caa		push	d
1cab		push	c
1cac		push	b
1cad		sliu d 1
1cae		slil d 12
1caf		push	d
1cb0		push	c
1cb1		sliu c 0
1cb2		slil c 5
1cb3		sliu d #printstring	[00]
1cb4		slil d #printstring	[00]
1cb5		jmpfar	d d
1cb6		pop	b
1cb7		pop	c
1cb8		pop	d
1cb9		sliu d #printerror_done	[0e]
1cba		slil d #printerror_done	[08]
1cbb		jalr	d d
1cbc	#printerror_return
1cbc		sliu a 7
1cbd		slil a 15
1cbe		sliu b #return_error	[06]
1cbf		slil b #return_error	[01]	; calling global function printstring

1cc0		push	d
1cc1		push	c
1cc2		push	b
1cc3		sliu d 1
1cc4		slil d 12
1cc5		push	d
1cc6		push	c
1cc7		sliu c 0
1cc8		slil c 5
1cc9		sliu d #printstring	[00]
1cca		slil d #printstring	[00]
1ccb		jmpfar	d d
1ccc		pop	b
1ccd		pop	c
1cce		pop	d
1ccf		sliu d #printerror_done	[0e]
1cd0		slil d #printerror_done	[08]
1cd1		jalr	d d
1cd2	#printerror_gosub
1cd2		sliu a 7
1cd3		slil a 15
1cd4		sliu b #gosub_error	[07]
1cd5		slil b #gosub_error	[06]	; calling global function printstring

1cd6		push	d
1cd7		push	c
1cd8		push	b
1cd9		sliu d 1
1cda		slil d 12
1cdb		push	d
1cdc		push	c
1cdd		sliu c 0
1cde		slil c 5
1cdf		sliu d #printstring	[00]
1ce0		slil d #printstring	[00]
1ce1		jmpfar	d d
1ce2		pop	b
1ce3		pop	c
1ce4		pop	d
1ce5		sliu d #printerror_done	[0e]
1ce6		slil d #printerror_done	[08]
1ce7		jalr	d d
1ce8	#printerror_done
1ce8		pop	d
1ce9		pop	c
1cea		jmpfar	d d	
	; printerror ends
	
	

1ceb		org 1d00	
	; variable storage at page d0
	;	d000 holds addr of next empty var entry
	
	
	; ------- GLOBAL FUNCTION initvar -------

1d00	#initvar
1d00		pop	c
1d01		push	d
1d02		sliu d 13
1d03		slil d 0
1d04		page	d
1d05		sub	d d
1d06		sliu c 0
1d07		slil c 1
1d08		store	c [d]
1d09		store	d [c]
1d0a		pop	d
1d0b		pop	c
1d0c		jmpfar	d d	
	; initvar ends
	
	
	
	; ------- GLOBAL FUNCTION setvar -------

1d0d	#setvar
1d0d		pop	c
1d0e		push	d		; input: fd:B points to variable name, A holds value
		; if variable doesn't exist, make it
	

1d0f		sub	c c
1d10		add	c a	; calling global function lookupvar

1d11		push	d
1d12		push	c
1d13		push	b
1d14		sliu d 1
1d15		slil d 13
1d16		push	d
1d17		push	c
1d18		sliu c 1
1d19		slil c 13
1d1a		sliu d #lookupvar	[09]
1d1b		slil d #lookupvar	[09]
1d1c		jmpfar	d d
1d1d		pop	b
1d1e		pop	c
1d1f		pop	d
1d20		push	a
1d21		sliu d 0
1d22		slil d 0
1d23		sub	a d
1d24		sliu d #@setvar0	[02]
1d25		slil d #@setvar0	[0c]
1d26		skipnz	a
1d27		jalr	d d
1d28		pop	a
1d29		sliu d #setvar_set	[05]
1d2a		slil d #setvar_set	[03]
1d2b		jalr	d d
1d2c	#@setvar0
1d2c		pop	a
1d2d		push	c		; find place for new var

1d2e		sliu d 13
1d2f		slil d 0
1d30		page	d
1d31		sub	d d
1d32		load	c [d]		; advance past #

1d33		inc	b		; copy var name

1d34	#setvar_copyname
1d34		sliu d 15
1d35		slil d 13
1d36		page	d
1d37		load	a [b]
1d38		sliu d 13
1d39		slil d 0
1d3a		page	d
1d3b		store	a [c]
1d3c		inc	b
1d3d		inc	c
1d3e		push	a
1d3f		sliu d 2
1d40		slil d 0
1d41		sub	a d
1d42		sliu d #@setvar1	[04]
1d43		slil d #@setvar1	[0a]
1d44		skipnz	a
1d45		jalr	d d
1d46		pop	a
1d47		sliu d #setvar_copyname	[03]
1d48		slil d #setvar_copyname	[04]
1d49		jalr	d d
1d4a	#@setvar1
1d4a		pop	a		; set the value

1d4b		pop	a
1d4c		store	a [c]
1d4d		inc	c		; update the lastvar pointer

1d4e		sub	d d
1d4f		store	c [d]
1d50		sliu d #setvar_done	[05]
1d51		slil d #setvar_done	[07]
1d52		jalr	d d
1d53	#setvar_set
1d53		sliu d 13
1d54		slil d 0
1d55		page	d
1d56		store	c [a]
1d57	#setvar_done
1d57		sliu d 15
1d58		slil d 13
1d59		page	d
1d5a		pop	d
1d5b		pop	c
1d5c		jmpfar	d d	
	; setvar ends
	
	
	
	; ------- GLOBAL FUNCTION getvar -------

1d5d	#getvar
1d5d		pop	c
1d5e		push	d		; input: fd:B points to variable name
		; A returns value of variable.  error raised if no var
	; calling global function lookupvar

1d5f		push	d
1d60		push	c
1d61		push	b
1d62		sliu d 1
1d63		slil d 13
1d64		push	d
1d65		push	c
1d66		sliu c 1
1d67		slil c 13
1d68		sliu d #lookupvar	[09]
1d69		slil d #lookupvar	[09]
1d6a		jmpfar	d d
1d6b		pop	b
1d6c		pop	c
1d6d		pop	d
1d6e		push	a
1d6f		sliu d 0
1d70		slil d 0
1d71		sub	a d
1d72		sliu d #@getvar0	[07]
1d73		slil d #@getvar0	[0a]
1d74		skipz	a
1d75		jalr	d d
1d76		pop	a
1d77		sliu d #getvar_error	[08]
1d78		slil d #getvar_error	[02]
1d79		jalr	d d
1d7a	#@getvar0
1d7a		pop	a
1d7b		sliu d 13
1d7c		slil d 0
1d7d		page	d
1d7e		load	a [a]
1d7f		sliu d #getvar_done	[09]
1d80		slil d #getvar_done	[03]
1d81		jalr	d d	

1d82	#getvar_error
1d82		sliu a 0
1d83		slil a 2	; calling global function mark_error

1d84		push	d
1d85		push	c
1d86		push	b
1d87		sliu d 1
1d88		slil d 13
1d89		push	d
1d8a		push	c
1d8b		sliu c 1
1d8c		slil c 12
1d8d		sliu d #mark_error	[00]
1d8e		slil d #mark_error	[00]
1d8f		jmpfar	d d
1d90		pop	b
1d91		pop	c
1d92		pop	d
1d93	#getvar_done
1d93		sliu d 15
1d94		slil d 13
1d95		page	d
1d96		pop	d
1d97		pop	c
1d98		jmpfar	d d	
	; getvar ends
	
	
	
	; ------- GLOBAL FUNCTION lookupvar -------

1d99	#lookupvar
1d99		pop	c
1d9a		push	d		; input: fd:B points to variable name
		; A returns address of match, or 0 no match
	
		; move past #

1d9b		inc	b		; push var name start

1d9c		push	b		
		;first variable here

1d9d		sliu c 0
1d9e		slil c 1	

1d9f	#lookup_var_loop		; check if any more variables

1d9f		sliu d 13
1da0		slil d 0
1da1		page	d
1da2		sliu d 0
1da3		slil d 0
1da4		load	d [d]
1da5		push	c
1da6		sub	c d
1da7		sliu d #@lookupvar0	[0a]
1da8		slil d #@lookupvar0	[0f]
1da9		skipge	c
1daa		jalr	d d
1dab		pop	c
1dac		sliu d #lookup_var_nomatches	[0f]
1dad		slil d #lookup_var_nomatches	[08]
1dae		jalr	d d
1daf	#@lookupvar0
1daf		pop	c	
		; reset test name

1db0		pop	b
1db1		push	b
1db2	#lookup_var_charloop		;get char from test

1db2		sliu d 15
1db3		slil d 13
1db4		page	d
1db5		load	a [b]		;get char from varlist

1db6		push	b
1db7		sliu d 13
1db8		slil d 0
1db9		page	d
1dba		load	b [c]
1dbb		push	a
1dbc		sub	a b
1dbd		sliu d #@lookupvar1	[0c]
1dbe		slil d #@lookupvar1	[05]
1dbf		skipnz	a
1dc0		jalr	d d
1dc1		pop	a
1dc2		sliu d #lookup_var_nomatch	[0e]
1dc3		slil d #lookup_var_nomatch	[00]
1dc4		jalr	d d
1dc5	#@lookupvar1
1dc5		pop	a
1dc6		push	a
1dc7		sliu d 2
1dc8		slil d 0
1dc9		sub	a d
1dca		sliu d #@lookupvar2	[0d]
1dcb		slil d #@lookupvar2	[02]
1dcc		skipz	a
1dcd		jalr	d d
1dce		pop	a
1dcf		sliu d #lookup_var_yesmatch	[0d]
1dd0		slil d #lookup_var_yesmatch	[09]
1dd1		jalr	d d
1dd2	#@lookupvar2
1dd2		pop	a
1dd3		pop	b
1dd4		inc	b
1dd5		inc	c
1dd6		sliu d #lookup_var_charloop	[0b]
1dd7		slil d #lookup_var_charloop	[02]
1dd8		jalr	d d
1dd9	#lookup_var_yesmatch
1dd9		pop	b		; move pointer to value

1dda		inc	c
1ddb		sub	a a
1ddc		add	a c
1ddd		sliu d #lookup_var_done	[0f]
1dde		slil d #lookup_var_done	[09]
1ddf		jalr	d d
1de0	#lookup_var_nomatch
1de0		pop	b		;advance to next variable

1de1	#lookup_var_advanceloop
1de1		load	a [c]
1de2		push	a
1de3		sliu d 2
1de4		slil d 0
1de5		sub	a d
1de6		sliu d #@lookupvar3	[0e]
1de7		slil d #@lookupvar3	[0e]
1de8		skipz	a
1de9		jalr	d d
1dea		pop	a
1deb		sliu d #lookup_var_advanceend	[0f]
1dec		slil d #lookup_var_advanceend	[03]
1ded		jalr	d d
1dee	#@lookupvar3
1dee		pop	a
1def		inc	c
1df0		sliu d #lookup_var_advanceloop	[0e]
1df1		slil d #lookup_var_advanceloop	[01]
1df2		jalr	d d
1df3	#lookup_var_advanceend		; move to next var

1df3		inc	c
1df4		inc	c
1df5		sliu d #lookup_var_loop	[09]
1df6		slil d #lookup_var_loop	[0f]
1df7		jalr	d d	

1df8	#lookup_var_nomatches
1df8		sub	a a
1df9	#lookup_var_done
1df9		pop	b
1dfa		sliu d 15
1dfb		slil d 13
1dfc		page	d
1dfd		pop	d
1dfe		pop	c
1dff		jmpfar	d d	
	; lookupvar ends
	
	

1e00		org 1e00	
	; ------- GLOBAL FUNCTION doLET -------

1e00	#doLET
1e00		pop	c
1e01		push	d		; starting point is either 0x80 or 0x82, depending on whether keyword LET is present

1e02		sliu c 8
1e03		slil c 0
1e04		load	a [c]
1e05		push	a
1e06		sliu d 2
1e07		slil d 3
1e08		sub	a d
1e09		sliu d #@doLET0	[01]
1e0a		slil d #@doLET0	[01]
1e0b		skipz	a
1e0c		jalr	d d
1e0d		pop	a
1e0e		sliu d #doletadvance	[02]
1e0f		slil d #doletadvance	[02]
1e10		jalr	d d
1e11	#@doLET0
1e11		pop	a	
		; first thing should be a var name

1e12		sliu c 8
1e13		slil c 2
1e14		load	a [c]
1e15		push	a
1e16		sliu d 2
1e17		slil d 3
1e18		sub	a d
1e19		sliu d #@doLET1	[02]
1e1a		slil d #@doLET1	[01]
1e1b		skipnz	a
1e1c		jalr	d d
1e1d		pop	a
1e1e		sliu d #dolet_error	[0a]
1e1f		slil d #dolet_error	[05]
1e20		jalr	d d
1e21	#@doLET1
1e21		pop	a		
		; advance past the variable name to the ' '

1e22	#doletadvance
1e22		inc	c
1e23		load	a [c]
1e24		push	a
1e25		sliu d 0
1e26		slil d 0
1e27		sub	a d
1e28		sliu d #@doLET2	[03]
1e29		slil d #@doLET2	[00]
1e2a		skipz	a
1e2b		jalr	d d
1e2c		pop	a
1e2d		sliu d #dolet_error	[0a]
1e2e		slil d #dolet_error	[05]
1e2f		jalr	d d
1e30	#@doLET2
1e30		pop	a
1e31		push	a
1e32		sliu d 2
1e33		slil d 0
1e34		sub	a d
1e35		sliu d #@doLET3	[03]
1e36		slil d #@doLET3	[0d]
1e37		skipnz	a
1e38		jalr	d d
1e39		pop	a
1e3a		sliu d #doletadvance	[02]
1e3b		slil d #doletadvance	[02]
1e3c		jalr	d d
1e3d	#@doLET3
1e3d		pop	a	
		; next should be an =

1e3e		inc	c
1e3f		load	a [c]
1e40		push	a
1e41		sliu d 3
1e42		slil d 13
1e43		sub	a d
1e44		sliu d #@doLET4	[04]
1e45		slil d #@doLET4	[0c]
1e46		skipnz	a
1e47		jalr	d d
1e48		pop	a
1e49		sliu d #dolet_error	[0a]
1e4a		slil d #dolet_error	[05]
1e4b		jalr	d d
1e4c	#@doLET4
1e4c		pop	a	
		; advance to expression

1e4d		inc	c
1e4e		load	a [c]
1e4f		push	a
1e50		sliu d 0
1e51		slil d 0
1e52		sub	a d
1e53		sliu d #@doLET5	[05]
1e54		slil d #@doLET5	[0b]
1e55		skipz	a
1e56		jalr	d d
1e57		pop	a
1e58		sliu d #dolet_error	[0a]
1e59		slil d #dolet_error	[05]
1e5a		jalr	d d
1e5b	#@doLET5
1e5b		pop	a
1e5c		inc	c	
	; calling global function eval_expression

1e5d		push	d
1e5e		push	c
1e5f		push	b
1e60		sliu d 1
1e61		slil d 14
1e62		push	d
1e63		push	c
1e64		sliu c 1
1e65		slil c 7
1e66		sliu d #eval_expression	[00]
1e67		slil d #eval_expression	[00]
1e68		jmpfar	d d
1e69		pop	b
1e6a		pop	c
1e6b		pop	d		; stop if an error

1e6c		push	a	; calling global function error_marked

1e6d		push	d
1e6e		push	c
1e6f		push	b
1e70		sliu d 1
1e71		slil d 14
1e72		push	d
1e73		push	c
1e74		sliu c 1
1e75		slil c 12
1e76		sliu d #error_marked	[01]
1e77		slil d #error_marked	[01]
1e78		jmpfar	d d
1e79		pop	b
1e7a		pop	c
1e7b		pop	d
1e7c		sliu d #dolet_done	[0b]
1e7d		slil d #dolet_done	[06]
1e7e		skipz	a
1e7f		jalr	d d
1e80		pop	a	
		; assign the variable

1e81		sliu b 8
1e82		slil b 0
1e83		load	c [b]
1e84		push	c
1e85		sliu d 4
1e86		slil d 12
1e87		sub	c d
1e88		sliu d #@doLET6	[09]
1e89		slil d #@doLET6	[00]
1e8a		skipnz	c
1e8b		jalr	d d
1e8c		pop	c
1e8d		sliu d #dolet_letpresent	[09]
1e8e		slil d #dolet_letpresent	[03]
1e8f		jalr	d d
1e90	#@doLET6
1e90		pop	c
1e91		inc	b
1e92		inc	b
1e93	#dolet_letpresent	; calling global function setvar

1e93		push	d
1e94		push	c
1e95		push	b
1e96		sliu d 1
1e97		slil d 14
1e98		push	d
1e99		push	c
1e9a		sliu c 1
1e9b		slil c 13
1e9c		sliu d #setvar	[00]
1e9d		slil d #setvar	[0d]
1e9e		jmpfar	d d
1e9f		pop	b
1ea0		pop	c
1ea1		pop	d
1ea2		sliu d #dolet_done	[0b]
1ea3		slil d #dolet_done	[06]
1ea4		jalr	d d		

1ea5	#dolet_error
1ea5		sliu a 0
1ea6		slil a 1	; calling global function mark_error

1ea7		push	d
1ea8		push	c
1ea9		push	b
1eaa		sliu d 1
1eab		slil d 14
1eac		push	d
1ead		push	c
1eae		sliu c 1
1eaf		slil c 12
1eb0		sliu d #mark_error	[00]
1eb1		slil d #mark_error	[00]
1eb2		jmpfar	d d
1eb3		pop	b
1eb4		pop	c
1eb5		pop	d
1eb6	#dolet_done
1eb6		pop	d
1eb7		pop	c
1eb8		jmpfar	d d	
	; doLET ends
	
	
	
	; ------- GLOBAL FUNCTION doLIST -------

1eb9	#doLIST
1eb9		pop	c
1eba		push	d
1ebb		sliu c 9
1ebc		slil c 0
1ebd		sliu b 0
1ebe		slil b 0
1ebf	#doLIST_loop
1ebf		page	c
1ec0		load	a [b]
1ec1		sliu d #doLIST_skipline	[0d]
1ec2		slil d #doLIST_skipline	[0c]
1ec3		skipnz	a
1ec4		jalr	d d
1ec5		sliu a 0
1ec6		slil a 13
1ec7		out	a
1ec8		sliu a 2
1ec9		slil a 0
1eca		out	a
1ecb		sub	a a
1ecc		add	a c	; calling global function printstring

1ecd		push	d
1ece		push	c
1ecf		push	b
1ed0		sliu d 1
1ed1		slil d 14
1ed2		push	d
1ed3		push	c
1ed4		sliu c 0
1ed5		slil c 5
1ed6		sliu d #printstring	[00]
1ed7		slil d #printstring	[00]
1ed8		jmpfar	d d
1ed9		pop	b
1eda		pop	c
1edb		pop	d
1edc	#doLIST_skipline
1edc		sliu d 2
1edd		slil d 0
1ede		add	b d
1edf		sliu d #doLIST_loop	[0b]
1ee0		slil d #doLIST_loop	[0f]
1ee1		skipz	b
1ee2		jalr	d d
1ee3		inc	c
1ee4		push	c
1ee5		sliu d 11
1ee6		slil d 0
1ee7		sub	c d
1ee8		sliu d #@doLIST0	[0f]
1ee9		slil d #@doLIST0	[00]
1eea		skipnz	c
1eeb		jalr	d d
1eec		pop	c
1eed		sliu d #doLIST_loop	[0b]
1eee		slil d #doLIST_loop	[0f]
1eef		jalr	d d
1ef0	#@doLIST0
1ef0		pop	c
1ef1		pop	d
1ef2		pop	c
1ef3		jmpfar	d d	
	; doLIST ends
	
	

1ef4		org 1f00	
	; ------- GLOBAL FUNCTION doCLS -------

1f00	#doCLS
1f00		pop	c
1f01		push	d
1f02		sliu d 0
1f03		slil d 1
1f04		out	d
1f05		sliu d 8
1f06		slil d 0
1f07		out	d
1f08		sliu c 15
1f09		slil c 15
1f0a	#docls_delay
1f0a		sliu d #docls_delay	[00]
1f0b		slil d #docls_delay	[0a]
1f0c		dec	c
1f0d		skipz	c
1f0e		jalr	d d
1f0f		sliu d 2
1f10		slil d 0
1f11		out	d
1f12		pop	d
1f13		pop	c
1f14		jmpfar	d d	
	; doCLS ends
	
	

1f15		org 2000	
	; ------- GLOBAL FUNCTION basic_initrun -------

2000	#basic_initrun
2000		pop	c
2001		push	d		; set current line number to 0, error code to 0

2002		sliu d 13
2003		slil d 1
2004		page	d
2005		sub	c c
2006		sub	d d
2007		store	d [c]
2008		inc	c
2009		store	d [c]		; set basic stack to empty

200a		sliu d 13
200b		slil d 2
200c		page	d
200d		sub	c c
200e		sliu d 0
200f		slil d 1
2010		store	d [c]
2011		pop	d
2012		pop	c
2013		jmpfar	d d	
	; basic_initrun ends
	
	
	
	; ------- GLOBAL FUNCTION basic_getrunline -------

2014	#basic_getrunline
2014		pop	c
2015		push	d		; sets the current line number to the next line of the program and copies the line to fd80
		; returns A = 1 if end of program
	
		; use current line number to determine page and address

2016		sliu d 13
2017		slil d 1
2018		page	d
2019		sub	d d
201a		load	a [d]		; line number on stack

201b		push	a		; divide it by eight to get the page number into c

201c		push	a
201d		sliu d 15
201e		slil d 8
201f		nand	a d
2020		nand	a a
2021		sliu b 0
2022		slil b 8	; calling global function div_even

2023		push	d
2024		push	c
2025		push	b
2026		sliu d 2
2027		slil d 0
2028		push	d
2029		push	c
202a		sliu c 0
202b		slil c 7
202c		sliu d #div_even	[06]
202d		slil d #div_even	[0a]
202e		jmpfar	d d
202f		pop	b
2030		pop	c
2031		pop	d
2032		sliu d 11
2033		slil d 0
2034		add	a d
2035		sub	c c
2036		add	c a	
		; last three bits * 32 is the address

2037		pop	a
2038		sliu d 0
2039		slil d 7
203a		nand	a d
203b		nand	a a
203c		sliu b 2
203d		slil b 0	; calling global function mul

203e		push	d
203f		push	c
2040		push	b
2041		sliu d 2
2042		slil d 0
2043		push	d
2044		push	c
2045		sliu c 0
2046		slil c 8
2047		sliu d #mul	[00]
2048		slil d #mul	[00]
2049		jmpfar	d d
204a		pop	b
204b		pop	c
204c		pop	d	
		; put page in b, addr in c

204d		sub	b b
204e		add	b c
204f		sub	c c
2050		add	c a	
		; find next valid program line

2051		page	b
2052	#basic_getrun_findlineloop
2052		load	a [c]		; if valid, run it

2053		push	a
2054		sliu d 0
2055		slil d 0
2056		sub	a d
2057		sliu d #@basic_getrunline0	[05]
2058		slil d #@basic_getrunline0	[0f]
2059		skipnz	a
205a		jalr	d d
205b		pop	a
205c		sliu d #basic_getrunline_copy	[07]
205d		slil d #basic_getrunline_copy	[0c]
205e		jalr	d d
205f	#@basic_getrunline0
205f		pop	a	
		; advance line

2060		sliu d 2
2061		slil d 0
2062		add	c d		; increment line number on stack

2063		pop	a
2064		inc	a
2065		push	a
2066		sliu d #basic_getrun_findlineloop	[05]
2067		slil d #basic_getrun_findlineloop	[02]
2068		skipz	c
2069		jalr	d d		; advance page

206a		inc	b
206b		page	b
206c		push	b
206d		sliu d 13
206e		slil d 0
206f		sub	b d
2070		sliu d #@basic_getrunline1	[07]
2071		slil d #@basic_getrunline1	[08]
2072		skipz	b
2073		jalr	d d
2074		pop	b
2075		sliu d #basic_getrun_stop	[0a]
2076		slil d #basic_getrun_stop	[00]
2077		jalr	d d
2078	#@basic_getrunline1
2078		pop	b
2079		sliu d #basic_getrun_findlineloop	[05]
207a		slil d #basic_getrun_findlineloop	[02]
207b		jalr	d d	

207c	#basic_getrunline_copy		; copy line to fd80

207c		sub	b b
207d	#basic_getrunline_copyloop		; copy until 0

207d		load	a [c]
207e		push	a
207f		inc	c
2080		inc	b
2081		sliu d #basic_getrunline_copyloop	[07]
2082		slil d #basic_getrunline_copyloop	[0d]
2083		skipz	a
2084		jalr	d d	
		; set page to fd

2085		sliu d 15
2086		slil d 13
2087		page	d
2088		sliu d 8
2089		slil d 0
208a		add	b d
208b		dec	b
208c	#basic_getrunline_copyloop2		; pop until reach fd80

208c		pop	a
208d		store	a [b]
208e		dec	b
208f		push	b
2090		sliu d 7
2091		slil d 15
2092		sub	b d
2093		sliu d #@basic_getrunline2	[09]
2094		slil d #@basic_getrunline2	[0b]
2095		skipnz	b
2096		jalr	d d
2097		pop	b
2098		sliu d #basic_getrunline_copyloop2	[08]
2099		slil d #basic_getrunline_copyloop2	[0c]
209a		jalr	d d
209b	#@basic_getrunline2
209b		pop	b
209c		sub	a a
209d		sliu d #basic_getrun_done	[0a]
209e		slil d #basic_getrun_done	[02]
209f		jalr	d d	

20a0	#basic_getrun_stop
20a0		sliu a 0
20a1		slil a 1
20a2	#basic_getrun_done		; update line number

20a2		sliu d 13
20a3		slil d 1
20a4		page	d
20a5		sub	d d
20a6		pop	b
20a7		store	b [d]
20a8		sliu d 15
20a9		slil d 13
20aa		page	d
20ab		pop	d
20ac		pop	c
20ad		jmpfar	d d	
	; basic_getrunline ends
	
	

20ae		org 2100	
	; ------- GLOBAL FUNCTION basic_run -------

2100	#basic_run
2100		pop	c
2101		push	d
2102	#basic_runloop		; get the next line into fd80
	; calling global function basic_getrunline

2102		push	d
2103		push	c
2104		push	b
2105		sliu d 2
2106		slil d 1
2107		push	d
2108		push	c
2109		sliu c 2
210a		slil c 0
210b		sliu d #basic_getrunline	[01]
210c		slil d #basic_getrunline	[04]
210d		jmpfar	d d
210e		pop	b
210f		pop	c
2110		pop	d	

2111		push	a
2112		sliu d 0
2113		slil d 1
2114		sub	a d
2115		sliu d #@basic_run0	[01]
2116		slil d #@basic_run0	[0d]
2117		skipz	a
2118		jalr	d d
2119		pop	a
211a		sliu d #basic_run_stop	[07]
211b		slil d #basic_run_stop	[0f]
211c		jalr	d d
211d	#@basic_run0
211d		pop	a	
		; if it's an END then stop

211e		sliu c 8
211f		slil c 0
2120		load	a [c]
2121		push	a
2122		sliu d 4
2123		slil d 5
2124		sub	a d
2125		sliu d #@basic_run1	[02]
2126		slil d #@basic_run1	[0d]
2127		skipz	a
2128		jalr	d d
2129		pop	a
212a		sliu d #basic_run_stop	[07]
212b		slil d #basic_run_stop	[0f]
212c		jalr	d d
212d	#@basic_run1
212d		pop	a	
		; do the line
	; calling global function basic_doline

212e		push	d
212f		push	c
2130		push	b
2131		sliu d 2
2132		slil d 1
2133		push	d
2134		push	c
2135		sliu c 2
2136		slil c 7
2137		sliu d #basic_doline	[00]
2138		slil d #basic_doline	[00]
2139		jmpfar	d d
213a		pop	b
213b		pop	c
213c		pop	d	
		; if there's an error then stop
	; calling global function error_marked

213d		push	d
213e		push	c
213f		push	b
2140		sliu d 2
2141		slil d 1
2142		push	d
2143		push	c
2144		sliu c 1
2145		slil c 12
2146		sliu d #error_marked	[01]
2147		slil d #error_marked	[01]
2148		jmpfar	d d
2149		pop	b
214a		pop	c
214b		pop	d
214c		push	a
214d		sliu d 0
214e		slil d 0
214f		sub	a d
2150		sliu d #@basic_run2	[05]
2151		slil d #@basic_run2	[08]
2152		skipnz	a
2153		jalr	d d
2154		pop	a
2155		sliu d #basic_run_stop	[07]
2156		slil d #basic_run_stop	[0f]
2157		jalr	d d
2158	#@basic_run2
2158		pop	a	
		; advance one line

2159		sliu d 13
215a		slil d 1
215b		page	d
215c		sub	d d
215d		load	c [d]
215e		inc	c
215f		store	c [d]	
		; if reached end of program space, stop

2160		push	c
2161		sliu d 0
2162		slil d 0
2163		sub	c d
2164		sliu d #@basic_run3	[06]
2165		slil d #@basic_run3	[0c]
2166		skipz	c
2167		jalr	d d
2168		pop	c
2169		sliu d #basic_run_stop	[07]
216a		slil d #basic_run_stop	[0f]
216b		jalr	d d
216c	#@basic_run3
216c		pop	c	
		; check for CTRL-C

216d		sub	a a
216e		in	a
216f		push	a
2170		sliu d 0
2171		slil d 3
2172		sub	a d
2173		sliu d #@basic_run4	[07]
2174		slil d #@basic_run4	[0b]
2175		skipz	a
2176		jalr	d d
2177		pop	a
2178		sliu d #basic_run_stop	[07]
2179		slil d #basic_run_stop	[0f]
217a		jalr	d d
217b	#@basic_run4
217b		pop	a	

217c		sliu d #basic_runloop	[00]
217d		slil d #basic_runloop	[02]
217e		jalr	d d	

217f	#basic_run_stop	; calling global function clear_error

217f		push	d
2180		push	c
2181		push	b
2182		sliu d 2
2183		slil d 1
2184		push	d
2185		push	c
2186		sliu c 1
2187		slil c 12
2188		sliu d #clear_error	[01]
2189		slil d #clear_error	[0f]
218a		jmpfar	d d
218b		pop	b
218c		pop	c
218d		pop	d
218e		pop	d
218f		pop	c
2190		jmpfar	d d	
	; basic_run ends
	
	
	
	; ------- GLOBAL FUNCTION doRUN -------

2191	#doRUN
2191		pop	c
2192		push	d	; calling global function basic_initrun

2193		push	d
2194		push	c
2195		push	b
2196		sliu d 2
2197		slil d 1
2198		push	d
2199		push	c
219a		sliu c 2
219b		slil c 0
219c		sliu d #basic_initrun	[00]
219d		slil d #basic_initrun	[00]
219e		jmpfar	d d
219f		pop	b
21a0		pop	c
21a1		pop	d	; calling global function basic_run

21a2		push	d
21a3		push	c
21a4		push	b
21a5		sliu d 2
21a6		slil d 1
21a7		push	d
21a8		push	c
21a9		sliu c 2
21aa		slil c 1
21ab		sliu d #basic_run	[00]
21ac		slil d #basic_run	[00]
21ad		jmpfar	d d
21ae		pop	b
21af		pop	c
21b0		pop	d
21b1		pop	d
21b2		pop	c
21b3		jmpfar	d d	
	; doRUN ends
	
	

21b4		org 2200	
	; ------- GLOBAL FUNCTION doGOTO -------

2200	#doGOTO
2200		pop	c
2201		push	d
2202		sliu c 8
2203		slil c 2	; calling global function eval_expression

2204		push	d
2205		push	c
2206		push	b
2207		sliu d 2
2208		slil d 2
2209		push	d
220a		push	c
220b		sliu c 1
220c		slil c 7
220d		sliu d #eval_expression	[00]
220e		slil d #eval_expression	[00]
220f		jmpfar	d d
2210		pop	b
2211		pop	c
2212		pop	d
2213		push	a	; calling global function error_marked

2214		push	d
2215		push	c
2216		push	b
2217		sliu d 2
2218		slil d 2
2219		push	d
221a		push	c
221b		sliu c 1
221c		slil c 12
221d		sliu d #error_marked	[01]
221e		slil d #error_marked	[01]
221f		jmpfar	d d
2220		pop	b
2221		pop	c
2222		pop	d
2223		push	a
2224		sliu d 0
2225		slil d 0
2226		sub	a d
2227		sliu d #@doGOTO0	[02]
2228		slil d #@doGOTO0	[0f]
2229		skipnz	a
222a		jalr	d d
222b		pop	a
222c		sliu d #dogoto_enderror	[03]
222d		slil d #dogoto_enderror	[0a]
222e		jalr	d d
222f	#@doGOTO0
222f		pop	a
2230		pop	a
2231		sliu d 13
2232		slil d 1
2233		page	d
2234		sub	d d		; RUN will increment this

2235		dec	a
2236		store	a [d]
2237		sliu d #dogoto_end	[03]
2238		slil d #dogoto_end	[0b]
2239		jalr	d d
223a	#dogoto_enderror
223a		pop	a
223b	#dogoto_end
223b		sliu d 15
223c		slil d 13
223d		page	d
223e		pop	d
223f		pop	c
2240		jmpfar	d d	
	; doGOTO ends
	
	
	
	; ------- GLOBAL FUNCTION doGOSUB -------

2241	#doGOSUB
2241		pop	c
2242		push	d
2243		sliu c 8
2244		slil c 2	; calling global function eval_expression

2245		push	d
2246		push	c
2247		push	b
2248		sliu d 2
2249		slil d 2
224a		push	d
224b		push	c
224c		sliu c 1
224d		slil c 7
224e		sliu d #eval_expression	[00]
224f		slil d #eval_expression	[00]
2250		jmpfar	d d
2251		pop	b
2252		pop	c
2253		pop	d
2254		push	a	; calling global function error_marked

2255		push	d
2256		push	c
2257		push	b
2258		sliu d 2
2259		slil d 2
225a		push	d
225b		push	c
225c		sliu c 1
225d		slil c 12
225e		sliu d #error_marked	[01]
225f		slil d #error_marked	[01]
2260		jmpfar	d d
2261		pop	b
2262		pop	c
2263		pop	d
2264		push	a
2265		sliu d 0
2266		slil d 0
2267		sub	a d
2268		sliu d #@doGOSUB0	[07]
2269		slil d #@doGOSUB0	[00]
226a		skipnz	a
226b		jalr	d d
226c		pop	a
226d		sliu d #dogosub_enderror	[09]
226e		slil d #dogosub_enderror	[02]
226f		jalr	d d
2270	#@doGOSUB0
2270		pop	a
2271		pop	a
2272		sliu d 13
2273		slil d 1
2274		page	d
2275		sub	d d
2276		load	b [d]
2277		dec	a
2278		store	a [d]
2279		sliu d 13
227a		slil d 2
227b		page	d
227c		sub	d d
227d		load	d [d]
227e		store	b [d]
227f		inc	d
2280		push	d
2281		sliu d 0
2282		slil d 0
2283		sub	d d
2284		sliu d #@doGOSUB1	[08]
2285		slil d #@doGOSUB1	[0c]
2286		skipz	d
2287		jalr	d d
2288		pop	d
2289		sliu d #dogosub_error	[09]
228a		slil d #dogosub_error	[06]
228b		jalr	d d
228c	#@doGOSUB1
228c		pop	d
228d		sub	c c
228e		store	d [c]
228f		sliu d #dogosub_end	[0a]
2290		slil d #dogosub_end	[07]
2291		jalr	d d
2292	#dogosub_enderror
2292		pop	a
2293		sliu d #dogosub_end	[0a]
2294		slil d #dogosub_end	[07]
2295		jalr	d d
2296	#dogosub_error
2296		sliu a 0
2297		slil a 6	; calling global function mark_error

2298		push	d
2299		push	c
229a		push	b
229b		sliu d 2
229c		slil d 2
229d		push	d
229e		push	c
229f		sliu c 1
22a0		slil c 12
22a1		sliu d #mark_error	[00]
22a2		slil d #mark_error	[00]
22a3		jmpfar	d d
22a4		pop	b
22a5		pop	c
22a6		pop	d
22a7	#dogosub_end
22a7		sliu d 15
22a8		slil d 13
22a9		page	d
22aa		pop	d
22ab		pop	c
22ac		jmpfar	d d	
	; doGOSUB ends
	
	
	
	; ------- GLOBAL FUNCTION doRETURN -------

22ad	#doRETURN
22ad		pop	c
22ae		push	d
22af		sliu d 13
22b0		slil d 2
22b1		page	d
22b2		sub	c c
22b3		load	b [c]
22b4		dec	b
22b5		push	b
22b6		sliu d 0
22b7		slil d 0
22b8		sub	b d
22b9		sliu d #@doRETURN0	[0c]
22ba		slil d #@doRETURN0	[01]
22bb		skipz	b
22bc		jalr	d d
22bd		pop	b
22be		sliu d #doreturn_error	[0c]
22bf		slil d #doreturn_error	[0c]
22c0		jalr	d d
22c1	#@doRETURN0
22c1		pop	b
22c2		load	a [b]
22c3		store	d [c]
22c4		sliu d 13
22c5		slil d 1
22c6		page	d
22c7		sub	d d
22c8		store	a [d]
22c9		sliu d #doreturn_end	[0d]
22ca		slil d #doreturn_end	[0d]
22cb		jalr	d d	

22cc	#doreturn_error
22cc		sliu a 0
22cd		slil a 5	; calling global function mark_error

22ce		push	d
22cf		push	c
22d0		push	b
22d1		sliu d 2
22d2		slil d 2
22d3		push	d
22d4		push	c
22d5		sliu c 1
22d6		slil c 12
22d7		sliu d #mark_error	[00]
22d8		slil d #mark_error	[00]
22d9		jmpfar	d d
22da		pop	b
22db		pop	c
22dc		pop	d
22dd	#doreturn_end
22dd		sliu d 15
22de		slil d 13
22df		page	d
22e0		pop	d
22e1		pop	c
22e2		jmpfar	d d	
	; doRETURN ends
	
	

22e3		org 2300	
	; ------- GLOBAL FUNCTION doIF -------

2300	#doIF
2300		pop	c
2301		push	d		; if takes form
		; IF expr comp expr THEN expr

2302		sliu c 8
2303		slil c 2	

2304		# get and push first value	; calling global function eval_expression

2304		push	d
2305		push	c
2306		push	b
2307		sliu d 2
2308		slil d 3
2309		push	d
230a		push	c
230b		sliu c 1
230c		slil c 7
230d		sliu d #eval_expression	[00]
230e		slil d #eval_expression	[00]
230f		jmpfar	d d
2310		pop	b
2311		pop	c
2312		pop	d
2313		push	a	; calling global function error_marked

2314		push	d
2315		push	c
2316		push	b
2317		sliu d 2
2318		slil d 3
2319		push	d
231a		push	c
231b		sliu c 1
231c		slil c 12
231d		sliu d #error_marked	[01]
231e		slil d #error_marked	[01]
231f		jmpfar	d d
2320		pop	b
2321		pop	c
2322		pop	d
2323		push	a
2324		sliu d 0
2325		slil d 0
2326		sub	a d
2327		sliu d #@doIF0	[02]
2328		slil d #@doIF0	[0f]
2329		skipnz	a
232a		jalr	d d
232b		pop	a
232c		sliu d #doif_else	[0d]
232d		slil d #doif_else	[02]
232e		jalr	d d
232f	#@doIF0
232f		pop	a
2330		pop	a
2331		push	a
2332		sliu d 15
2333		slil d 15
2334		load	c [d]	

2335		# get and push operator
2335		load	a [c]
2336		inc	c
2337		inc	c
2338		push	a	

2339		# get and push second value	; calling global function eval_expression

2339		push	d
233a		push	c
233b		push	b
233c		sliu d 2
233d		slil d 3
233e		push	d
233f		push	c
2340		sliu c 1
2341		slil c 7
2342		sliu d #eval_expression	[00]
2343		slil d #eval_expression	[00]
2344		jmpfar	d d
2345		pop	b
2346		pop	c
2347		pop	d
2348		push	a	; calling global function error_marked

2349		push	d
234a		push	c
234b		push	b
234c		sliu d 2
234d		slil d 3
234e		push	d
234f		push	c
2350		sliu c 1
2351		slil c 12
2352		sliu d #error_marked	[01]
2353		slil d #error_marked	[01]
2354		jmpfar	d d
2355		pop	b
2356		pop	c
2357		pop	d
2358		push	a
2359		sliu d 0
235a		slil d 0
235b		sub	a d
235c		sliu d #@doIF1	[06]
235d		slil d #@doIF1	[04]
235e		skipnz	a
235f		jalr	d d
2360		pop	a
2361		sliu d #doif_else	[0d]
2362		slil d #doif_else	[02]
2363		jalr	d d
2364	#@doIF1
2364		pop	a
2365		pop	a
2366		sliu d 15
2367		slil d 15
2368		load	c [d]
2369		sub	b b
236a		add	b a	

236b		# save token address
236b		sub	d d
236c		add	d c	

236d		# do the comparison
236d		pop	c
236e		pop	a	

236f		push	d	

2370		sliu d 3
2371		slil d 13
2372		sub	c d
2373		sliu d #doif_eq	[0a]
2374		slil d #doif_eq	[0d]
2375		skipnz	c
2376		jalr	d d
2377		sliu d 3
2378		slil d 13
2379		add	c d	

237a		sliu d 2
237b		slil d 1
237c		sub	c d
237d		sliu d #doif_ne	[0b]
237e		slil d #doif_ne	[05]
237f		skipnz	c
2380		jalr	d d
2381		sliu d 2
2382		slil d 1
2383		add	c d	

2384		sliu d 3
2385		slil d 12
2386		sub	c d
2387		sliu d #doif_lt	[0c]
2388		slil d #doif_lt	[05]
2389		skipnz	c
238a		jalr	d d
238b		sliu d 3
238c		slil d 12
238d		add	c d	

238e		sliu d 3
238f		slil d 14
2390		sub	c d
2391		sliu d #doif_gt	[0b]
2392		slil d #doif_gt	[0d]
2393		skipnz	c
2394		jalr	d d
2395		sliu d 3
2396		slil d 14
2397		add	c d	
	;	.if c == 0x3d then doif_eq
	;	.if c == 0x21 then doif_ne
	;	.if c == 0x3c then doif_lt
	;	.if c == 0x3e then doif_gt

2398		pop	c
2399		sliu a 0
239a		slil a 1	; calling global function mark_error

239b		push	d
239c		push	c
239d		push	b
239e		sliu d 2
239f		slil d 3
23a0		push	d
23a1		push	c
23a2		sliu c 1
23a3		slil c 12
23a4		sliu d #mark_error	[00]
23a5		slil d #mark_error	[00]
23a6		jmpfar	d d
23a7		pop	b
23a8		pop	c
23a9		pop	d
23aa		sliu d #doif_end	[0d]
23ab		slil d #doif_end	[03]
23ac		jalr	d d	

23ad	#doif_eq
23ad		sub	a b
23ae		sliu d #doif_thenlocal	[0c]
23af		slil d #doif_thenlocal	[0d]
23b0		skipnz	a
23b1		jalr	d d	;	.if a == b then doif_thenlocal

23b2		sliu d #doif_else	[0d]
23b3		slil d #doif_else	[02]
23b4		jalr	d d
23b5	#doif_ne
23b5		sub	a b
23b6		sliu d #doif_thenlocal	[0c]
23b7		slil d #doif_thenlocal	[0d]
23b8		skipz	a
23b9		jalr	d d	;	.if a != b then doif_thenlocal

23ba		sliu d #doif_else	[0d]
23bb		slil d #doif_else	[02]
23bc		jalr	d d
23bd	#doif_gt
23bd		sub	b a
23be		sliu d #doif_thenlocal	[0c]
23bf		slil d #doif_thenlocal	[0d]
23c0		skipge	b
23c1		jalr	d d	;	.if a > b then doif_thenlocal

23c2		sliu d #doif_else	[0d]
23c3		slil d #doif_else	[02]
23c4		jalr	d d
23c5	#doif_lt
23c5		sub	a b
23c6		sliu d #doif_thenlocal	[0c]
23c7		slil d #doif_thenlocal	[0d]
23c8		skipge	a
23c9		jalr	d d	;	.if a < b then doif_thenlocal

23ca		sliu d #doif_else	[0d]
23cb		slil d #doif_else	[02]
23cc		jalr	d d
23cd	#doif_thenlocal
23cd		sliu c 2
23ce		slil c 4
23cf		sliu d #doif_then	[00]
23d0		slil d #doif_then	[00]
23d1		jmpfar	d d
23d2	#doif_else
23d2		pop	c
23d3	#doif_end
23d3		pop	d
23d4		pop	c
23d5		jmpfar	d d	
	; doIF ends
	
	

23d6		org 2400
2400	#doif_then
2400		pop	c		; move past THEN

2401		load	a [c]
2402		push	a
2403		sliu d 5
2404		slil d 4
2405		sub	a d
2406		sliu d #@doIF2	[00]
2407		slil d #@doIF2	[0e]
2408		skipz	a
2409		jalr	d d
240a		pop	a
240b		sliu d #doif_then2	[02]
240c		slil d #doif_then2	[05]
240d		jalr	d d
240e	#@doIF2
240e		pop	a
240f		sliu a 0
2410		slil a 1	; calling global function mark_error

2411		push	d
2412		push	c
2413		push	b
2414		sliu d 2
2415		slil d 4
2416		push	d
2417		push	c
2418		sliu c 1
2419		slil c 12
241a		sliu d #mark_error	[00]
241b		slil d #mark_error	[00]
241c		jmpfar	d d
241d		pop	b
241e		pop	c
241f		pop	d
2420		sliu c 2
2421		slil c 3
2422		sliu d #doif_end	[0d]
2423		slil d #doif_end	[03]
2424		jmpfar	d d
2425	#doif_then2
2425		inc	c
2426		inc	c
2427		# get goto address	; calling global function eval_expression

2427		push	d
2428		push	c
2429		push	b
242a		sliu d 2
242b		slil d 4
242c		push	d
242d		push	c
242e		sliu c 1
242f		slil c 7
2430		sliu d #eval_expression	[00]
2431		slil d #eval_expression	[00]
2432		jmpfar	d d
2433		pop	b
2434		pop	c
2435		pop	d
2436		push	a	; calling global function error_marked

2437		push	d
2438		push	c
2439		push	b
243a		sliu d 2
243b		slil d 4
243c		push	d
243d		push	c
243e		sliu c 1
243f		slil c 12
2440		sliu d #error_marked	[01]
2441		slil d #error_marked	[01]
2442		jmpfar	d d
2443		pop	b
2444		pop	c
2445		pop	d
2446		push	a
2447		sliu d 0
2448		slil d 0
2449		sub	a d
244a		sliu d #@doIF3	[05]
244b		slil d #@doIF3	[02]
244c		skipnz	a
244d		jalr	d d
244e		pop	a
244f		sliu d #doif_endlocal	[06]
2450		slil d #doif_endlocal	[02]
2451		jalr	d d
2452	#@doIF3
2452		pop	a
2453		pop	a	

2454		#do the goto
2454		sliu d 13
2455		slil d 1
2456		page	d
2457		sub	d d
2458		dec	a
2459		store	a [d]
245a		sliu d 15
245b		slil d 13
245c		page	d
245d		sliu c 2
245e		slil c 3
245f		sliu d #doif_end	[0d]
2460		slil d #doif_end	[03]
2461		jmpfar	d d	

2462	#doif_endlocal
2462		pop	a
2463		sliu c 2
2464		slil c 3
2465		sliu d #doif_end	[0d]
2466		slil d #doif_end	[03]
2467		jmpfar	d d
2468		pop	d
2469		pop	c
246a		jmpfar	d d	
	; doIF ends
	
	

246b		org 2500	
	; ------- GLOBAL FUNCTION doINPUT -------

2500	#doINPUT
2500		pop	c
2501		push	d		; check that there's a variable

2502		sliu b 8
2503		slil b 2
2504		load	a [b]
2505		push	a
2506		sliu d 2
2507		slil d 3
2508		sub	a d
2509		sliu d #@doINPUT0	[01]
250a		slil d #@doINPUT0	[01]
250b		skipnz	a
250c		jalr	d d
250d		pop	a
250e		sliu d #doinput_error	[06]
250f		slil d #doinput_error	[07]
2510		jalr	d d
2511	#@doINPUT0
2511		pop	a	

2512		sliu d 3
2513		slil d 15
2514		out	d
2515		sliu d 2
2516		slil d 0
2517		out	d	

2518		sliu a 15
2519		slil a 13
251a		sliu b 0
251b		slil b 0	; calling global function readstring

251c		push	d
251d		push	c
251e		push	b
251f		sliu d 2
2520		slil d 5
2521		push	d
2522		push	c
2523		sliu c 0
2524		slil c 6
2525		sliu d #readstring	[01]
2526		slil d #readstring	[03]
2527		jmpfar	d d
2528		pop	b
2529		pop	c
252a		pop	d	

252b		sliu a 15
252c		slil a 13
252d		sliu b 0
252e		slil b 0	; calling global function dectobin

252f		push	d
2530		push	c
2531		push	b
2532		sliu d 2
2533		slil d 5
2534		push	d
2535		push	c
2536		sliu c 1
2537		slil c 4
2538		sliu d #dectobin	[00]
2539		slil d #dectobin	[00]
253a		jmpfar	d d
253b		pop	b
253c		pop	c
253d		pop	d	

253e		sliu b 8
253f		slil b 2	; calling global function setvar

2540		push	d
2541		push	c
2542		push	b
2543		sliu d 2
2544		slil d 5
2545		push	d
2546		push	c
2547		sliu c 1
2548		slil c 13
2549		sliu d #setvar	[00]
254a		slil d #setvar	[0d]
254b		jmpfar	d d
254c		pop	b
254d		pop	c
254e		pop	d
254f		sliu d #doinput_end	[07]
2550		slil d #doinput_end	[08]
2551		jalr	d d	

2552	#doinput_enderror
2552		pop	a
2553		sliu a 0
2554		slil a 8	; calling global function mark_error

2555		push	d
2556		push	c
2557		push	b
2558		sliu d 2
2559		slil d 5
255a		push	d
255b		push	c
255c		sliu c 1
255d		slil c 12
255e		sliu d #mark_error	[00]
255f		slil d #mark_error	[00]
2560		jmpfar	d d
2561		pop	b
2562		pop	c
2563		pop	d
2564		sliu d #doinput_end	[07]
2565		slil d #doinput_end	[08]
2566		jalr	d d
2567	#doinput_error
2567		sliu a 0
2568		slil a 1	; calling global function mark_error

2569		push	d
256a		push	c
256b		push	b
256c		sliu d 2
256d		slil d 5
256e		push	d
256f		push	c
2570		sliu c 1
2571		slil c 12
2572		sliu d #mark_error	[00]
2573		slil d #mark_error	[00]
2574		jmpfar	d d
2575		pop	b
2576		pop	c
2577		pop	d
2578	#doinput_end
2578		pop	d
2579		pop	c
257a		jmpfar	d d	
	; doINPUT ends
	
	

257b		org 2600	
	; ------- GLOBAL FUNCTION doFOR -------

2600	#doFOR
2600		pop	c
2601		push	d		; syntax
		; FOR var = exp TO exp [STEP exp]
	
		; advance to =

2602		sliu c 8
2603		slil c 0
2604	#for_advance
2604		inc	c
2605		load	a [c]
2606		push	a
2607		sliu d 3
2608		slil d 13
2609		sub	a d
260a		sliu d #@doFOR0	[01]
260b		slil d #@doFOR0	[02]
260c		skipnz	a
260d		jalr	d d
260e		pop	a
260f		sliu d #for_advance	[00]
2610		slil d #for_advance	[04]
2611		jalr	d d
2612	#@doFOR0
2612		pop	a
2613		inc	c
2614		inc	c	
		;read first expression
	; calling global function eval_expression

2615		push	d
2616		push	c
2617		push	b
2618		sliu d 2
2619		slil d 6
261a		push	d
261b		push	c
261c		sliu c 1
261d		slil c 7
261e		sliu d #eval_expression	[00]
261f		slil d #eval_expression	[00]
2620		jmpfar	d d
2621		pop	b
2622		pop	c
2623		pop	d
2624		sliu d 15
2625		slil d 15
2626		load	c [d]	
	
		;advance past TO

2627		inc	c
2628		inc	c	
		;read second expression
	; calling global function eval_expression

2629		push	d
262a		push	c
262b		push	b
262c		sliu d 2
262d		slil d 6
262e		push	d
262f		push	c
2630		sliu c 1
2631		slil c 7
2632		sliu d #eval_expression	[00]
2633		slil d #eval_expression	[00]
2634		jmpfar	d d
2635		pop	b
2636		pop	c
2637		pop	d
2638		sliu d 15
2639		slil d 15
263a		load	c [d]		
	

263b	#for_done
263b		pop	d
263c		pop	c
263d		jmpfar	d d	
	; doFOR ends
	
	

263e		org 2700	
	; ------- GLOBAL FUNCTION basic_doline -------

2700	#basic_doline
2700		pop	c
2701		push	d		; fd:80 holds line to run
	
		; check for LIST

2702		sliu d 15
2703		slil d 13
2704		page	d
2705		sliu c 8
2706		slil c 0
2707		load	a [c]	
	
	;	.if a == 0x73 then basic_dolist

2708		sliu d 7
2709		slil d 3
270a		sub	a d
270b		sliu d #basic_dolist	[05]
270c		slil d #basic_dolist	[0a]
270d		skipnz	a
270e		jalr	d d	
		; check for CLS
	;	.if a == 0x63 then basic_docls

270f		load	a [c]
2710		sliu d 6
2711		slil d 3
2712		sub	a d
2713		sliu d #basic_docls	[06]
2714		slil d #basic_docls	[0c]
2715		skipnz	a
2716		jalr	d d	
		; check for PRINT
	;	.if a == 0x50 then basic_doprint

2717		load	a [c]
2718		sliu d 5
2719		slil d 0
271a		sub	a d
271b		sliu d #basic_doprint	[07]
271c		slil d #basic_doprint	[0e]
271d		skipnz	a
271e		jalr	d d	
		; check for LET
	;	.if a == 0x4c then basic_dolet
	;	.if a == 0x23 then basic_dolet

271f		load	a [c]
2720		sliu d 2
2721		slil d 3
2722		sub	a d
2723		sliu d #basic_dolet	[09]
2724		slil d #basic_dolet	[00]
2725		skipnz	a
2726		jalr	d d
2727		sliu d 2
2728		slil d 9
2729		sub	a d
272a		sliu d #basic_dolet	[09]
272b		slil d #basic_dolet	[00]
272c		skipnz	a
272d		jalr	d d	
		; check for RUN
	;	.if a == 0x72 then basic_dorun

272e		load	a [c]
272f		sliu d 7
2730		slil d 2
2731		sub	a d
2732		sliu d #basic_dorun	[0a]
2733		slil d #basic_dorun	[02]
2734		skipnz	a
2735		jalr	d d	

2736		push	c
2737		sliu c 2
2738		slil c 8
2739		sliu d #basic_doline_continued	[00]
273a		slil d #basic_doline_continued	[00]
273b		jmpfar	d d	

273c	#basic_doline_firstpage_done
273c		pop	c
273d		sliu d #basic_done	[0b]
273e		slil d #basic_done	[04]
273f		jalr	d d	

2740	#basic_doline_firstpage
2740		pop	c	
		; check for empty line
	;	.if a == 0 then basic_done

2741		load	a [c]
2742		sliu d #basic_done	[0b]
2743		slil d #basic_done	[04]
2744		skipnz	a
2745		jalr	d d	

2746		sliu a 0
2747		slil a 3	; calling global function mark_error

2748		push	d
2749		push	c
274a		push	b
274b		sliu d 2
274c		slil d 7
274d		push	d
274e		push	c
274f		sliu c 1
2750		slil c 12
2751		sliu d #mark_error	[00]
2752		slil d #mark_error	[00]
2753		jmpfar	d d
2754		pop	b
2755		pop	c
2756		pop	d
2757		sliu d #basic_done	[0b]
2758		slil d #basic_done	[04]
2759		jalr	d d	

275a	#basic_dolist	; calling global function doLIST

275a		push	d
275b		push	c
275c		push	b
275d		sliu d 2
275e		slil d 7
275f		push	d
2760		push	c
2761		sliu c 1
2762		slil c 14
2763		sliu d #doLIST	[0b]
2764		slil d #doLIST	[09]
2765		jmpfar	d d
2766		pop	b
2767		pop	c
2768		pop	d
2769		sliu d #basic_done	[0b]
276a		slil d #basic_done	[04]
276b		jalr	d d	

276c	#basic_docls	; calling global function doCLS

276c		push	d
276d		push	c
276e		push	b
276f		sliu d 2
2770		slil d 7
2771		push	d
2772		push	c
2773		sliu c 1
2774		slil c 15
2775		sliu d #doCLS	[00]
2776		slil d #doCLS	[00]
2777		jmpfar	d d
2778		pop	b
2779		pop	c
277a		pop	d
277b		sliu d #basic_done	[0b]
277c		slil d #basic_done	[04]
277d		jalr	d d	

277e	#basic_doprint	; calling global function doPRINT

277e		push	d
277f		push	c
2780		push	b
2781		sliu d 2
2782		slil d 7
2783		push	d
2784		push	c
2785		sliu c 1
2786		slil c 6
2787		sliu d #doPRINT	[00]
2788		slil d #doPRINT	[00]
2789		jmpfar	d d
278a		pop	b
278b		pop	c
278c		pop	d
278d		sliu d #basic_done	[0b]
278e		slil d #basic_done	[04]
278f		jalr	d d	

2790	#basic_dolet	; calling global function doLET

2790		push	d
2791		push	c
2792		push	b
2793		sliu d 2
2794		slil d 7
2795		push	d
2796		push	c
2797		sliu c 1
2798		slil c 14
2799		sliu d #doLET	[00]
279a		slil d #doLET	[00]
279b		jmpfar	d d
279c		pop	b
279d		pop	c
279e		pop	d
279f		sliu d #basic_done	[0b]
27a0		slil d #basic_done	[04]
27a1		jalr	d d	

27a2	#basic_dorun	; calling global function doRUN

27a2		push	d
27a3		push	c
27a4		push	b
27a5		sliu d 2
27a6		slil d 7
27a7		push	d
27a8		push	c
27a9		sliu c 2
27aa		slil c 1
27ab		sliu d #doRUN	[09]
27ac		slil d #doRUN	[01]
27ad		jmpfar	d d
27ae		pop	b
27af		pop	c
27b0		pop	d
27b1		sliu d #basic_done	[0b]
27b2		slil d #basic_done	[04]
27b3		jalr	d d	

27b4	#basic_done	; calling global function error_marked

27b4		push	d
27b5		push	c
27b6		push	b
27b7		sliu d 2
27b8		slil d 7
27b9		push	d
27ba		push	c
27bb		sliu c 1
27bc		slil c 12
27bd		sliu d #error_marked	[01]
27be		slil d #error_marked	[01]
27bf		jmpfar	d d
27c0		pop	b
27c1		pop	c
27c2		pop	d
27c3		push	a
27c4		sliu d 0
27c5		slil d 0
27c6		sub	a d
27c7		sliu d #@basic_doline0	[0c]
27c8		slil d #@basic_doline0	[0f]
27c9		skipz	a
27ca		jalr	d d
27cb		pop	a
27cc		sliu d #basic_line_ret	[0d]
27cd		slil d #basic_line_ret	[0f]
27ce		jalr	d d
27cf	#@basic_doline0
27cf		pop	a	; calling global function printerror

27d0		push	d
27d1		push	c
27d2		push	b
27d3		sliu d 2
27d4		slil d 7
27d5		push	d
27d6		push	c
27d7		sliu c 1
27d8		slil c 12
27d9		sliu d #printerror	[02]
27da		slil d #printerror	[0e]
27db		jmpfar	d d
27dc		pop	b
27dd		pop	c
27de		pop	d	;	.call printstring

27df	#basic_line_ret
27df		pop	d
27e0		pop	c
27e1		jmpfar	d d	
	; basic_doline ends
	
	

27e2		org 2800
2800	#basic_doline_continued
2800		pop	c	
		; check for GOTO
	;	.if a == 0x47 then basic_dogoto

2801		load	a [c]
2802		sliu d 4
2803		slil d 7
2804		sub	a d
2805		sliu d #basic_dogoto	[03]
2806		slil d #basic_dogoto	[0d]
2807		skipnz	a
2808		jalr	d d	
		; check for GOSUB
	;	.if a == 0x53 then basic_dogosub

2809		load	a [c]
280a		sliu d 5
280b		slil d 3
280c		sub	a d
280d		sliu d #basic_dogosub	[04]
280e		slil d #basic_dogosub	[0f]
280f		skipnz	a
2810		jalr	d d	
		; check for RETURN
	;	.if a == 0x52 then basic_doreturn

2811		load	a [c]
2812		sliu d 5
2813		slil d 2
2814		sub	a d
2815		sliu d #basic_doreturn	[06]
2816		slil d #basic_doreturn	[01]
2817		skipnz	a
2818		jalr	d d	
		; check for IF
	;	.if a == 0x49 then basic_doif

2819		load	a [c]
281a		sliu d 4
281b		slil d 9
281c		sub	a d
281d		sliu d #basic_doif	[07]
281e		slil d #basic_doif	[03]
281f		skipnz	a
2820		jalr	d d	
		; check for INPUT
	;	.if a == 0x69 then basic_doinput

2821		load	a [c]
2822		sliu d 6
2823		slil d 9
2824		sub	a d
2825		sliu d #basic_doinput	[09]
2826		slil d #basic_doinput	[07]
2827		skipnz	a
2828		jalr	d d	
		; check for CLEAR
	;	.if a == 0x65 then basic_doclear

2829		load	a [c]
282a		sliu d 6
282b		slil d 5
282c		sub	a d
282d		sliu d #basic_doclear	[08]
282e		slil d #basic_doclear	[05]
282f		skipnz	a
2830		jalr	d d	
	

2831		push	c
2832		sliu c 2
2833		slil c 7
2834		sliu d #basic_doline_firstpage	[04]
2835		slil d #basic_doline_firstpage	[00]
2836		jmpfar	d d	

2837	#basic_doline_gobacktofirstpage
2837		push	c
2838		sliu c 2
2839		slil c 7
283a		sliu d #basic_doline_firstpage_done	[03]
283b		slil d #basic_doline_firstpage_done	[0c]
283c		jmpfar	d d	

283d	#basic_dogoto	; calling global function doGOTO

283d		push	d
283e		push	c
283f		push	b
2840		sliu d 2
2841		slil d 8
2842		push	d
2843		push	c
2844		sliu c 2
2845		slil c 2
2846		sliu d #doGOTO	[00]
2847		slil d #doGOTO	[00]
2848		jmpfar	d d
2849		pop	b
284a		pop	c
284b		pop	d
284c		sliu d #basic_doline_gobacktofirstpage	[03]
284d		slil d #basic_doline_gobacktofirstpage	[07]
284e		jalr	d d	

284f	#basic_dogosub	; calling global function doGOSUB

284f		push	d
2850		push	c
2851		push	b
2852		sliu d 2
2853		slil d 8
2854		push	d
2855		push	c
2856		sliu c 2
2857		slil c 2
2858		sliu d #doGOSUB	[04]
2859		slil d #doGOSUB	[01]
285a		jmpfar	d d
285b		pop	b
285c		pop	c
285d		pop	d
285e		sliu d #basic_doline_gobacktofirstpage	[03]
285f		slil d #basic_doline_gobacktofirstpage	[07]
2860		jalr	d d	

2861	#basic_doreturn	; calling global function doRETURN

2861		push	d
2862		push	c
2863		push	b
2864		sliu d 2
2865		slil d 8
2866		push	d
2867		push	c
2868		sliu c 2
2869		slil c 2
286a		sliu d #doRETURN	[0a]
286b		slil d #doRETURN	[0d]
286c		jmpfar	d d
286d		pop	b
286e		pop	c
286f		pop	d
2870		sliu d #basic_doline_gobacktofirstpage	[03]
2871		slil d #basic_doline_gobacktofirstpage	[07]
2872		jalr	d d	

2873	#basic_doif	; calling global function doIF

2873		push	d
2874		push	c
2875		push	b
2876		sliu d 2
2877		slil d 8
2878		push	d
2879		push	c
287a		sliu c 2
287b		slil c 3
287c		sliu d #doIF	[00]
287d		slil d #doIF	[00]
287e		jmpfar	d d
287f		pop	b
2880		pop	c
2881		pop	d
2882		sliu d #basic_doline_gobacktofirstpage	[03]
2883		slil d #basic_doline_gobacktofirstpage	[07]
2884		jalr	d d	

2885	#basic_doclear	; calling global function initvar

2885		push	d
2886		push	c
2887		push	b
2888		sliu d 2
2889		slil d 8
288a		push	d
288b		push	c
288c		sliu c 1
288d		slil c 13
288e		sliu d #initvar	[00]
288f		slil d #initvar	[00]
2890		jmpfar	d d
2891		pop	b
2892		pop	c
2893		pop	d
2894		sliu d #basic_doline_gobacktofirstpage	[03]
2895		slil d #basic_doline_gobacktofirstpage	[07]
2896		jalr	d d	

2897	#basic_doinput	; calling global function doINPUT

2897		push	d
2898		push	c
2899		push	b
289a		sliu d 2
289b		slil d 8
289c		push	d
289d		push	c
289e		sliu c 2
289f		slil c 5
28a0		sliu d #doINPUT	[00]
28a1		slil d #doINPUT	[00]
28a2		jmpfar	d d
28a3		pop	b
28a4		pop	c
28a5		pop	d
28a6		sliu d #basic_doline_gobacktofirstpage	[03]
28a7		slil d #basic_doline_gobacktofirstpage	[07]
28a8		jalr	d d	

28a9		org 7e00
7e00	#keychars
7e00		db	0x3d
7e01		db	0
7e02		db	0x3d
7e03		db	0
7e04		db	0x3c
7e05		db	0
7e06		db	0x3c
7e07		db	0
7e08		db	0x3e
7e09		db	0
7e0a		db	0x3e
7e0b		db	0
7e0c		db	0x2b
7e0d		db	0
7e0e		db	0x2b
7e0f		db	0
7e10		db	0x2d
7e11		db	0
7e12		db	0x2d
7e13		db	0
7e14		db	0x2a
7e15		db	0
7e16		db	0x2a
7e17		db	0
7e18		db	0x2f
7e19		db	0
7e1a		db	0x2f
7e1b		db	0
7e1c		db	0x28
7e1d		db	0
7e1e		db	0x28
7e1f		db	0
7e20		db	0x29
7e21		db	0
7e22		db	0x29
7e23		db	0
7e24		db	0x2c
7e25		db	0
7e26		db	0x2c
7e27		db	0
7e28		db	0x21
7e29		db	0
7e2a		db	0x21
7e2b		db	0		; ; char

7e2c		db	0x3b
7e2d		db	0
7e2e			db	0x3b
7e2f			db	0
7e30		db	0
7e31	#keywords
7e31		db	0x50
7e32		db	0x52
7e33		db	0x49
7e34		db	0x4e
7e35		db	0x54
7e36		db	0
7e37		db	0x50
7e38		db	0
7e39		db	0x49
7e3a		db	0x46
7e3b		db	0
7e3c		db	0x49
7e3d		db	0
7e3e		db	0x54
7e3f		db	0x48
7e40		db	0x45
7e41		db	0x4e
7e42		db	0
7e43		db	0x54
7e44		db	0
7e45		db	0x47
7e46		db	0x4f
7e47		db	0x54
7e48		db	0x4f
7e49		db	0
7e4a		db	0x47
7e4b		db	0
7e4c		db	0x49
7e4d		db	0x4e
7e4e		db	0x50
7e4f		db	0x55
7e50		db	0x54
7e51		db	0
7e52		db	0x69
7e53		db	0
7e54		db	0x4c
7e55		db	0x45
7e56		db	0x54
7e57		db	0
7e58		db	0x4c
7e59		db	0
7e5a		db	0x47
7e5b		db	0x4f
7e5c		db	0x53
7e5d		db	0x55
7e5e		db	0x42
7e5f		db	0
7e60		db	0x53
7e61		db	0
7e62		db	0x52
7e63		db	0x45
7e64		db	0x54
7e65		db	0x55
7e66		db	0x52
7e67		db	0x4e
7e68		db	0
7e69		db	0x52
7e6a		db	0
7e6b		db	0x4c
7e6c		db	0x49
7e6d		db	0x53
7e6e		db	0x54
7e6f		db	0
7e70		db	0x73
7e71		db	0
7e72		db	0x52
7e73		db	0x55
7e74		db	0x4e
7e75		db	0
7e76		db	0x72
7e77		db	0
7e78		db	0x45
7e79		db	0x4e
7e7a		db	0x44
7e7b		db	0
7e7c		db	0x45
7e7d		db	0
7e7e		db	0x46
7e7f		db	0x4f
7e80		db	0x52
7e81		db	0
7e82		db	0x46
7e83		db	0
7e84		db	0x54
7e85		db	0x4f
7e86		db	0
7e87		db	0x74
7e88		db	0
7e89		db	0x4e
7e8a		db	0x45
7e8b		db	0x58
7e8c		db	0x54
7e8d		db	0
7e8e		db	0x58
7e8f		db	0
7e90		db	0x53
7e91		db	0x54
7e92		db	0x45
7e93		db	0x50
7e94		db	0
7e95		db	0x70
7e96		db	0
7e97		db	0x52
7e98		db	0x4e
7e99		db	0x44
7e9a		db	0
7e9b		db	0x6e
7e9c		db	0
7e9d		db	0x43
7e9e		db	0x4c
7e9f		db	0x53
7ea0		db	0
7ea1		db	0x63
7ea2		db	0
7ea3		db	0x4c
7ea4		db	0x4f
7ea5		db	0x41
7ea6		db	0x44
7ea7		db	0
7ea8		db	0x64
7ea9		db	0
7eaa		db	0x4d
7eab		db	0x4f
7eac		db	0x44
7ead		db	0
7eae		db	0x25
7eaf		db	0
7eb0		db	0x43
7eb1		db	0x4c
7eb2		db	0x45
7eb3		db	0x41
7eb4		db	0x52
7eb5		db	0
7eb6		db	0x65
7eb7		db	0
7eb8		db	0
7eb9	#endtokenlist
7eb9		db	0x3b
7eba		db	0x2c
7ebb		db	0x29
7ebc		db	0x54
7ebd		db	0x3c
7ebe		db	0x3e
7ebf		db	0x3d
7ec0		db	0x21
7ec1		db	0	

7ec2		org 7f00
7f00	#monitor_message
7f00		db	0x52
7f01		db	0x49
7f02		db	0x53
7f03		db	0x43
7f04		db	0x59
7f05		db	0x20
7f06		db	0x4d
7f07		db	0x4f
7f08		db	0x4e
7f09		db	0x49
7f0a		db	0x54
7f0b		db	0x4f
7f0c		db	0x52
7f0d		db	0
7f0e	#basic_message
7f0e		db	0x54
7f0f		db	0x49
7f10		db	0x4e
7f11		db	0x59
7f12		db	0x20
7f13		db	0x42
7f14		db	0x41
7f15		db	0x53
7f16		db	0x49
7f17		db	0x43
7f18		db	0
7f19	#basic_prompt
7f19		db	0x4f
7f1a		db	0x4b
7f1b		db	0
7f1c	#newline
7f1c		db	0x0d
7f1d		db	0x20
7f1e		db	0x00
7f1f	#lexical_error
7f1f		db	0x43
7f20		db	0x41
7f21		db	0x4e
7f22		db	0x4e
7f23		db	0x4f
7f24		db	0x54
7f25		db	0x20
7f26		db	0x50
7f27		db	0x41
7f28		db	0x52
7f29		db	0x53
7f2a		db	0x45
7f2b		db	0x20
7f2c		db	0x4c
7f2d		db	0x49
7f2e		db	0x4e
7f2f		db	0x45
7f30		db	0
7f31	#syntax_error
7f31		db	0x53
7f32		db	0x59
7f33		db	0x4e
7f34		db	0x54
7f35		db	0x41
7f36		db	0x58
7f37		db	0x20
7f38		db	0x45
7f39		db	0x52
7f3a		db	0x52
7f3b		db	0x4f
7f3c		db	0x52
7f3d		db	0
7f3e	#undefinedvar_error
7f3e		db	0x55
7f3f		db	0x4e
7f40		db	0x44
7f41		db	0x45
7f42		db	0x46
7f43		db	0x49
7f44		db	0x4e
7f45		db	0x45
7f46		db	0x44
7f47		db	0x20
7f48		db	0x56
7f49		db	0x41
7f4a		db	0x52
7f4b		db	0x49
7f4c		db	0x41
7f4d		db	0x42
7f4e		db	0x4c
7f4f		db	0x45
7f50		db	0
7f51	#undefinedcommand_error
7f51		db	0x55
7f52		db	0x4e
7f53		db	0x4b
7f54		db	0x4e
7f55		db	0x4f
7f56		db	0x57
7f57		db	0x4e
7f58		db	0x20
7f59		db	0x43
7f5a		db	0x4f
7f5b		db	0x4d
7f5c		db	0x4d
7f5d		db	0x41
7f5e		db	0x4e
7f5f		db	0x44
7f60		db	0
7f61	#return_error
7f61		db	0x52
7f62		db	0x45
7f63		db	0x54
7f64		db	0x55
7f65		db	0x52
7f66		db	0x4e
7f67		db	0x20
7f68		db	0x57
7f69		db	0x49
7f6a		db	0x54
7f6b		db	0x48
7f6c		db	0x4f
7f6d		db	0x55
7f6e		db	0x54
7f6f		db	0x20
7f70		db	0x47
7f71		db	0x4f
7f72		db	0x53
7f73		db	0x55
7f74		db	0x42
7f75		db	0
7f76	#gosub_error
7f76		db	0x54
7f77		db	0x4f
7f78		db	0x4f
7f79		db	0x20
7f7a		db	0x4d
7f7b		db	0x41
7f7c		db	0x4e
7f7d		db	0x59
7f7e		db	0x20
7f7f		db	0x47
7f80		db	0x4f
7f81		db	0x53
7f82		db	0x55
7f83		db	0x42
7f84		db	0x53
7f85		db	0
