
0000		org	0
0000		sliu d 15
0001		slil d 15
0002		stackpage	d	
	; calling global function setupdisplay

0003		push	d
0004		push	c
0005		push	b
0006		sliu d 0
0007		slil d 0
0008		push	d
0009		push	c
000a		sliu c 0
000b		slil c 1
000c		sliu d #setupdisplay	[00]
000d		slil d #setupdisplay	[00]
000e		jmpfar	d d
000f		pop	b
0010		pop	c
0011		pop	d	; calling global function monitor_entry

0012		push	d
0013		push	c
0014		push	b
0015		sliu d 0
0016		slil d 0
0017		push	d
0018		push	c
0019		sliu c 0
001a		slil c 2
001b		sliu d #monitor_entry	[00]
001c		slil d #monitor_entry	[00]
001d		jmpfar	d d
001e		pop	b
001f		pop	c
0020		pop	d	

0021		halt	

0022		org	100	
	; ------- GLOBAL FUNCTION setupdisplay -------

0100	#setupdisplay
0100		pop	c
0101		push	d	;	li	d,0x80
	;	out	d

0102		sliu d 0
0103		slil d 2
0104		out	d
0105		sliu d 0
0106		slil d 2
0107		out	d
0108		sliu d 0
0109		slil d 12
010a		out	d
010b		sliu d 0
010c		slil d 0
010d		out	d
010e		sliu d 0
010f		slil d 15
0110		out	d
0111		sliu d 0
0112		slil d 0
0113		out	d
0114		sliu d 0
0115		slil d 1
0116		out	d
0117		pop	d
0118		pop	c
0119		jmpfar	d d	
	; setupdisplay ends
	
	

011a		org	200	
	; ------- GLOBAL FUNCTION monitor_entry -------

0200	#monitor_entry
0200		pop	c
0201		push	d		; print out "RISCY Monitor"

0202		sliu a 7
0203		slil a 15
0204		sliu b #monitor_message	[00]
0205		slil b #monitor_message	[00]	; calling global function printstring

0206		push	d
0207		push	c
0208		push	b
0209		sliu d 0
020a		slil d 2
020b		push	d
020c		push	c
020d		sliu c 0
020e		slil c 5
020f		sliu d #printstring	[00]
0210		slil d #printstring	[00]
0211		jmpfar	d d
0212		pop	b
0213		pop	c
0214		pop	d
0215	#monitor	; calling global function readprompt

0215		push	d
0216		push	c
0217		push	b
0218		sliu d 0
0219		slil d 2
021a		push	d
021b		push	c
021c		sliu c 0
021d		slil c 8
021e		sliu d #readprompt	[01]
021f		slil d #readprompt	[01]
0220		jmpfar	d d
0221		pop	b
0222		pop	c
0223		pop	d		; read a line into 0xfd:0

0224		sliu a 15
0225		slil a 13
0226		sliu b 0
0227		slil b 0	; calling global function readstring

0228		push	d
0229		push	c
022a		push	b
022b		sliu d 0
022c		slil d 2
022d		push	d
022e		push	c
022f		sliu c 0
0230		slil c 6
0231		sliu d #readstring	[01]
0232		slil d #readstring	[03]
0233		jmpfar	d d
0234		pop	b
0235		pop	c
0236		pop	d	
	;	.call clearscreen
		;get command

0237		sliu a 15
0238		slil a 13
0239		page	a
023a		sliu b 0
023b		slil b 0
023c		load	a [b]	
		;check command

023d		push	a
023e		sliu d 4
023f		slil d 4
0240		sub	a d
0241		sliu d #@monitor_entry0	[04]
0242		slil d #@monitor_entry0	[09]
0243		skipz	a
0244		jalr	d d
0245		pop	a
0246		sliu d #domonitordump	[07]
0247		slil d #domonitordump	[04]
0248		jalr	d d
0249	#@monitor_entry0
0249		pop	a
024a		push	a
024b		sliu d 4
024c		slil d 5
024d		sub	a d
024e		sliu d #@monitor_entry1	[05]
024f		slil d #@monitor_entry1	[06]
0250		skipz	a
0251		jalr	d d
0252		pop	a
0253		sliu d #domonitoredit	[08]
0254		slil d #domonitoredit	[06]
0255		jalr	d d
0256	#@monitor_entry1
0256		pop	a
0257		push	a
0258		sliu d 4
0259		slil d 7
025a		sub	a d
025b		sliu d #@monitor_entry2	[06]
025c		slil d #@monitor_entry2	[03]
025d		skipz	a
025e		jalr	d d
025f		pop	a
0260		sliu d #domonitorgo	[0a]
0261		slil d #domonitorgo	[0a]
0262		jalr	d d
0263	#@monitor_entry2
0263		pop	a
0264		push	a
0265		sliu d 4
0266		slil d 2
0267		sub	a d
0268		sliu d #@monitor_entry3	[07]
0269		slil d #@monitor_entry3	[00]
026a		skipz	a
026b		jalr	d d
026c		pop	a
026d		sliu d #domonitorbasic	[09]
026e		slil d #domonitorbasic	[08]
026f		jalr	d d
0270	#@monitor_entry3
0270		pop	a	

0271		sliu d #monitor	[01]
0272		slil d #monitor	[05]
0273		jalr	d d	

0274	#domonitordump	; calling global function monitordump

0274		push	d
0275		push	c
0276		push	b
0277		sliu d 0
0278		slil d 2
0279		push	d
027a		push	c
027b		sliu c 0
027c		slil c 3
027d		sliu d #monitordump	[00]
027e		slil d #monitordump	[00]
027f		jmpfar	d d
0280		pop	b
0281		pop	c
0282		pop	d
0283		sliu d #monitor	[01]
0284		slil d #monitor	[05]
0285		jalr	d d
0286	#domonitoredit	; calling global function monitoredit

0286		push	d
0287		push	c
0288		push	b
0289		sliu d 0
028a		slil d 2
028b		push	d
028c		push	c
028d		sliu c 0
028e		slil c 3
028f		sliu d #monitoredit	[09]
0290		slil d #monitoredit	[0c]
0291		jmpfar	d d
0292		pop	b
0293		pop	c
0294		pop	d
0295		sliu d #monitor	[01]
0296		slil d #monitor	[05]
0297		jalr	d d
0298	#domonitorbasic	; calling global function basic

0298		push	d
0299		push	c
029a		push	b
029b		sliu d 0
029c		slil d 2
029d		push	d
029e		push	c
029f		sliu c 1
02a0		slil c 2
02a1		sliu d #basic	[00]
02a2		slil d #basic	[00]
02a3		jmpfar	d d
02a4		pop	b
02a5		pop	c
02a6		pop	d
02a7		sliu d #monitor	[01]
02a8		slil d #monitor	[05]
02a9		jalr	d d
02aa	#domonitorgo
02aa		sliu b 0
02ab		slil b 2
02ac		load	a [b]
02ad		inc	b
02ae		load	b [b]	; calling global function hextobin

02af		push	d
02b0		push	c
02b1		push	b
02b2		sliu d 0
02b3		slil d 2
02b4		push	d
02b5		push	c
02b6		sliu c 0
02b7		slil c 4
02b8		sliu d #hextobin	[08]
02b9		slil d #hextobin	[0f]
02ba		jmpfar	d d
02bb		pop	b
02bc		pop	c
02bd		pop	d
02be		pop	b
02bf		push	a
02c0		sliu d 0
02c1		slil d 4
02c2		add	b d
02c3		load	a [b]
02c4		inc	b
02c5		load	b [b]	; calling global function hextobin

02c6		push	d
02c7		push	c
02c8		push	b
02c9		sliu d 0
02ca		slil d 2
02cb		push	d
02cc		push	c
02cd		sliu c 0
02ce		slil c 4
02cf		sliu d #hextobin	[08]
02d0		slil d #hextobin	[0f]
02d1		jmpfar	d d
02d2		pop	b
02d3		pop	c
02d4		pop	d
02d5		pop	c
02d6		jmpfar	a a	

02d7		pop	d
02d8		pop	c
02d9		jmpfar	d d	
	; monitor_entry ends
	
	

02da		org 300	
	; ------- GLOBAL FUNCTION monitordump -------

0300	#monitordump
0300		pop	c
0301		push	d	; calling global function monitor_printaddress

0302		push	d
0303		push	c
0304		push	b
0305		sliu d 0
0306		slil d 3
0307		push	d
0308		push	c
0309		sliu c 0
030a		slil c 4
030b		sliu d #monitor_printaddress	[00]
030c		slil d #monitor_printaddress	[00]
030d		jmpfar	d d
030e		pop	b
030f		pop	c
0310		pop	d
0311		sub	b b	; calling global function monitor_getaddress

0312		push	d
0313		push	c
0314		push	b
0315		sliu d 0
0316		slil d 3
0317		push	d
0318		push	c
0319		sliu c 0
031a		slil c 4
031b		sliu d #monitor_getaddress	[05]
031c		slil d #monitor_getaddress	[0c]
031d		jmpfar	d d
031e		pop	b
031f		pop	c
0320		pop	d
0321		sub	b b
0322		add	b a
0323		load	a [b]	; calling global function printhex

0324		push	d
0325		push	c
0326		push	b
0327		sliu d 0
0328		slil d 3
0329		push	d
032a		push	c
032b		sliu c 0
032c		slil c 5
032d		sliu d #printhex	[05]
032e		slil d #printhex	[03]
032f		jmpfar	d d
0330		pop	b
0331		pop	c
0332		pop	d
0333		sliu a 2
0334		slil a 0	; calling global function printchar

0335		push	d
0336		push	c
0337		push	b
0338		sliu d 0
0339		slil d 3
033a		push	d
033b		push	c
033c		sliu c 0
033d		slil c 5
033e		sliu d #printchar	[02]
033f		slil d #printchar	[07]
0340		jmpfar	d d
0341		pop	b
0342		pop	c
0343		pop	d
0344		inc	b
0345		load	a [b]	; calling global function printhex

0346		push	d
0347		push	c
0348		push	b
0349		sliu d 0
034a		slil d 3
034b		push	d
034c		push	c
034d		sliu c 0
034e		slil c 5
034f		sliu d #printhex	[05]
0350		slil d #printhex	[03]
0351		jmpfar	d d
0352		pop	b
0353		pop	c
0354		pop	d
0355		sliu a 2
0356		slil a 0	; calling global function printchar

0357		push	d
0358		push	c
0359		push	b
035a		sliu d 0
035b		slil d 3
035c		push	d
035d		push	c
035e		sliu c 0
035f		slil c 5
0360		sliu d #printchar	[02]
0361		slil d #printchar	[07]
0362		jmpfar	d d
0363		pop	b
0364		pop	c
0365		pop	d
0366		inc	b
0367		load	a [b]	; calling global function printhex

0368		push	d
0369		push	c
036a		push	b
036b		sliu d 0
036c		slil d 3
036d		push	d
036e		push	c
036f		sliu c 0
0370		slil c 5
0371		sliu d #printhex	[05]
0372		slil d #printhex	[03]
0373		jmpfar	d d
0374		pop	b
0375		pop	c
0376		pop	d
0377		sliu a 2
0378		slil a 0	; calling global function printchar

0379		push	d
037a		push	c
037b		push	b
037c		sliu d 0
037d		slil d 3
037e		push	d
037f		push	c
0380		sliu c 0
0381		slil c 5
0382		sliu d #printchar	[02]
0383		slil d #printchar	[07]
0384		jmpfar	d d
0385		pop	b
0386		pop	c
0387		pop	d
0388		inc	b
0389		load	a [b]	; calling global function printhex

038a		push	d
038b		push	c
038c		push	b
038d		sliu d 0
038e		slil d 3
038f		push	d
0390		push	c
0391		sliu c 0
0392		slil c 5
0393		sliu d #printhex	[05]
0394		slil d #printhex	[03]
0395		jmpfar	d d
0396		pop	b
0397		pop	c
0398		pop	d
0399		pop	d
039a		pop	c
039b		jmpfar	d d	
	; monitordump ends
	
	
	
	; ------- GLOBAL FUNCTION monitoredit -------

039c	#monitoredit
039c		pop	c
039d		push	d		; get value byte

039e		sliu b 0
039f		slil b 7
03a0		load	a [b]
03a1		inc	b
03a2		load	b [b]	; calling global function hextobin

03a3		push	d
03a4		push	c
03a5		push	b
03a6		sliu d 0
03a7		slil d 3
03a8		push	d
03a9		push	c
03aa		sliu c 0
03ab		slil c 4
03ac		sliu d #hextobin	[08]
03ad		slil d #hextobin	[0f]
03ae		jmpfar	d d
03af		pop	b
03b0		pop	c
03b1		pop	d
03b2		push	a
03b3		sub	b b	; calling global function monitor_getaddress

03b4		push	d
03b5		push	c
03b6		push	b
03b7		sliu d 0
03b8		slil d 3
03b9		push	d
03ba		push	c
03bb		sliu c 0
03bc		slil c 4
03bd		sliu d #monitor_getaddress	[05]
03be		slil d #monitor_getaddress	[0c]
03bf		jmpfar	d d
03c0		pop	b
03c1		pop	c
03c2		pop	d
03c3		pop	b
03c4		store	b [a]
03c5		pop	d
03c6		pop	c
03c7		jmpfar	d d	
	; monitoredit ends
	
	

03c8		org 400	
	; ------- GLOBAL FUNCTION monitor_printaddress -------

0400	#monitor_printaddress
0400		pop	c
0401		push	d
0402		sliu b 0
0403		slil b 2
0404		load	a [b]	; calling global function printchar

0405		push	d
0406		push	c
0407		push	b
0408		sliu d 0
0409		slil d 4
040a		push	d
040b		push	c
040c		sliu c 0
040d		slil c 5
040e		sliu d #printchar	[02]
040f		slil d #printchar	[07]
0410		jmpfar	d d
0411		pop	b
0412		pop	c
0413		pop	d
0414		inc	b
0415		load	a [b]	; calling global function printchar

0416		push	d
0417		push	c
0418		push	b
0419		sliu d 0
041a		slil d 4
041b		push	d
041c		push	c
041d		sliu c 0
041e		slil c 5
041f		sliu d #printchar	[02]
0420		slil d #printchar	[07]
0421		jmpfar	d d
0422		pop	b
0423		pop	c
0424		pop	d
0425		inc	b
0426		load	a [b]	; calling global function printchar

0427		push	d
0428		push	c
0429		push	b
042a		sliu d 0
042b		slil d 4
042c		push	d
042d		push	c
042e		sliu c 0
042f		slil c 5
0430		sliu d #printchar	[02]
0431		slil d #printchar	[07]
0432		jmpfar	d d
0433		pop	b
0434		pop	c
0435		pop	d
0436		inc	b
0437		load	a [b]	; calling global function printchar

0438		push	d
0439		push	c
043a		push	b
043b		sliu d 0
043c		slil d 4
043d		push	d
043e		push	c
043f		sliu c 0
0440		slil c 5
0441		sliu d #printchar	[02]
0442		slil d #printchar	[07]
0443		jmpfar	d d
0444		pop	b
0445		pop	c
0446		pop	d
0447		inc	b
0448		sliu a 2
0449		slil a 0	; calling global function printchar

044a		push	d
044b		push	c
044c		push	b
044d		sliu d 0
044e		slil d 4
044f		push	d
0450		push	c
0451		sliu c 0
0452		slil c 5
0453		sliu d #printchar	[02]
0454		slil d #printchar	[07]
0455		jmpfar	d d
0456		pop	b
0457		pop	c
0458		pop	d
0459		pop	d
045a		pop	c
045b		jmpfar	d d	
	; monitor_printaddress ends
	
	
	
	; ------- GLOBAL FUNCTION monitor_getaddress -------

045c	#monitor_getaddress
045c		pop	c
045d		push	d		; sets the data page to the page entered, returns the address in A

045e		push	b
045f		sliu b 0
0460		slil b 2
0461		load	a [b]
0462		inc	b
0463		load	b [b]	; calling global function hextobin

0464		push	d
0465		push	c
0466		push	b
0467		sliu d 0
0468		slil d 4
0469		push	d
046a		push	c
046b		sliu c 0
046c		slil c 4
046d		sliu d #hextobin	[08]
046e		slil d #hextobin	[0f]
046f		jmpfar	d d
0470		pop	b
0471		pop	c
0472		pop	d
0473		pop	b
0474		push	a
0475		sliu d 0
0476		slil d 4
0477		add	b d
0478		load	a [b]
0479		inc	b
047a		load	b [b]	; calling global function hextobin

047b		push	d
047c		push	c
047d		push	b
047e		sliu d 0
047f		slil d 4
0480		push	d
0481		push	c
0482		sliu c 0
0483		slil c 4
0484		sliu d #hextobin	[08]
0485		slil d #hextobin	[0f]
0486		jmpfar	d d
0487		pop	b
0488		pop	c
0489		pop	d
048a		pop	b
048b		page	b
048c		pop	d
048d		pop	c
048e		jmpfar	d d	
	; monitor_getaddress ends
	
	
	
	; ------- GLOBAL FUNCTION hextobin -------

048f	#hextobin
048f		pop	c
0490		push	d		; A,B are two chars.  returns num in A

0491		push	a
0492		sliu d 3
0493		slil d 10
0494		sub	a d
0495		sliu d #@hextobin0	[09]
0496		slil d #@hextobin0	[0d]
0497		skipge	a
0498		jalr	d d
0499		pop	a
049a		sliu d #hextobin_letter1	[0a]
049b		slil d #hextobin_letter1	[01]
049c		jalr	d d
049d	#@hextobin0
049d		pop	a
049e		sliu d #hextobin_number1	[0a]
049f		slil d #hextobin_number1	[0a]
04a0		jalr	d d
04a1	#hextobin_letter1
04a1		sliu d 4
04a2		slil d 1
04a3		sub	a d
04a4		sliu d 0
04a5		slil d 10
04a6		add	a d
04a7		sliu d #hextobin2	[0a]
04a8		slil d #hextobin2	[0d]
04a9		jalr	d d
04aa	#hextobin_number1
04aa		sliu d 3
04ab		slil d 0
04ac		sub	a d
04ad	#hextobin2
04ad		add	a a
04ae		add	a a
04af		add	a a
04b0		add	a a
04b1		push	b
04b2		sliu d 3
04b3		slil d 10
04b4		sub	b d
04b5		sliu d #@hextobin1	[0b]
04b6		slil d #@hextobin1	[0d]
04b7		skipge	b
04b8		jalr	d d
04b9		pop	b
04ba		sliu d #hextobin_letter2	[0c]
04bb		slil d #hextobin_letter2	[01]
04bc		jalr	d d
04bd	#@hextobin1
04bd		pop	b
04be		sliu d #hextobin_number2	[0c]
04bf		slil d #hextobin_number2	[0a]
04c0		jalr	d d
04c1	#hextobin_letter2
04c1		sliu d 4
04c2		slil d 1
04c3		sub	b d
04c4		sliu d 0
04c5		slil d 10
04c6		add	b d
04c7		sliu d #hextobin3	[0c]
04c8		slil d #hextobin3	[0d]
04c9		jalr	d d
04ca	#hextobin_number2
04ca		sliu d 3
04cb		slil d 0
04cc		sub	b d
04cd	#hextobin3
04cd		add	a b
04ce		pop	d
04cf		pop	c
04d0		jmpfar	d d	
	; hextobin ends
	
	

04d1		org 500	
	; ------- GLOBAL FUNCTION printstring -------

0500	#printstring
0500		pop	c
0501		push	d		; page in A, string addr in B

0502		page	a
0503	#printstring_loop
0503		load	a [b]
0504		push	a
0505		sliu d 0
0506		slil d 0
0507		sub	a d
0508		sliu d #@printstring0	[01]
0509		slil d #@printstring0	[00]
050a		skipz	a
050b		jalr	d d
050c		pop	a
050d		sliu d #printstring_done	[02]
050e		slil d #printstring_done	[04]
050f		jalr	d d
0510	#@printstring0
0510		pop	a	
	; calling global function printchar

0511		push	d
0512		push	c
0513		push	b
0514		sliu d 0
0515		slil d 5
0516		push	d
0517		push	c
0518		sliu c 0
0519		slil c 5
051a		sliu d #printchar	[02]
051b		slil d #printchar	[07]
051c		jmpfar	d d
051d		pop	b
051e		pop	c
051f		pop	d	

0520		inc	b
0521		sliu d #printstring_loop	[00]
0522		slil d #printstring_loop	[03]
0523		jalr	d d
0524	#printstring_done
0524		pop	d
0525		pop	c
0526		jmpfar	d d	
	; printstring ends
	
	
	
	; ------- GLOBAL FUNCTION printchar -------

0527	#printchar
0527		pop	c
0528		push	d	;	 prints char in A
	;	out	a
	

0529		push	a
052a		push	a
052b		sliu d 15
052c		slil d 0
052d		nand	a d
052e		nand	a a
052f		sliu b 1
0530		slil b 0	; calling global function div_even

0531		push	d
0532		push	c
0533		push	b
0534		sliu d 0
0535		slil d 5
0536		push	d
0537		push	c
0538		sliu c 0
0539		slil c 7
053a		sliu d #div_even	[01]
053b		slil d #div_even	[09]
053c		jmpfar	d d
053d		pop	b
053e		pop	c
053f		pop	d
0540		sliu c 7
0541		slil c 15
0542		nand	a c
0543		nand	a c
0544		out	a
0545		pop	a
0546		sliu d 0
0547		slil d 15
0548		nand	a d
0549		nand	a a
054a		sliu d 7
054b		slil d 15
054c		nand	a d
054d		nand	a d
054e		out	a
054f		pop	a
0550		pop	d
0551		pop	c
0552		jmpfar	d d	
	; printchar ends
	
	
	
	; ------- GLOBAL FUNCTION printhex -------

0553	#printhex
0553		pop	c
0554		push	d		; prints a byte in A as two hex chars

0555		push	a
0556		push	a
0557		sliu d 15
0558		slil d 0
0559		nand	a d
055a		nand	a a
055b		sliu b 1
055c		slil b 0	; calling global function div_even

055d		push	d
055e		push	c
055f		push	b
0560		sliu d 0
0561		slil d 5
0562		push	d
0563		push	c
0564		sliu c 0
0565		slil c 7
0566		sliu d #div_even	[01]
0567		slil d #div_even	[09]
0568		jmpfar	d d
0569		pop	b
056a		pop	c
056b		pop	d
056c		push	a
056d		sliu d 0
056e		slil d 10
056f		sub	a d
0570		sliu d #@printhex0	[07]
0571		slil d #@printhex0	[08]
0572		skipl	a
0573		jalr	d d
0574		pop	a
0575		sliu d #printhex_num1	[08]
0576		slil d #printhex_num1	[02]
0577		jalr	d d
0578	#@printhex0
0578		pop	a
0579		sliu d 0
057a		slil d 10
057b		sub	a d
057c		sliu d 4
057d		slil d 1
057e		add	a d
057f		sliu d #printhex2	[08]
0580		slil d #printhex2	[05]
0581		jalr	d d
0582	#printhex_num1
0582		sliu d 3
0583		slil d 0
0584		add	a d
0585	#printhex2	; calling global function printchar

0585		push	d
0586		push	c
0587		push	b
0588		sliu d 0
0589		slil d 5
058a		push	d
058b		push	c
058c		sliu c 0
058d		slil c 5
058e		sliu d #printchar	[02]
058f		slil d #printchar	[07]
0590		jmpfar	d d
0591		pop	b
0592		pop	c
0593		pop	d
0594		pop	a
0595		sliu b 0
0596		slil b 15
0597		nand	a b
0598		nand	a a
0599		push	a
059a		sliu d 0
059b		slil d 10
059c		sub	a d
059d		sliu d #@printhex1	[0a]
059e		slil d #@printhex1	[05]
059f		skipl	a
05a0		jalr	d d
05a1		pop	a
05a2		sliu d #printhex_num2	[0a]
05a3		slil d #printhex_num2	[0f]
05a4		jalr	d d
05a5	#@printhex1
05a5		pop	a
05a6		sliu d 0
05a7		slil d 10
05a8		sub	a d
05a9		sliu d 4
05aa		slil d 1
05ab		add	a d
05ac		sliu d #printhex3	[0b]
05ad		slil d #printhex3	[02]
05ae		jalr	d d
05af	#printhex_num2
05af		sliu d 3
05b0		slil d 0
05b1		add	a d
05b2	#printhex3	; calling global function printchar

05b2		push	d
05b3		push	c
05b4		push	b
05b5		sliu d 0
05b6		slil d 5
05b7		push	d
05b8		push	c
05b9		sliu c 0
05ba		slil c 5
05bb		sliu d #printchar	[02]
05bc		slil d #printchar	[07]
05bd		jmpfar	d d
05be		pop	b
05bf		pop	c
05c0		pop	d
05c1		pop	a
05c2		pop	d
05c3		pop	c
05c4		jmpfar	d d	
	; printhex ends
	
	

05c5		org	600	
	; ------- GLOBAL FUNCTION readchar -------

0600	#readchar
0600		pop	c
0601		push	d		; reads a char in A

0602	#inloop
0602		in	a
0603		push	a
0604		sliu d 0
0605		slil d 0
0606		sub	a d
0607		sliu d #@readchar0	[00]
0608		slil d #@readchar0	[0f]
0609		skipz	a
060a		jalr	d d
060b		pop	a
060c		sliu d #inloop	[00]
060d		slil d #inloop	[02]
060e		jalr	d d
060f	#@readchar0
060f		pop	a
0610		pop	d
0611		pop	c
0612		jmpfar	d d	
	; readchar ends
	
	
	
	; ------- GLOBAL FUNCTION readstring -------

0613	#readstring
0613		pop	c
0614		push	d		;A = buffer page, B = buffer addr
		; reads a string until RETURN, puts in buffer and null terminates
	

0615		page	a
0616	#readstring_readloop	; calling global function readchar

0616		push	d
0617		push	c
0618		push	b
0619		sliu d 0
061a		slil d 6
061b		push	d
061c		push	c
061d		sliu c 0
061e		slil c 6
061f		sliu d #readchar	[00]
0620		slil d #readchar	[00]
0621		jmpfar	d d
0622		pop	b
0623		pop	c
0624		pop	d
0625		push	a
0626		sliu d 0
0627		slil d 13
0628		sub	a d
0629		sliu d #@readstring0	[03]
062a		slil d #@readstring0	[01]
062b		skipz	a
062c		jalr	d d
062d		pop	a
062e		sliu d #readstring_return	[07]
062f		slil d #readstring_return	[06]
0630		jalr	d d
0631	#@readstring0
0631		pop	a
0632		push	a
0633		sliu d 0
0634		slil d 8
0635		sub	a d
0636		sliu d #@readstring1	[03]
0637		slil d #@readstring1	[0e]
0638		skipz	a
0639		jalr	d d
063a		pop	a
063b		sliu d #readstring_backspace	[05]
063c		slil d #readstring_backspace	[03]
063d		jalr	d d
063e	#@readstring1
063e		pop	a	; calling global function printchar

063f		push	d
0640		push	c
0641		push	b
0642		sliu d 0
0643		slil d 6
0644		push	d
0645		push	c
0646		sliu c 0
0647		slil c 5
0648		sliu d #printchar	[02]
0649		slil d #printchar	[07]
064a		jmpfar	d d
064b		pop	b
064c		pop	c
064d		pop	d
064e		store	a [b]
064f		inc	b
0650		sliu d #readstring_readloop	[01]
0651		slil d #readstring_readloop	[06]
0652		jalr	d d	

0653	#readstring_backspace		; ignore if beginning of line
		;;; TODO bug what if buffer doesn't start at 0?

0653		push	b
0654		sliu d 0
0655		slil d 0
0656		sub	b d
0657		sliu d #@readstring2	[05]
0658		slil d #@readstring2	[0f]
0659		skipz	b
065a		jalr	d d
065b		pop	b
065c		sliu d #readstring_readloop	[01]
065d		slil d #readstring_readloop	[06]
065e		jalr	d d
065f	#@readstring2
065f		pop	b
0660		dec	b
0661		sliu d 0
0662		slil d 0
0663		out	d
0664		sliu d 0
0665		slil d 4
0666		out	d
0667		sliu d 8
0668		slil d 2
0669		out	d
066a		sliu d 8
066b		slil d 0
066c		out	d
066d		sliu d 0
066e		slil d 0
066f		out	d
0670		sliu d 0
0671		slil d 0
0672		out	d	;	li	d,0x08
	;	out	d
	;	li	d,0x20
	;	out	d
	;	li	d,0x08
	;	out	d

0673		sliu d #readstring_readloop	[01]
0674		slil d #readstring_readloop	[06]
0675		jalr	d d	

0676	#readstring_return	;	li	d,0x0d
	;	out	d
	;	li	d,0x0a
	;	out	d
	;	; home

0676		sliu d 0
0677		slil d 0
0678		out	d
0679		sliu d 0
067a		slil d 3
067b		out	d	
		;null terminate

067c		sliu a 0
067d		slil a 0
067e		store	a [b]
067f		pop	d
0680		pop	c
0681		jmpfar	d d	
	; readstring ends
	
	

0682		org	700	
	; ------- GLOBAL FUNCTION div -------

0700	#div
0700		pop	c
0701		push	d		; only works if A is 7f or less
		; A = A / B

0702		sliu c 0
0703		slil c 0
0704	#divwhile
0704		push	a
0705		sub	a b
0706		sliu d #@div0	[00]
0707		slil d #@div0	[0e]
0708		skipl	a
0709		jalr	d d
070a		pop	a
070b		sliu d #divwhileend	[01]
070c		slil d #divwhileend	[04]
070d		jalr	d d
070e	#@div0
070e		pop	a
070f		sub	a b
0710		inc	c
0711		sliu d #divwhile	[00]
0712		slil d #divwhile	[04]
0713		jalr	d d
0714	#divwhileend
0714		sub	a a
0715		add	a c
0716		pop	d
0717		pop	c
0718		jmpfar	d d	
	; div ends
	
	
	
	; ------- GLOBAL FUNCTION div_even -------

0719	#div_even
0719		pop	c
071a		push	d		; A = A / B
		; only works if A%B is 0

071b		sliu c 0
071c		slil c 0
071d	#divewhile
071d		push	a
071e		sliu d 0
071f		slil d 0
0720		sub	a d
0721		sliu d #@div_even0	[02]
0722		slil d #@div_even0	[09]
0723		skipz	a
0724		jalr	d d
0725		pop	a
0726		sliu d #divewhileend	[02]
0727		slil d #divewhileend	[0f]
0728		jalr	d d
0729	#@div_even0
0729		pop	a
072a		sub	a b
072b		inc	c
072c		sliu d #divewhile	[01]
072d		slil d #divewhile	[0d]
072e		jalr	d d
072f	#divewhileend
072f		sub	a a
0730		add	a c
0731		pop	d
0732		pop	c
0733		jmpfar	d d	
	; div_even ends
	
	
	
	; ------- GLOBAL FUNCTION mod -------

0734	#mod
0734		pop	c
0735		push	d		; A = A % B

0736	#modwhile
0736		push	a
0737		sub	a b
0738		sliu d #@mod0	[04]
0739		slil d #@mod0	[00]
073a		skipl	a
073b		jalr	d d
073c		pop	a
073d		sliu d #modwhileend	[04]
073e		slil d #modwhileend	[05]
073f		jalr	d d
0740	#@mod0
0740		pop	a
0741		sub	a b
0742		sliu d #modwhile	[03]
0743		slil d #modwhile	[06]
0744		jalr	d d
0745	#modwhileend
0745		pop	d
0746		pop	c
0747		jmpfar	d d	
	; mod ends
	
	
	
	
	; ------- GLOBAL FUNCTION mul -------

0748	#mul
0748		pop	c
0749		push	d		; A = A * B

074a		sub	c c
074b	#mulloop
074b		push	b
074c		sliu d 0
074d		slil d 0
074e		sub	b d
074f		sliu d #@mul0	[05]
0750		slil d #@mul0	[07]
0751		skipz	b
0752		jalr	d d
0753		pop	b
0754		sliu d #mulend	[05]
0755		slil d #mulend	[0d]
0756		jalr	d d
0757	#@mul0
0757		pop	b
0758		add	c a
0759		dec	b
075a		sliu d #mulloop	[04]
075b		slil d #mulloop	[0b]
075c		jalr	d d
075d	#mulend
075d		sub	a a
075e		add	a c
075f		pop	d
0760		pop	c
0761		jmpfar	d d	
	; mul ends
	
	

0762		org	800	
	; ------- GLOBAL FUNCTION clearscreen -------

0800	#clearscreen
0800		pop	c
0801		push	d		; resets screen and homes cursor
	;	li	d,0x80
	;	out	d
	;	; home

0802		sliu d 0
0803		slil d 0
0804		out	d
0805		sliu d 0
0806		slil d 3
0807		out	d		; clear

0808		sliu d 0
0809		slil d 0
080a		out	d
080b		sliu d 0
080c		slil d 1
080d		out	d	

080e		pop	d
080f		pop	c
0810		jmpfar	d d	
	; clearscreen ends
	
	
	
	; ------- GLOBAL FUNCTION readprompt -------

0811	#readprompt
0811		pop	c
0812		push	d		;move to new line and display > prompt
	;	li	d,0x0d
	;	out	d
	;	li	d,0x0a
	;	out	d
	;	li	d,0x3e
	;	out	d
	
		;clears second line, puts cursor at beginning, prints prompt
		
		; put cursor on second line

0813		sliu d 0
0814		slil d 12
0815		out	d
0816		sliu d 0
0817		slil d 0
0818		out	d	
		;print 16 spaces

0819		sliu c 1
081a		slil c 0
081b	#readprompt_clr
081b		sliu d 8
081c		slil d 2
081d		out	d
081e		sliu d 8
081f		slil d 0
0820		out	d
0821		dec	c
0822		push	c
0823		sliu d 0
0824		slil d 0
0825		sub	c d
0826		sliu d #@readprompt0	[02]
0827		slil d #@readprompt0	[0e]
0828		skipnz	c
0829		jalr	d d
082a		pop	c
082b		sliu d #readprompt_clr	[01]
082c		slil d #readprompt_clr	[0b]
082d		jalr	d d
082e	#@readprompt0
082e		pop	c	
		; put cursor on second line again

082f		sliu d 0
0830		slil d 12
0831		out	d
0832		sliu d 0
0833		slil d 0
0834		out	d	
		; print a > prompt

0835		sliu d 8
0836		slil d 3
0837		out	d
0838		sliu d 8
0839		slil d 14
083a		out	d
083b		pop	d
083c		pop	c
083d		jmpfar	d d	
	; readprompt ends
	
	
	
	; ------- GLOBAL FUNCTION nextline -------

083e	#nextline
083e		pop	c
083f		push	d		;move to new line
	
		;clears second line, puts cursor at beginning, prints prompt
		
		; put cursor on second line

0840		sliu d 0
0841		slil d 12
0842		out	d
0843		sliu d 0
0844		slil d 0
0845		out	d	
		;print 16 spaces

0846		sliu c 1
0847		slil c 0
0848	#nextprompt_clr
0848		sliu d 8
0849		slil d 2
084a		out	d
084b		sliu d 8
084c		slil d 0
084d		out	d
084e		dec	c
084f		push	c
0850		sliu d 0
0851		slil d 0
0852		sub	c d
0853		sliu d #@nextline0	[05]
0854		slil d #@nextline0	[0b]
0855		skipnz	c
0856		jalr	d d
0857		pop	c
0858		sliu d #nextprompt_clr	[04]
0859		slil d #nextprompt_clr	[08]
085a		jalr	d d
085b	#@nextline0
085b		pop	c	
		; put cursor on second line again

085c		sliu d 0
085d		slil d 12
085e		out	d
085f		sliu d 0
0860		slil d 0
0861		out	d	

0862		pop	d
0863		pop	c
0864		jmpfar	d d	
	; nextline ends
	
	
	
	; tokens:
	; known keywords are reduced to a single character
	; integers consist of one or more digits
	; strings are surrounded by ""
	; vars are # then one or more capital letters
	

0865		org 1000	
	; ------- GLOBAL FUNCTION tokenize -------

1000	#tokenize
1000		pop	c
1001		push	d		; generates a new command string with tokens replacing keywords
		; A=buffer page, B=buffer addr, C=dest buffer addr
		; returns 0 if no error, 1 if syntax error
	

1002		page	a		;push the page

1003		push	a	
		;save dest addr on stack

1004		push	c	

1005	#tokenize_loop		;get next char

1005		load	a [b]	
		;if it's 0, end of line

1006		sliu d #tokenize_done	[0e]
1007		slil d #tokenize_done	[08]
1008		skipnz	a
1009		jalr	d d	
		; check if it's a keyword
	

100a		pop	c
100b		pop	a
100c		push	a
100d		push	c	
	; calling global function identify_keyword

100e		push	d
100f		push	c
1010		push	b
1011		sliu d 1
1012		slil d 0
1013		push	d
1014		push	c
1015		sliu c 1
1016		slil c 1
1017		sliu d #identify_keyword	[00]
1018		slil d #identify_keyword	[00]
1019		jmpfar	d d
101a		pop	b
101b		pop	c
101c		pop	d
101d		sliu d #tokenize_notkey	[03]
101e		slil d #tokenize_notkey	[09]
101f		skipnz	a
1020		jalr	d d	
		;save keyword token to output string

1021		pop	c
1022		store	a [c]
1023		inc	c		;include space separator

1024		sliu d 2
1025		slil d 0
1026		store	d [c]
1027		inc	c
1028		push	c	
		;advance b to next space or EOL

1029	#tokenize_advance
1029		inc	b
102a		load	a [b]	
		; if a == 0 then done

102b		sliu d #tokenize_done	[0e]
102c		slil d #tokenize_done	[08]
102d		skipnz	a
102e		jalr	d d		; if a == ' ' then stop

102f		sliu d 2
1030		slil d 0
1031		sub	a d
1032		sliu d #tokenize_advance	[02]
1033		slil d #tokenize_advance	[09]
1034		skipz	a
1035		jalr	d d	

1036		sliu d #tokenize_loop	[00]
1037		slil d #tokenize_loop	[05]
1038		jalr	d d	

1039	#tokenize_notkey		; is it a space? just move forward

1039		load	a [b]
103a		push	a
103b		sliu d 2
103c		slil d 0
103d		sub	a d
103e		sliu d #@tokenize0	[04]
103f		slil d #@tokenize0	[06]
1040		skipnz	a
1041		jalr	d d
1042		pop	a
1043		sliu d #tokenize_notspace	[04]
1044		slil d #tokenize_notspace	[0b]
1045		jalr	d d
1046	#@tokenize0
1046		pop	a
1047		inc	b
1048		sliu d #tokenize_loop	[00]
1049		slil d #tokenize_loop	[05]
104a		jalr	d d	

104b	#tokenize_notspace		; is it a string? then copy and advance to next "

104b		push	a
104c		sliu d 2
104d		slil d 2
104e		sub	a d
104f		sliu d #@tokenize1	[05]
1050		slil d #@tokenize1	[07]
1051		skipnz	a
1052		jalr	d d
1053		pop	a
1054		sliu d #tokenize_notstring	[07]
1055		slil d #tokenize_notstring	[07]
1056		jalr	d d
1057	#@tokenize1
1057		pop	a
1058		pop	c	

1059	#tokenize_stringcopyloop
1059		store	a [c]
105a		inc	b
105b		inc	c
105c		load	a [b]
105d		push	a
105e		sliu d 2
105f		slil d 2
1060		sub	a d
1061		sliu d #@tokenize2	[06]
1062		slil d #@tokenize2	[09]
1063		skipnz	a
1064		jalr	d d
1065		pop	a
1066		sliu d #tokenize_stringcopyloop	[05]
1067		slil d #tokenize_stringcopyloop	[09]
1068		jalr	d d
1069	#@tokenize2
1069		pop	a	
		;put a space after the string

106a		inc	b
106b		sliu d 2
106c		slil d 2
106d		store	d [c]
106e		inc	c
106f		sliu d 2
1070		slil d 0
1071		store	d [c]
1072		inc	c
1073		push	c
1074		sliu d #tokenize_loop	[00]
1075		slil d #tokenize_loop	[05]
1076		jalr	d d	

1077	#tokenize_notstring		;is it a number? match 0-9

1077		load	a [b]
1078		push	a
1079		sliu d 3
107a		slil d 0
107b		sub	a d
107c		sliu d #@tokenize3	[08]
107d		slil d #@tokenize3	[04]
107e		skipl	a
107f		jalr	d d
1080		pop	a
1081		sliu d #tokenize_notnumber	[0a]
1082		slil d #tokenize_notnumber	[0b]
1083		jalr	d d
1084	#@tokenize3
1084		pop	a
1085		push	a
1086		sliu d 3
1087		slil d 10
1088		sub	a d
1089		sliu d #@tokenize4	[09]
108a		slil d #@tokenize4	[01]
108b		skipge	a
108c		jalr	d d
108d		pop	a
108e		sliu d #tokenize_notnumber	[0a]
108f		slil d #tokenize_notnumber	[0b]
1090		jalr	d d
1091	#@tokenize4
1091		pop	a	
		; copy the number over

1092		pop	c
1093	#tokenize_numbercopyloop
1093		load	a [b]
1094		store	a [c]
1095		inc	b
1096		inc	c
1097		load	a [b]
1098		sliu d #tokenize_numbercopyloopdone	[0a]
1099		slil d #tokenize_numbercopyloopdone	[03]
109a		skipnz	a
109b		jalr	d d
109c		sliu d 2
109d		slil d 0
109e		sub	a d
109f		sliu d #tokenize_numbercopyloop	[09]
10a0		slil d #tokenize_numbercopyloop	[03]
10a1		skipz	a
10a2		jalr	d d	

10a3	#tokenize_numbercopyloopdone		; save a space

10a3		sliu d 2
10a4		slil d 0
10a5		store	d [c]
10a6		inc	c
10a7		push	c
10a8		sliu d #tokenize_loop	[00]
10a9		slil d #tokenize_loop	[05]
10aa		jalr	d d	

10ab	#tokenize_notnumber		;is it a var? match A-Z

10ab		load	a [b]
10ac		push	a
10ad		sliu d 4
10ae		slil d 1
10af		sub	a d
10b0		sliu d #@tokenize5	[0b]
10b1		slil d #@tokenize5	[08]
10b2		skipl	a
10b3		jalr	d d
10b4		pop	a
10b5		sliu d #tokenize_notvar	[0e]
10b6		slil d #tokenize_notvar	[03]
10b7		jalr	d d
10b8	#@tokenize5
10b8		pop	a
10b9		push	a
10ba		sliu d 5
10bb		slil d 11
10bc		sub	a d
10bd		sliu d #@tokenize6	[0c]
10be		slil d #@tokenize6	[05]
10bf		skipge	a
10c0		jalr	d d
10c1		pop	a
10c2		sliu d #tokenize_notvar	[0e]
10c3		slil d #tokenize_notvar	[03]
10c4		jalr	d d
10c5	#@tokenize6
10c5		pop	a	

10c6		pop	c	
		;plant a # at beginning

10c7		sliu d 2
10c8		slil d 3
10c9		store	d [c]
10ca		inc	c	
		; copy the letters over

10cb	#tokenize_varcopyloop
10cb		load	a [b]
10cc		store	a [c]
10cd		inc	b
10ce		inc	c
10cf		load	a [b]
10d0		sliu d #tokenize_varcopyloopdone	[0d]
10d1		slil d #tokenize_varcopyloopdone	[0b]
10d2		skipnz	a
10d3		jalr	d d
10d4		sliu d 2
10d5		slil d 0
10d6		sub	a d
10d7		sliu d #tokenize_varcopyloop	[0c]
10d8		slil d #tokenize_varcopyloop	[0b]
10d9		skipz	a
10da		jalr	d d	

10db	#tokenize_varcopyloopdone		; save a space

10db		sliu d 2
10dc		slil d 0
10dd		store	d [c]
10de		inc	c
10df		push	c
10e0		sliu d #tokenize_loop	[00]
10e1		slil d #tokenize_loop	[05]
10e2		jalr	d d	

10e3	#tokenize_notvar		;syntax error

10e3		sliu a 0
10e4		slil a 1
10e5		sliu d #tokenize_done_return	[0e]
10e6		slil d #tokenize_done_return	[0e]
10e7		jalr	d d	

10e8	#tokenize_done
10e8		pop	c
10e9		push	c
10ea		# null terminate output string
10ea		sliu d 0
10eb		slil d 0
10ec		store	d [c]
10ed		sub	a a
10ee	#tokenize_done_return
10ee		pop	c
10ef		pop	d
10f0		pop	d
10f1		pop	c
10f2		jmpfar	d d	
	; tokenize ends
	
	

10f3		org 1100	
	
	; ------- GLOBAL FUNCTION identify_keyword -------

1100	#identify_keyword
1100		pop	c
1101		push	d		; A is page, B is address
		; returns 0 if no match, otherwise keyword char in A
	
		; push test address and data page

1102		push	b
1103		push	a		
		; c holds keyword addr

1104		sub	c c	

1105	#identify_keyword_loop		;compare
		;get char from keyword list

1105		sliu a 7
1106		slil a 14
1107		page	a
1108		load	a [c]	
		;is the keyword 0? then test better be 0 or ' '

1109		push	a
110a		sliu d 0
110b		slil d 0
110c		sub	a d
110d		sliu d #@identify_keyword0	[01]
110e		slil d #@identify_keyword0	[05]
110f		skipnz	a
1110		jalr	d d
1111		pop	a
1112		sliu d #identify_keyword_notendofkeyword	[04]
1113		slil d #identify_keyword_notendofkeyword	[0f]
1114		jalr	d d
1115	#@identify_keyword0
1115		pop	a		
		;get char from test

1116		pop	a
1117		page	a
1118		push	a
1119		load	a [b]	
		;if it's 0 or ' ', then match

111a		push	a
111b		sliu d 0
111c		slil d 0
111d		sub	a d
111e		sliu d #@identify_keyword1	[02]
111f		slil d #@identify_keyword1	[06]
1120		skipz	a
1121		jalr	d d
1122		pop	a
1123		sliu d #identify_keyword_match	[07]
1124		slil d #identify_keyword_match	[0b]
1125		jalr	d d
1126	#@identify_keyword1
1126		pop	a
1127		push	a
1128		sliu d 2
1129		slil d 0
112a		sub	a d
112b		sliu d #@identify_keyword2	[03]
112c		slil d #@identify_keyword2	[03]
112d		skipz	a
112e		jalr	d d
112f		pop	a
1130		sliu d #identify_keyword_match	[07]
1131		slil d #identify_keyword_match	[0b]
1132		jalr	d d
1133	#@identify_keyword2
1133		pop	a	

1134	#identify_keyword_doesntmatch	
		;not a match.  reset b and move to next keyword

1134		pop	a
1135		pop	b
1136		push	b
1137		push	a
1138		sliu a 7
1139		slil a 14
113a		page	a		;advance c to 0 if it's not there yet

113b	#identify_keyword_doesntmatch2
113b		load	a [c]
113c		sliu d #identify_keyword_doesntmatch1	[04]
113d		slil d #identify_keyword_doesntmatch1	[04]
113e		skipnz	a
113f		jalr	d d
1140		inc	c
1141		sliu d #identify_keyword_doesntmatch2	[03]
1142		slil d #identify_keyword_doesntmatch2	[0b]
1143		jalr	d d
1144	#identify_keyword_doesntmatch1	
		; advance c three forwards

1144		inc	c
1145		inc	c
1146		inc	c		; if it is zero, no keywords match

1147		load	a [c]
1148		sliu d #identify_keyword_nomatches	[08]
1149		slil d #identify_keyword_nomatches	[03]
114a		skipnz	a
114b		jalr	d d
114c		sliu d #identify_keyword_loop	[00]
114d		slil d #identify_keyword_loop	[05]
114e		jalr	d d	

114f	#identify_keyword_notendofkeyword		; are we at end of test word? if so, no match

114f		pop	a
1150		page	a
1151		push	a
1152		load	a [b]
1153		push	a
1154		sliu d 0
1155		slil d 0
1156		sub	a d
1157		sliu d #@identify_keyword3	[05]
1158		slil d #@identify_keyword3	[0f]
1159		skipz	a
115a		jalr	d d
115b		pop	a
115c		sliu d #identify_keyword_doesntmatch	[03]
115d		slil d #identify_keyword_doesntmatch	[04]
115e		jalr	d d
115f	#@identify_keyword3
115f		pop	a
1160		push	a
1161		sliu d 2
1162		slil d 0
1163		sub	a d
1164		sliu d #@identify_keyword4	[06]
1165		slil d #@identify_keyword4	[0c]
1166		skipz	a
1167		jalr	d d
1168		pop	a
1169		sliu d #identify_keyword_doesntmatch	[03]
116a		slil d #identify_keyword_doesntmatch	[04]
116b		jalr	d d
116c	#@identify_keyword4
116c		pop	a	
		;test if the letters are the same

116d		sliu d 7
116e		slil d 14
116f		page	d
1170		load	d [c]	

1171		sub	a d
1172		sliu d #identify_keyword_doesntmatch	[03]
1173		slil d #identify_keyword_doesntmatch	[04]
1174		skipz	a
1175		jalr	d d	
		;not done with matching.  go to next character

1176		inc	b
1177		inc	c
1178		sliu d #identify_keyword_loop	[00]
1179		slil d #identify_keyword_loop	[05]
117a		jalr	d d	

117b	#identify_keyword_match		; the next char is the token

117b		sliu d 7
117c		slil d 14
117d		page	d
117e		inc	c
117f		load	a [c]
1180		sliu d #identify_keyword_done	[08]
1181		slil d #identify_keyword_done	[04]
1182		jalr	d d	

1183	#identify_keyword_nomatches	

1183		sub	a a	

1184	#identify_keyword_done
1184		pop	d
1185		page	d
1186		pop	d
1187		pop	d
1188		pop	c
1189		jmpfar	d d	
	; identify_keyword ends
	
	

118a		org 1200	
	; ------- GLOBAL FUNCTION basic -------

1200	#basic
1200		pop	c
1201		push	d		; print "tiny basic"

1202		sliu a 7
1203		slil a 15
1204		sliu b #basic_message	[00]
1205		slil b #basic_message	[0e]	; calling global function printstring

1206		push	d
1207		push	c
1208		push	b
1209		sliu d 1
120a		slil d 2
120b		push	d
120c		push	c
120d		sliu c 0
120e		slil c 5
120f		sliu d #printstring	[00]
1210		slil d #printstring	[00]
1211		jmpfar	d d
1212		pop	b
1213		pop	c
1214		pop	d	; calling global function basic_init

1215		push	d
1216		push	c
1217		push	b
1218		sliu d 1
1219		slil d 2
121a		push	d
121b		push	c
121c		sliu c 1
121d		slil c 3
121e		sliu d #basic_init	[00]
121f		slil d #basic_init	[00]
1220		jmpfar	d d
1221		pop	b
1222		pop	c
1223		pop	d	
		; main basic loop

1224	#basicloop	;	li	d,0x0d
	;	out	d
	;	li	d,0x0a
	;	out	d
	
	; calling global function nextline

1224		push	d
1225		push	c
1226		push	b
1227		sliu d 1
1228		slil d 2
1229		push	d
122a		push	c
122b		sliu c 0
122c		slil c 8
122d		sliu d #nextline	[03]
122e		slil d #nextline	[0e]
122f		jmpfar	d d
1230		pop	b
1231		pop	c
1232		pop	d		; print "Ok" prompt

1233		sliu a 7
1234		slil a 15
1235		sliu b #basic_prompt	[01]
1236		slil b #basic_prompt	[09]	; calling global function printstring

1237		push	d
1238		push	c
1239		push	b
123a		sliu d 1
123b		slil d 2
123c		push	d
123d		push	c
123e		sliu c 0
123f		slil c 5
1240		sliu d #printstring	[00]
1241		slil d #printstring	[00]
1242		jmpfar	d d
1243		pop	b
1244		pop	c
1245		pop	d
1246		sliu d 2
1247		slil d 0	; calling global function printchar

1248		push	d
1249		push	c
124a		push	b
124b		sliu d 1
124c		slil d 2
124d		push	d
124e		push	c
124f		sliu c 0
1250		slil c 5
1251		sliu d #printchar	[02]
1252		slil d #printchar	[07]
1253		jmpfar	d d
1254		pop	b
1255		pop	c
1256		pop	d	;	li	d,0x0d
	;	out	d
	;	li	d,0x0a
	;	out	d
	
		; read a string to fd00

1257		sliu a 15
1258		slil a 13
1259		sliu b 0
125a		slil b 0	; calling global function readstring

125b		push	d
125c		push	c
125d		push	b
125e		sliu d 1
125f		slil d 2
1260		push	d
1261		push	c
1262		sliu c 0
1263		slil c 6
1264		sliu d #readstring	[01]
1265		slil d #readstring	[03]
1266		jmpfar	d d
1267		pop	b
1268		pop	c
1269		pop	d	
	; calling global function clearscreen

126a		push	d
126b		push	c
126c		push	b
126d		sliu d 1
126e		slil d 2
126f		push	d
1270		push	c
1271		sliu c 0
1272		slil c 8
1273		sliu d #clearscreen	[00]
1274		slil d #clearscreen	[00]
1275		jmpfar	d d
1276		pop	b
1277		pop	c
1278		pop	d	
		; convert it to tokens at fd80
	; calling global function tokenizeline

1279		push	d
127a		push	c
127b		push	b
127c		sliu d 1
127d		slil d 2
127e		push	d
127f		push	c
1280		sliu c 1
1281		slil c 2
1282		sliu d #tokenizeline	[0c]
1283		slil d #tokenizeline	[0f]
1284		jmpfar	d d
1285		pop	b
1286		pop	c
1287		pop	d	
		; if the first token is a line number, save line in program space

1288		sliu a 15
1289		slil a 13
128a		page	a
128b		sliu c 8
128c		slil c 0
128d		load	a [c]
128e		push	a
128f		sliu d 3
1290		slil d 0
1291		sub	a d
1292		sliu d #@basic0	[09]
1293		slil d #@basic0	[0a]
1294		skipl	a
1295		jalr	d d
1296		pop	a
1297		sliu d #basic_notprog	[0b]
1298		slil d #basic_notprog	[0a]
1299		jalr	d d
129a	#@basic0
129a		pop	a
129b		push	a
129c		sliu d 3
129d		slil d 10
129e		sub	a d
129f		sliu d #@basic1	[0a]
12a0		slil d #@basic1	[07]
12a1		skipge	a
12a2		jalr	d d
12a3		pop	a
12a4		sliu d #basic_notprog	[0b]
12a5		slil d #basic_notprog	[0a]
12a6		jalr	d d
12a7	#@basic1
12a7		pop	a	
	; calling global function basic_saveline

12a8		push	d
12a9		push	c
12aa		push	b
12ab		sliu d 1
12ac		slil d 2
12ad		push	d
12ae		push	c
12af		sliu c 1
12b0		slil c 3
12b1		sliu d #basic_saveline	[01]
12b2		slil d #basic_saveline	[0f]
12b3		jmpfar	d d
12b4		pop	b
12b5		pop	c
12b6		pop	d
12b7		sliu d #basicloop	[02]
12b8		slil d #basicloop	[04]
12b9		jalr	d d	

12ba	#basic_notprog	; calling global function basic_doline

12ba		push	d
12bb		push	c
12bc		push	b
12bd		sliu d 1
12be		slil d 2
12bf		push	d
12c0		push	c
12c1		sliu c 1
12c2		slil c 5
12c3		sliu d #basic_doline	[00]
12c4		slil d #basic_doline	[00]
12c5		jmpfar	d d
12c6		pop	b
12c7		pop	c
12c8		pop	d
12c9		sliu d #basicloop	[02]
12ca		slil d #basicloop	[04]
12cb		jalr	d d		
	;	.goto basicloop

12cc		pop	d
12cd		pop	c
12ce		jmpfar	d d	
	; basic ends
	
	
	
	; ------- GLOBAL FUNCTION tokenizeline -------

12cf	#tokenizeline
12cf		pop	c
12d0		push	d
12d1		sliu a 15
12d2		slil a 13
12d3		sliu b 0
12d4		slil b 0
12d5		sliu c 8
12d6		slil c 0	; calling global function tokenize

12d7		push	d
12d8		push	c
12d9		push	b
12da		sliu d 1
12db		slil d 2
12dc		push	d
12dd		push	c
12de		sliu c 1
12df		slil c 0
12e0		sliu d #tokenize	[00]
12e1		slil d #tokenize	[00]
12e2		jmpfar	d d
12e3		pop	b
12e4		pop	c
12e5		pop	d
12e6		sliu a 15
12e7		slil a 13
12e8		sliu b 8
12e9		slil b 0	; calling global function printstring

12ea		push	d
12eb		push	c
12ec		push	b
12ed		sliu d 1
12ee		slil d 2
12ef		push	d
12f0		push	c
12f1		sliu c 0
12f2		slil c 5
12f3		sliu d #printstring	[00]
12f4		slil d #printstring	[00]
12f5		jmpfar	d d
12f6		pop	b
12f7		pop	c
12f8		pop	d
12f9		pop	d
12fa		pop	c
12fb		jmpfar	d d	
	; tokenizeline ends
	
	

12fc		org 1300	
	; ------- GLOBAL FUNCTION basic_init -------

1300	#basic_init
1300		pop	c
1301		push	d		; goes from pages 0x90 to 0xaf and sets to 0

1302		sliu a 0
1303		slil a 0
1304		sliu c 9
1305		slil c 0
1306	#basic_init_pageloop
1306		page	c
1307		sliu b 0
1308		slil b 0
1309	#basic_init_addrloop
1309		dec	b
130a		store	a [b]
130b		sliu d #basic_init_addrloop	[00]
130c		slil d #basic_init_addrloop	[09]
130d		skipz	b
130e		inc	c
130f		push	c
1310		sliu d 11
1311		slil d 0
1312		sub	c d
1313		sliu d #@basic_init0	[01]
1314		slil d #@basic_init0	[0b]
1315		skipnz	c
1316		jalr	d d
1317		pop	c
1318		sliu d #basic_init_pageloop	[00]
1319		slil d #basic_init_pageloop	[06]
131a		jalr	d d
131b	#@basic_init0
131b		pop	c
131c		pop	d
131d		pop	c
131e		jmpfar	d d	
	; basic_init ends
	
	
	
	; ------- GLOBAL FUNCTION basic_saveline -------

131f	#basic_saveline
131f		pop	c
1320		push	d		; copy line at fd80 to program space and link line number
		; program space from pages 90 onwards
		; each program line is given 0x20 space
	
		; push fdbf to fd80 to stack

1321		sliu a 15
1322		slil a 13
1323		page	a
1324		sliu b 9
1325		slil b 15
1326	#basic_saveline_pushloop
1326		load	a [b]
1327		push	a
1328		dec	b
1329		push	b
132a		sliu d 7
132b		slil d 15
132c		sub	b d
132d		sliu d #@basic_saveline0	[03]
132e		slil d #@basic_saveline0	[05]
132f		skipnz	b
1330		jalr	d d
1331		pop	b
1332		sliu d #basic_saveline_pushloop	[02]
1333		slil d #basic_saveline_pushloop	[06]
1334		jalr	d d
1335	#@basic_saveline0
1335		pop	b	
		; get line number

1336		sliu a 15
1337		slil a 13
1338		sliu b 8
1339		slil b 0	; calling global function dectobin

133a		push	d
133b		push	c
133c		push	b
133d		sliu d 1
133e		slil d 3
133f		push	d
1340		push	c
1341		sliu c 1
1342		slil c 4
1343		sliu d #dectobin	[00]
1344		slil d #dectobin	[00]
1345		jmpfar	d d
1346		pop	b
1347		pop	c
1348		pop	d	
		; divide it by eight to get the page number

1349		push	a
134a		sliu d 15
134b		slil d 8
134c		nand	a d
134d		nand	a a
134e		sliu b 0
134f		slil b 8	; calling global function div_even

1350		push	d
1351		push	c
1352		push	b
1353		sliu d 1
1354		slil d 3
1355		push	d
1356		push	c
1357		sliu c 0
1358		slil c 7
1359		sliu d #div_even	[01]
135a		slil d #div_even	[09]
135b		jmpfar	d d
135c		pop	b
135d		pop	c
135e		pop	d
135f		page	a	
		; last three bits * 32 is the address

1360		pop	a
1361		sliu d 0
1362		slil d 7
1363		nand	a d
1364		nand	a a
1365		sliu b 2
1366		slil b 0	; calling global function mul

1367		push	d
1368		push	c
1369		push	b
136a		sliu d 1
136b		slil d 3
136c		push	d
136d		push	c
136e		sliu c 0
136f		slil c 7
1370		sliu d #mul	[04]
1371		slil d #mul	[08]
1372		jmpfar	d d
1373		pop	b
1374		pop	c
1375		pop	d	
		;copy string from stack

1376		sliu c 2
1377		slil c 0
1378	#basic_saveline_poploop
1378		pop	b
1379		store	b [a]
137a		inc	a
137b		dec	c
137c		sliu d #basic_saveline_poploop	[07]
137d		slil d #basic_saveline_poploop	[08]
137e		skipz	c
137f		jalr	d d
1380		pop	d
1381		pop	c
1382		jmpfar	d d	
	; basic_saveline ends
	
	

1383		org 1400	
	
	; ------- GLOBAL FUNCTION dectobin -------

1400	#dectobin
1400		pop	c
1401		push	d		;page in A, string addr in B terminated in ' ' or 0, returns num in A
	

1402		page	a
1403		sub	a a
1404	#dectobin_digloop
1404		load	c [b]		; check if digit is a ' ' or  \0

1405		sliu d #dectobin_digdone	[02]
1406		slil d #dectobin_digdone	[0c]
1407		skipnz	c
1408		jalr	d d
1409		sliu d 2
140a		slil d 0
140b		sub	c d
140c		sliu d #dectobin_digdone	[02]
140d		slil d #dectobin_digdone	[0c]
140e		skipnz	c
140f		jalr	d d	
		; multiply a = a * 10

1410		push	b
1411		sliu b 0
1412		slil b 10	; calling global function mul

1413		push	d
1414		push	c
1415		push	b
1416		sliu d 1
1417		slil d 4
1418		push	d
1419		push	c
141a		sliu c 0
141b		slil c 7
141c		sliu d #mul	[04]
141d		slil d #mul	[08]
141e		jmpfar	d d
141f		pop	b
1420		pop	c
1421		pop	d
1422		pop	b	
		; add digit

1423		load	c [b]
1424		add	a c
1425		sliu d 3
1426		slil d 0
1427		sub	a d	

1428		inc	b
1429		sliu d #dectobin_digloop	[00]
142a		slil d #dectobin_digloop	[04]
142b		jalr	d d
142c	#dectobin_digdone
142c		pop	d
142d		pop	c
142e		jmpfar	d d	
	; dectobin ends
	
	
	

142f		org 1500	
	; ------- GLOBAL FUNCTION basic_doline -------

1500	#basic_doline
1500		pop	c
1501		push	d
1502		pop	d
1503		pop	c
1504		jmpfar	d d	
	; basic_doline ends
	
	

1505		org 7e00
7e00	#keywords
7e00		db	0x3d
7e01		db	0
7e02		db	0x3d
7e03		db	0
7e04		db	0x3c
7e05		db	0x3e
7e06		db	0
7e07		db	0x21
7e08		db	0
7e09		db	0x3c
7e0a		db	0
7e0b		db	0x3c
7e0c		db	0
7e0d		db	0x3e
7e0e		db	0
7e0f		db	0x3e
7e10		db	0
7e11		db	0x3c
7e12		db	0x3d
7e13		db	0
7e14		db	0x6c
7e15		db	0
7e16		db	0x3e
7e17		db	0x3d
7e18		db	0
7e19		db	0x67
7e1a		db	0
7e1b		db	0x2b
7e1c		db	0
7e1d		db	0x2b
7e1e		db	0
7e1f		db	0x2d
7e20		db	0
7e21		db	0x2d
7e22		db	0
7e23		db	0x2a
7e24		db	0
7e25		db	0x2a
7e26		db	0
7e27		db	0x2f
7e28		db	0
7e29		db	0x2f
7e2a		db	0
7e2b		db	0x28
7e2c		db	0
7e2d		db	0x28
7e2e		db	0
7e2f		db	0x29
7e30		db	0
7e31		db	0x29
7e32		db	0
7e33		db	0x2c
7e34		db	0
7e35		db	0x2c
7e36		db	0		; ; char

7e37		db	0x3b
7e38		db	0
7e39			db	0x3b
7e3a			db	0
7e3b		db	0x50
7e3c		db	0x52
7e3d		db	0x49
7e3e		db	0x4e
7e3f		db	0x54
7e40		db	0
7e41		db	0x50
7e42		db	0
7e43		db	0x49
7e44		db	0x46
7e45		db	0
7e46		db	0x49
7e47		db	0
7e48		db	0x54
7e49		db	0x48
7e4a		db	0x45
7e4b		db	0x4e
7e4c		db	0
7e4d		db	0x54
7e4e		db	0
7e4f		db	0x47
7e50		db	0x4f
7e51		db	0x54
7e52		db	0x4f
7e53		db	0
7e54		db	0x47
7e55		db	0
7e56		db	0x49
7e57		db	0x4e
7e58		db	0x50
7e59		db	0x55
7e5a		db	0x54
7e5b		db	0
7e5c		db	0x55
7e5d		db	0
7e5e		db	0x4c
7e5f		db	0x45
7e60		db	0x54
7e61		db	0
7e62		db	0x4c
7e63		db	0
7e64		db	0x47
7e65		db	0x4f
7e66		db	0x53
7e67		db	0x55
7e68		db	0x42
7e69		db	0
7e6a		db	0x53
7e6b		db	0
7e6c		db	0x52
7e6d		db	0x45
7e6e		db	0x54
7e6f		db	0x55
7e70		db	0x52
7e71		db	0x4e
7e72		db	0
7e73		db	0x52
7e74		db	0
7e75		db	0x4c
7e76		db	0x49
7e77		db	0x53
7e78		db	0x54
7e79		db	0
7e7a		db	0x73
7e7b		db	0
7e7c		db	0x52
7e7d		db	0x55
7e7e		db	0x4e
7e7f		db	0
7e80		db	0x72
7e81		db	0
7e82		db	0x45
7e83		db	0x4e
7e84		db	0x44
7e85		db	0
7e86		db	0x45
7e87		db	0
7e88		db	0x46
7e89		db	0x4f
7e8a		db	0x52
7e8b		db	0
7e8c		db	0x46
7e8d		db	0
7e8e		db	0x54
7e8f		db	0x4f
7e90		db	0
7e91		db	0x50
7e92		db	0
7e93		db	0x4e
7e94		db	0x45
7e95		db	0x58
7e96		db	0x54
7e97		db	0
7e98		db	0x58
7e99		db	0
7e9a		db	0x53
7e9b		db	0x54
7e9c		db	0x45
7e9d		db	0x50
7e9e		db	0
7e9f		db	0x74
7ea0		db	0
7ea1		db	0x44
7ea2		db	0x49
7ea3		db	0x4d
7ea4		db	0
7ea5		db	0x44
7ea6		db	0
7ea7		db	0x52
7ea8		db	0x4e
7ea9		db	0x44
7eaa		db	0
7eab		db	0x6e
7eac		db	0
7ead		db	0	

7eae		org 7f00
7f00	#monitor_message
7f00		db	0x52
7f01		db	0x49
7f02		db	0x53
7f03		db	0x43
7f04		db	0x59
7f05		db	0x20
7f06		db	0x4d
7f07		db	0x6f
7f08		db	0x6e
7f09		db	0x69
7f0a		db	0x74
7f0b		db	0x6f
7f0c		db	0x72
7f0d		db	0
7f0e	#basic_message
7f0e		db	0x54
7f0f		db	0x69
7f10		db	0x6e
7f11		db	0x79
7f12		db	0x20
7f13		db	0x42
7f14		db	0x41
7f15		db	0x53
7f16		db	0x49
7f17		db	0x43
7f18		db	0
7f19	#basic_prompt
7f19		db	0x4f
7f1a		db	0x6b
7f1b		db	0
7f1c	#newline
7f1c		db	0x0d
7f1d		db	0x0a
7f1e		db	0x00
